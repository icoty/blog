{"meta":{"title":"阳光沥肩头 仿佛自由人","subtitle":null,"description":"Linux C++服务端","author":"icoty","url":"http://yoursite.com","root":"/"},"pages":[{"title":"杨宇","date":"2019-04-12T14:41:48.000Z","updated":"2019-04-17T18:21:20.491Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"ME 男 / 1992 QQ/WeChat：604381117 1864030** / icoty.yangy@gmail.com 技术博客：https://icoty.github.io Leetcode：https://github.com/icoty/LeetCode EDUCATION 北京大学 - 软件工程 / 2018.09～至今 东北大学 - 工业工程 / 2011.09～2015.07 EXPERIENCE浙江大华（ 2018年2月 ~ 2018年9月 ）第三方SDK集成 项目说明：客户的平台通过调用中间SDK API与公司内部平台通信。 功能实现： 在SDK进程中嵌入一个RTSP Client从公司内部平台拉取音视频流之后调用客户的SDK API接口直接推给客户的平台； 在SDK进程中开启一个RPC Client与公司的内部平台通信，SDK进程接收到SDK API的通知消息（由客户的平台发送过来）后立即封装成RPC请求交给RPC Client处理。 相关技术：RTSP拉流，RPC，网络编程，函数指针与函数回调。 第三方智能算法集成 项目说明：内部应用采集的音视频流，需要进行智能算法分析（如人脸检测，区域检测，车辆检测等），客户自己提供了一套算法库来分析这些过程，同时客户也自己开发了一个web界面需要与其自己的算法库通信，由于网络安全限制，客户的web请求不能直接与其自己的算法库通信，必须经由内部应用转发。 功能实现： 三方算法库进程集成HttpServer专职接受第三方web请求，然后回调至算法库内部； 三方算法库进程集成RpcClient专职接受经算法库处理后的元数据，然后发送到内部应用的RpcServer端口进行处理； 开辟两个共享内存专职把内部采集的到音视频传送到算法库进程。 相关技术：Http，共享内存，SDK。 矩阵元（深圳）技术 （ 2017年4月 ~ 2017年10月 ）Jenkins持续集成工具 项目说明：通过Jenkins管理产品分支，持续集成工具部署 功能实现： Jenkins搭建与配置； Redhat与Centos平台的版本功能持续验证，Docker平台的探索； Shell脚本，集代码分支、编译、测试、安装、Docker镜像制作和版本发布为一体； 对接Android、IOS、Web端联调、输出详细设计文档。 ARTICLE 进程间通信-利用共享内存和管道通信实现聊天窗口 SKILLS Linux/vim/Makefile/gcc/gdb Mysql C/C++/STL TCP/Socket/Epoll/IPC Shell Docker Http Nginx 数据结构 微信小程序开发 Python/MVP框架 ThinkPHP/MVC框架"},{"title":"分类","date":"2019-04-12T14:45:46.000Z","updated":"2019-04-13T09:28:17.759Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-12T14:45:34.000Z","updated":"2019-04-13T09:28:12.902Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux下Docker快速部署LAMP","slug":"hello-world","date":"2019-04-17T17:36:13.860Z","updated":"2019-04-16T15:11:13.554Z","comments":true,"path":"2019/04/18/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/18/hello-world/","excerpt":"","text":"若你的mac或Linux环境上未安装Docker，请移步Docker安装，确认安装成功之后再进行下文内容。 Quick Start获取基础镜像12$ docker pull tutum/lamp # 从Docker Hub上的tutum用户的仓库获取lamp镜像$ docker images # 列出所有的镜像，会发现多一条记录：tutum/lamp 本文用的镜像源tutum/lamp，目前Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像，开发者可以注册自己的账号，并自定义自己的镜像进行存储，需要的时候可以直接拿来用，同时也能够分享，有点类似于Github。如想注册可移步 Docker Hub。 自定义你的镜像在一个空的目录下新建Dockerfile文件名，填入如下4行内容。1234FROM tutum/lamp:latest # 表示在镜像tutum/lamp:latest之上自定义你的镜像RUN rm -fr /app # 后面会把你的php项目映射到容器的/app/目录下EXPOSE 80 3306 # 暴露80 3306端口CMD [\"/run.sh\"] # 当容器启动后会自动执行容器内部的/run.sh脚本 在Dockerfile的同级目录执行如下命令，该命令会去执行Dockerfile脚本，并构建新的镜像username/my-lamp-app，其中my-lamp-app为自定义的镜像名字，命名成你的即可。如果注册了docker hub，一般将username换层你的用户名，如未注册，可以随便取。我执行的是：“docker build -t icoty1/lamp .”1$ docker build -t username/my-lamp-app . 基于你的镜像运行一个容器1$ docker run -d -v /home/icoty/app/:/app/ -p 80:80 -p 3306:3306 username/my-lamp-app -v /home/icoty/app/:/app/ 表示将/home/icoty/app/目录映射到容器内部的/app/目录，其中/home/icoty/app/为我的php项目存放位置，需要换成你的。 -p 80:80 表示将本机的80端口映射到容器内部的80端口，在容器外面是无法直接访问容器内部端口的，映射后才可以，这样当本机80端口收到数据后会自动转发给容器内部的80端口，不过在容器内部是可以直接访问其他远程主机的，这点保证了容器的封闭性和安全性。 username/my-lamp-app 为前面自定义的镜像名称。 权限修改123$ docker ps -a # 查看上一步运行的容器，找到username/my-lamp-app对应的CONTAINER ID$ docker exec -it ID /bin/bash # 根据容器ID进入容器，其中ID为前一句找到的CONTAINER ID$ chown -R www-data:www-data /app/ # 将php项目目录权限修改为运行apache的用户组，否则会因为权限不够，web页面打不开 访问测试1http://ip/public/index.php 注意：/app/目录下的各个子目录下如果存在.htaccess 文件，会导致web页面无法访问对应子目录，只需将.htaccess重命名为.htaccess.bak即可解决。","categories":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/categories/IDE/"}],"tags":[{"name":"LAMP","slug":"LAMP","permalink":"http://yoursite.com/tags/LAMP/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"进程间通信-利用共享内存和管道通信实现聊天窗口","slug":"ipc-chat","date":"2019-04-17T16:16:06.000Z","updated":"2019-04-18T02:13:31.331Z","comments":true,"path":"2019/04/18/ipc-chat/","link":"","permalink":"http://yoursite.com/2019/04/18/ipc-chat/","excerpt":"","text":"问题模型 A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据通过共享内存传递给B1进程显示； 对于A、B 进程，采用ctrl+c（实际为SIGINT信号）方式退出，A、B进程通过捕捉SIGINT信号注册信号处理函数进行资源清理，A1、B1进程手动关闭即可。 特别注意 A、B通过管道通信，如果首先通过ctrl+c退出A进程，那么B进程的fifo1管道的写端会收到SIGPIPE信号而终止B进程，因此必须在B进程终止前清理掉被B占用的共享内存2，将共享内存2的引用计数减一，否则，当B1进程退出并清理共享内存2后，共享内存2的引用计数不为0，会导致共享内存2得不到释放； 为了解决前一个问题，A、B进程在启动后立即将各自的进程id通过管道发送给对方，并在各自的进程退出时向对方进程id发送SIGINT信号，触发对方进程进入信号处理接口执行资源回收工作； A和A1通过共享内存1通信，会从A进程和A1进程的虚拟地址空间分配一段连续的页映射到同一块连续的物理内存页上，这样A、A1两个进程都可以间接访问物理内存页，从而达到通信的目的，一般共享内存需要进行保护，读写不能同时进行，也不能同时进行写操作，共享内存省去了从内核缓冲区到用户缓冲区的拷贝，因此效率高。 编码与效果图 func.h:12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;strings.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/uio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt; processA.cpp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"func.h\"int shmid;int pidB; // 存放对端进程B的进程id号char *p; // 共享内存指针// 回收共享内存资源前先杀死对端进程，否则回收失败void handle(int num)&#123; kill(pidB, SIGINT); shmdt(p); int ret; if(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) &#123; perror(\"shmctl\"); return (void)-1; &#125; exit(0);&#125;int main(int argc, char **argv)&#123; signal(SIGINT, handle); if(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666))) &#123; perror(\"shmget\"); return -1; &#125; if((char*)-1 == (p=(char*)shmat(shmid, NULL, 0))) &#123; perror(\"shmat\"); return -1; &#125; // 管道文件为单工通信方式，因此需要建立两条管道 // A进程通过管道文件fifo1的读端fdr读取B进程发送的数据 // A进程通过管道文件fifo2的写端fdw向B进程发送数据 int fdr, fdw; if(-1 == (fdr=open(\"fifo1\", O_RDONLY)) || -1 == (fdw=open(\"fifo2\", O_WRONLY))) &#123; perror(\"open fifo1 or open fifo2\"); return -1; &#125; // 通信之前先通过管道互相告知对方自己的进程id char s1[10] = &#123;0&#125;; char s2[10] = &#123;0&#125;; sprintf(s1, \"%d\\n\", getpid()); write(fdw, s1, strlen(s1) - 1); read(fdr, s2, strlen(s1) - 1); pidB = atoi(s2); printf(\"pipe connect success, A to A1 shmid:[%d], pidA:[%d], pidB:[%d]\\n\", shmid, getpid(), pidB); char buf[1024] = &#123;0&#125;; int ret; fd_set rdset; while(true) &#123; FD_ZERO(&amp;rdset); FD_SET(0, &amp;rdset); FD_SET(fdr, &amp;rdset); if((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0)) &#123; // fdr可读,则接收数据之后通过共享内存传给A1 if(FD_ISSET(fdr, &amp;rdset)) &#123; bzero(buf, sizeof(buf)); if(read(fdr, buf, sizeof(buf)) &gt; 0) &#123; strncpy(p, buf, sizeof(buf)); &#125; else &#123; break; &#125; &#125; // 标准输入可读,读出来传递给B进程 if(FD_ISSET(0, &amp;rdset)) &#123; bzero(buf, sizeof(buf)); if(read(STDIN_FILENO, buf, sizeof(buf)) &gt; 0) &#123; write(fdw, buf, strlen(buf) - 1); &#125; else &#123; break; &#125; &#125; &#125; &#125; close(fdr); close(fdw); return 0;&#125; processB.cpp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"func.h\"int shmid;int pidA; // 存放对端进程idchar *p; // 共享内存指针// 回收共享内存资源前先杀死对端进程，否则回收失败void handle(int num)&#123; kill(pidA, SIGINT); shmdt(p); int ret; if(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) &#123; perror(\"shmctl\"); return (void)-1; &#125; exit(0);&#125;int main(int argc, char **argv)&#123; signal(SIGINT, handle); if(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666))) &#123; perror(\"shmget\"); return -1; &#125; if((char*)-1 == (p=(char*)shmat(shmid, NULL, 0))) &#123; perror(\"shmat\"); return -1; &#125; // 管道文件为单工通信方式 // B进程通过管道文件fifo1的写端fdw向A进程发送数据 // B进程通过管道文件fifo2的读端fdr接收A进程的数据 int fdr, fdw; if(-1 == (fdw=open(\"fifo1\", O_WRONLY)) || -1 == (fdr=open(\"fifo2\", O_RDONLY))) &#123; perror(\"open fifo1 or open fifo2\"); return -1; &#125; // 通信之前先通过管道互相告知对方自己的进程id char s1[10] = &#123;0&#125;; char s2[10] = &#123;0&#125;; sprintf(s1, \"%d\\n\", getpid()); write(fdw, s1, strlen(s1) - 1); read(fdr, s2, strlen(s1) - 1); pidA = atoi(s2); printf(\"pipe connect success, B to B1 shmid:[%d], pidA:[%d], pidB:[%d]\\n\", shmid, pidA, getpid()); char buf[1024] = &#123;0&#125;; int ret; fd_set rdset; while(true) &#123; FD_ZERO(&amp;rdset); FD_SET(0, &amp;rdset); FD_SET(fdr, &amp;rdset); if((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0)) &#123; // fdr可读,则接收数据之后通过共享内存传给B1 if(FD_ISSET(fdr, &amp;rdset)) &#123; bzero(buf, sizeof(buf)); if(read(fdr, buf, sizeof(buf)) &gt; 0) &#123; strncpy(p, buf, sizeof(buf)); &#125; else &#123; break; &#125; &#125; // 标注输入可读,读出来传递给A进程 if(FD_ISSET(0, &amp;rdset)) &#123; bzero(buf, sizeof(buf)); if(read(STDIN_FILENO, buf, sizeof(buf)) &gt; 0) &#123; write(fdw, buf, strlen(buf) - 1); &#125; else &#123; break; &#125; &#125; &#125; &#125; close(fdr); close(fdw); return 0;&#125; processA1.cpp：123456789101112131415161718192021222324252627282930313233343536373839404142#include \"fuprintf(\"p:%s\\n\", p);nc.h\"int main(void)&#123; char buf[1024] = &#123;0&#125;; int shmid; if(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666))) &#123; perror(\"shmget\"); return -1; &#125; char *p; if((char*)-1 == (p=(char*)shmat(shmid, NULL, 0))) &#123; perror(\"shmat\"); return -1; &#125; while(true) &#123; if(!(strcmp(buf, p))) &#123; continue; &#125; else &#123; // 共享内存有数据可读 bzero(buf, sizeof(buf)); strcpy(buf, p); printf(\"I am A1, recv from A:[%s]\\n\", buf); &#125; &#125; if(-1 ==(shmctl(shmid, IPC_RMID, 0))) &#123; perror(\"shmctl\"); return -1; &#125; return 0;&#125; processB1.cpp：123456789101112131415161718192021222324252627282930313233343536373839404142#include \"func.h\"int main(void)&#123; char buf[1024] = &#123;0&#125;; int shmid; if(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666))) &#123; perror(\"shmget\"); return -1; &#125; char *p; if((char*)-1 == (p=(char*)shmat(shmid, NULL, 0))) &#123; perror(\"shmat\"); return -1; &#125; while(true) &#123; if(!(strcmp(buf, p))) &#123; continue; &#125; else &#123; // 共享内存有数据可读 bzero(buf, sizeof(buf)); strcpy(buf, p); printf(\"I am B1, recv from B:[%s]\\n\", buf); &#125; &#125; if(-1 ==(shmctl(shmid, IPC_RMID, 0))) &#123; perror(\"shmctl\"); return -1; &#125; return 0;&#125; 回收资源 这里首先通过ctrl+c退出A进程，然后B进程收到SIGPIPE信号退出，A、B进程同时调用各自的信号处理函数回收资源，通过ipcs命令发现拥有者为root的共享内存资源的nattch都为1，分别被A1和B1占有。 然后手动关闭A1、B1进程，再次执行ipcs命令，发现拥有者为root的共享内存资源不存在，已经释放成功。1$ ipcs # 查看共性内存资源数量 源码获取本文所有源码链接","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"IPC","slug":"IPC","permalink":"http://yoursite.com/tags/IPC/"},{"name":"共享内存","slug":"共享内存","permalink":"http://yoursite.com/tags/共享内存/"},{"name":"命名管道","slug":"命名管道","permalink":"http://yoursite.com/tags/命名管道/"},{"name":"信号","slug":"信号","permalink":"http://yoursite.com/tags/信号/"},{"name":"select","slug":"select","permalink":"http://yoursite.com/tags/select/"}]}]}
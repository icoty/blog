<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荒野之萍</title>
  
  <subtitle>忙着活或忙着死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://icoty.github.io/"/>
  <updated>2019-06-09T07:49:35.000Z</updated>
  <id>https://icoty.github.io/</id>
  
  <author>
    <name>杨宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XV6源代码阅读-虚拟内存管理</title>
    <link href="https://icoty.github.io/2019/06/09/xv6-virtual-memory/"/>
    <id>https://icoty.github.io/2019/06/09/xv6-virtual-memory/</id>
    <published>2019-06-09T03:18:06.000Z</published>
    <updated>2019-06-09T07:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h2><ol><li>内存管理部分: kalloc.c vm.c 以及相关其他文件代码</li></ol><ul><li>kalloc.c：char <em> kalloc(void)负责在需要的时候为用户空间、内核栈、页表页以及缓冲区分配物理内存，将物理地址转为虚拟地址返回，物理页大小为4k。void kfree(char </em> v)接收一个虚拟地址，找对对应的物理地址进行释放。xv6使用空闲内存的前部分作为指针域来指向下一页空闲内存，物理内存管理是以页（4K）为单位进行分配的。物理内存空间上空闲的每一页，都有一个指针域（虚拟地址）指向下一个空闲页，最后一个空闲页为NULL ，通过这种方式，kmem只需要保存着虚拟地址空间上的freelist地址即可；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// kalloc.c</span><br><span class="line">// Physical memory allocator, intended to allocate</span><br><span class="line">// memory <span class="keyword">for</span> user processes, kernel stacks, page table pages,</span><br><span class="line">// and pipe buffers. Allocates 4096-byte pages.</span><br><span class="line"></span><br><span class="line">void freerange(void *vstart, void *vend);</span><br><span class="line">extern char end[]; // first address after kernel loaded from ELF file</span><br><span class="line"></span><br><span class="line">struct run &#123;</span><br><span class="line">  struct run *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  int use_lock;</span><br><span class="line">  struct run *freelist;</span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><ul><li>xv6让每个进程都有独立的页表结构，在切换进程时总是需要切换页表，switchkvm设置cr3寄存器的值为kpgdir首地址，kpgdir仅仅在scheduler内核线程中使用。页表和内核栈都是每个进程独有的，xv6使用结构体proc将它们统一起来，在进程切换的时候，他们也往往随着进程切换而切换，内核中模拟出了一个内核线程，它独占内核栈和内核页表kpgdir，它是所有进程调度的基础。switchuvm通过传入的proc结构负责切换相关的进程独有的数据结构，其中包括TSS相关的操作，然后将进程特有的页表载入cr3寄存器，完成设置进程相关的虚拟地址空间环境；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// vm.c</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">// Switch h/w page table register to the kernel-only page table,</span><br><span class="line">// <span class="keyword">for</span> when no process is running.</span><br><span class="line">void</span><br><span class="line">switchkvm(void)</span><br><span class="line">&#123;</span><br><span class="line">  lcr3(v2p(kpgdir));   // switch to the kernel page table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Switch TSS and h/w page table to correspond to process p.</span><br><span class="line">void</span><br><span class="line">switchuvm(struct proc *p)</span><br><span class="line">&#123;</span><br><span class="line">  pushcli();</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;cpu-&gt;ts, sizeof(cpu-&gt;ts)-1, 0);</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS].s = 0;</span><br><span class="line">  cpu-&gt;ts.ss0 = SEG_KDATA &lt;&lt; 3;</span><br><span class="line">  cpu-&gt;ts.esp0 = (uint)proc-&gt;kstack + KSTACKSIZE;</span><br><span class="line">  ltr(SEG_TSS &lt;&lt; 3);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pgdir == 0)</span><br><span class="line">    panic(<span class="string">"switchuvm: no pgdir"</span>);</span><br><span class="line">  lcr3(v2p(p-&gt;pgdir));  // switch to new address space</span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进程的页表在使用前往往需要初始化，其中必须包含内核代码的映射，这样进程在进入内核时便不需要再次切换页表，进程使用虚拟地址空间的低地址部分，高地址部分留给内核，主要接口：<ul><li>pde_t * setupkvm(void)通过kalloc分配一页内存作为页目录，然后将按照kmap数据结构映射内核虚拟地址空间到物理地址空间，期间调用了工具函数mappages；</li><li>int allocuvm(pde_t * pgdir, uint oldsz, uint newsz)在设置页表的同时分配虚拟地址oldsz到newsz的以页为单位的内存；</li><li>int deallocuvm(pde_t * pgdir, uint oldsz, uint newsz)则将newsz到oldsz对应的虚拟地址空间内存置为空闲；</li><li>int loaduvm(pde_t <em> pgdir, char </em> addr, struct inode * ip, uint offset, uint sz)将文件系统上的i节点内容读取载入到相应的地址上，通过allocuvm接口为用户进程分配内存和设置页表，然后调用loaduvm接口将文件系统上的程序载入到内存，便能够为exec系统调用提供接口，为用户进程的正式运行做准备；</li><li>当进程销毁需要回收内存时，调用void freevm(pde_t * pgdir)清除用户进程相关的内存环境，其首先调用将0到KERNBASE的虚拟地址空间回收，然后销毁整个进程的页表；</li><li>pde_t <em> copyuvm(pde_t </em> pgdir, uint sz)负责复制一个新的页表并分配新的内存，新的内存布局和旧的完全一样，xv6使用这个函数作为fork()底层实现。</li></ul></li></ul><h2 id="Exercise2-带着问题阅读"><a href="#Exercise2-带着问题阅读" class="headerlink" title="Exercise2 带着问题阅读"></a>Exercise2 带着问题阅读</h2><ol><li>XV6初始化之后到执行main.c时，内存布局是怎样的(其中已有哪些内容)?</li></ol><ul><li><p>内核代码存在于物理地址低地址的0x100000处，页表为main.c文件中的entrypgdir数组，其中虚拟地址低4M映射物理地址低4M，虚拟地址 [KERNBASE, KERNBASE+4MB) 映射到 物理地址[0, 4MB)；</p></li><li><p>紧接着调用kinit1初始化内核末尾到物理内存4M的物理内存空间为未使用，然后调用kinit2初始化剩余内核空间到PHYSTOP为未使用。kinit1调用前使用的还是最初的页表（也就是是上面的内存布局），所以只能初始化4M，同时由于后期再构建新页表时也要使用页表转换机制来找到实际存放页表的物理内存空间，这就构成了自举问题，xv6通过在main函数最开始处释放内核末尾到4Mb的空间来分配页表，由于在最开始时多核CPU还未启动，所以没有设置锁机制。kinit2在内核构建了新页表后，能够完全访问内核的虚拟地址空间，所以在这里初始化所有物理内存，并开始了锁机制保护空闲内存链表；</p></li><li>然后main函数通过调用void kvmalloc(void)函数来实现内核新页表的初始化；</li><li>最后内存布局和地址空间如下：内核末尾物理地址到物理地址PHYSTOP的内存空间未使用，虚拟地址空间KERNBASE以上部分映射到物理内存低地址相应位置。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// kalloc.c</span><br><span class="line">// Initialization happens <span class="keyword">in</span> two phases.</span><br><span class="line">// 1. main() calls kinit1() <span class="keyword">while</span> still using entrypgdir to place just</span><br><span class="line">// the pages mapped by entrypgdir on free list.</span><br><span class="line">// 2. main() calls kinit2() with the rest of the physical pages</span><br><span class="line">// after installing a full page table that maps them on all cores.</span><br><span class="line">void</span><br><span class="line">kinit1(void *vstart, void *vend)</span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">"kmem"</span>);</span><br><span class="line">  kmem.use_lock = 0;</span><br><span class="line">  freerange(vstart, vend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">kinit2(void *vstart, void *vend)</span><br><span class="line">&#123;</span><br><span class="line">  freerange(vstart, vend);</span><br><span class="line">  kmem.use_lock = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// kmap.c</span><br><span class="line">……</span><br><span class="line">// This table defines the kernel<span class="string">'s mappings, which are present in</span></span><br><span class="line"><span class="string">// every process'</span>s page table.</span><br><span class="line">static struct kmap &#123;</span><br><span class="line">  void *virt;</span><br><span class="line">  uint phys_start;</span><br><span class="line">  uint phys_end;</span><br><span class="line">  int perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line"> &#123; (void*)KERNBASE, 0,             EXTMEM,    PTE_W&#125;, // I/O space</span><br><span class="line"> &#123; (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0&#125;,     // kern text+rodata</span><br><span class="line"> &#123; (void*)data,     V2P(data),     PHYSTOP,   PTE_W&#125;, // kern data+memory</span><br><span class="line"> &#123; (void*)DEVSPACE, DEVSPACE,      0,         PTE_W&#125;, // more devices</span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><ol start="2"><li><p>XV6 的动态内存管理是如何完成的? 有一个kmem(链表)，用于管理可分配的物理内存页。(vend=0x00400000，也就是可分配的内存页最大为4Mb)<br>详见“Exercise 1  源代码阅读”部分，已经作出完整解答。</p></li><li><p>XV6的虚拟内存是如何初始化的? 画出XV6的虚拟内存布局图，请说出每一部分对应的内容是什么。见memlayout.h和vm.c的kmap上的注释?</p></li></ol><ul><li><p>main函数通过调用void kinit1(void <em> vstart, void </em> vend), void kinit2(void <em> vstart, void </em> vend), void kvmalloc(void)函数来实现内核新页表的初始化。虚拟地址与物理地址的转换接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// memlayout.h</span><br><span class="line">// Memory layout</span><br><span class="line"></span><br><span class="line"><span class="comment">#define EXTMEM  0x100000            // Start of extended memory</span></span><br><span class="line"><span class="comment">#define PHYSTOP 0xE000000           // Top physical memory</span></span><br><span class="line"><span class="comment">#define DEVSPACE 0xFE000000         // Other devices are at high addresses</span></span><br><span class="line"></span><br><span class="line">// Key addresses <span class="keyword">for</span> address space layout (see kmap <span class="keyword">in</span> vm.c <span class="keyword">for</span> layout)</span><br><span class="line"><span class="comment">#define KERNBASE 0x80000000         // First kernel virtual address</span></span><br><span class="line"><span class="comment">#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line">static inline uint v2p(void *a) &#123; <span class="built_in">return</span> ((uint) (a))  - KERNBASE; &#125;</span><br><span class="line">static inline void *p2v(uint a) &#123; <span class="built_in">return</span> (void *) ((a) + KERNBASE); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define V2P(a) (((uint) (a)) - KERNBASE)</span></span><br><span class="line"><span class="comment">#define P2V(a) (((void *) (a)) + KERNBASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts</span></span><br><span class="line"><span class="comment">#define P2V_WO(x) ((x) + KERNBASE)    // same as V2P, but without casts</span></span><br></pre></td></tr></table></figure></li><li><p>内存布局：</p></li></ul><p><img src="/2019/06/09/xv6-virtual-memory/memlayout" alt="聊天窗口模型"></p><ol start="4"><li>关于XV6 的内存页式管理。发生中断时，用哪个页表? 一个内存页是多大? 页目录有多少项? 页表有多少项? 最大支持多大的内存? 画出从虚拟地址到物理地址的转换图。在XV6中，是如何将虚拟地址与物理地址映射的(调用了哪些函数实现了哪些功能)?</li></ol><ul><li>发生中断时，将换入cpu的进程的页表首地址存入cr3寄存器；一个内存页为4k；XV6页表采用的二级目录，一级目录有$2^{10}$条，二级目录有$2^{10} * 2^{10}$条；页表项为$2^2$Bytes，故页表有$2^{12} / 2^2 = 2^{10} = 1024$项；最大支持4G内存；</li></ul><p><img src="/2019/06/09/xv6-virtual-memory/V2P" alt="聊天窗口模型"></p><ul><li>物理内存页的申请与释放，虚拟地址与物理地址如何映射等在“Exercise 1  源代码阅读”都已经详述了，在此主要说下mappages接口，虚拟地址 <em> va与物理地址 </em> pa映射size个字节，同时赋予该页的权限perm，如下:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// vm.c</span><br><span class="line">……</span><br><span class="line">// Create PTEs <span class="keyword">for</span> virtual addresses starting at va that refer to</span><br><span class="line">// physical addresses starting at pa. va and size might not</span><br><span class="line">// be page-aligned.</span><br><span class="line">static int</span><br><span class="line">mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)</span><br><span class="line">&#123;</span><br><span class="line">  char *a, *last;</span><br><span class="line">  pte_t *pte;</span><br><span class="line">  </span><br><span class="line">  a = (char*)PGROUNDDOWN((uint)va);</span><br><span class="line">  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walkpgdir(pgdir, a, 1)) == 0)</span><br><span class="line">      <span class="built_in">return</span> -1;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_P)</span><br><span class="line">      panic(<span class="string">"remap"</span>);</span><br><span class="line">    *pte = pa | perm | PTE_P;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/hehao98/p/10683588.html" rel="external nofollow noopener noreferrer" target="_blank">xv6虚拟内存-博客园</a><br>[2] <a href="http://linbo.github.io/2017/10/01/xv6-vm" rel="external nofollow noopener noreferrer" target="_blank">xv6 virtual memory-hexo</a><br>[3] <a href="https://www.jianshu.com/p/13921afe0fde" rel="external nofollow noopener noreferrer" target="_blank">xv6内存管理-简书</a><br>[4] <a href="https://blog.csdn.net/qq_25426415/article/details/54633843" rel="external nofollow noopener noreferrer" target="_blank">xv6内存管理-CSDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Exercise1-源代码阅读&quot;&gt;&lt;a href=&quot;#Exercise1-源代码阅读&quot; class=&quot;headerlink&quot; title=&quot;Exercise1 源代码阅读&quot;&gt;&lt;/a&gt;Exercise1 源代码阅读&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内存管理部分: kall
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="XV6" scheme="https://icoty.github.io/tags/XV6/"/>
    
      <category term="虚拟内存" scheme="https://icoty.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>XV6源代码阅读-中断与系统调用</title>
    <link href="https://icoty.github.io/2019/06/09/xv6-interrupt-systemcall/"/>
    <id>https://icoty.github.io/2019/06/09/xv6-interrupt-systemcall/</id>
    <published>2019-06-09T03:17:35.000Z</published>
    <updated>2019-06-09T08:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h2><ol><li>启动部分: bootasm.S bootmain.c 和xv6初始化模块:main.c</li></ol><ul><li>bootasm.S 由16位和32位汇编混合编写成的XV6引导加载器。bootasm.S内的汇编代码会调用bootmain.c中的void bootmain(void)；main.c主函数内部初始化各模块；</li><li>当x86 PC启动时，它执行的是一个叫BIOS的程序。BIOS存放在非易失存储器中，BIOS的作用是在启动时进行硬件的准备工作，接着把控制权交给操作系统。具体来说，BIOS会把控制权交给从磁盘第0块引导扇区（用于引导的磁盘的第一个512字节的数据区）加载的代码。引导扇区中包含引导加载器——负责内核加载到内存中。BIOS 会把引导扇区加载到内存 0x7c00 处，接着（通过设置寄存器 %ip）跳转至该地址。引导加载器开始执行后，处理器处于模拟Intel 8088处理器的模式下。而接下来的工作就是把处理器设置为现代的操作模式，并从磁盘中把 xv6内核载入到内存中，然后将控制权交给内核。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start the first CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class="line"><span class="comment"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class="line"><span class="comment"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class="line"><span class="comment"># with %cs=0 %ip=7c00.</span></span><br><span class="line"></span><br><span class="line">.code16                       <span class="comment"># Assemble for 16-bit mode</span></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  cli                         <span class="comment"># BIOS enabled interrupts; disable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Zero data segment registers DS, ES, and SS.</span></span><br><span class="line">  xorw    %ax,%ax             <span class="comment"># Set %ax to zero</span></span><br><span class="line">  movw    %ax,%ds             <span class="comment"># -&gt; Data Segment</span></span><br><span class="line">  movw    %ax,%es             <span class="comment"># -&gt; Extra Segment</span></span><br><span class="line">  movw    %ax,%ss             <span class="comment"># -&gt; Stack Segment</span></span><br></pre></td></tr></table></figure><ol start="2"><li>中断与系统调用部分: trap.c trapasm.S vectors.S &amp; vectors.pl syscall.c sysproc.c proc.c 以及相关其他文件代码</li></ol><ul><li>trap.c 陷入指令c语言处理接口，trapasm.S陷入指令的汇编逻辑；</li><li>vector.S由vector.pl生成，中断描述符256个；</li><li>proc.c 内部主要接口：static struct proc * allocproc(void)、void userinit(void)、int growproc(int n)、int fork(void)、void exit(void)、int wait(void)、void scheduler(void)、void yield(void)；</li><li>syscall.c 内部定义了各种类型的系统调用函数，sysproc.c内部是与进程创建、退出等相关的系统调用函数的实现。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// syscall.h  System call numbers</span><br><span class="line">……</span><br><span class="line"><span class="comment">#define SYS_fork    1</span></span><br><span class="line"><span class="comment">#define SYS_exit    2</span></span><br><span class="line"><span class="comment">#define SYS_wait    3</span></span><br><span class="line"><span class="comment">#define SYS_pipe    4</span></span><br><span class="line"><span class="comment">#define SYS_read    5</span></span><br><span class="line"><span class="comment">#define SYS_kill    6</span></span><br><span class="line"><span class="comment">#define SYS_exec    7</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// syscall.c 声明系统调用</span><br><span class="line">……</span><br><span class="line">extern int sys_chdir(void);</span><br><span class="line">extern int sys_close(void);</span><br><span class="line">extern int sys_dup(void);</span><br><span class="line">extern int sys_exec(void);</span><br><span class="line">extern int sys_exit(void);</span><br><span class="line">extern int sys_fork(void);</span><br><span class="line">extern int sys_fstat(void);</span><br><span class="line">extern int sys_getpid(void);</span><br><span class="line">extern int sys_kill(void);</span><br><span class="line">extern int sys_link(void);</span><br><span class="line">extern int sys_mkdir(void);</span><br><span class="line">extern int sys_mknod(void);</span><br><span class="line">extern int sys_open(void);</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">// sysproc.c 定义前面声明的系统调用接口</span><br><span class="line">int sys_fork(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> fork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">  <span class="built_in">return</span> 0;  // not reached</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_wait(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_kill(void)</span><br><span class="line">&#123;</span><br><span class="line">  int pid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(0, &amp;pid) &lt; 0)</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">kill</span>(pid);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="Exercise2-带着问题阅读"><a href="#Exercise2-带着问题阅读" class="headerlink" title="Exercise2 带着问题阅读"></a>Exercise2 带着问题阅读</h2><ol><li>什么是用户态和内核态，两者有何区别? 什么是中断和系统调用，两者有何区别? 计算机在运行时，是如何确定当前处于用户态还是内核态的?</li></ol><ul><li>当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，从而进入内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据；</li><li>系统调用需要借助于中断机制来实现。两者都是从同一个异常处理入口开始，但是系统调用会一开始让CPU进入内核模式且使能中断，然后从系统调用表中取得相应的注册函数调用之；而中断处理则让CPU进入内核模式且disable中断。所以系统调用的真实处理（系统调用表中的注册函数执行）中可以阻塞，而中断处理的上半部不可以。所以在写驱动代码如字符设备驱动，实现读操作时是可以让其sleep的（比如没有数据时候，用户设置读模式是阻塞型的）。另一方面，如果该驱动读操作过于耗时也是不可取的，它在内核态中执行，这个时候只有中断的优先级比它高，其它的高优先级线程将不能得到及时调度执行；</li><li>用户态和内核态的特权级不同，因此可以通过特全级判断当前处于用户态还是内核态。</li></ul><ol start="2"><li>计算机开始运行阶段就有中断吗? XV6 的中断管理是如何初始化的? XV6 是如何实现内核态到用户态的转变的? XV6 中的硬件中断是如何开关的? 实际的计算机里，中断有哪几种?</li></ol><ul><li>计算机开始运行阶段就有BIOS支持的中断；</li><li>由于xv6在开始运行阶段没有初始化中断处理程序，于是xv6在bootasm.S中用cli命令禁止中断发生。xv6的终端管理初始化各部分通过main.c中的main()函数调用。picinit()和oapicinit()初始化可编程中断控制器，consoleinit()和uartinit()设置了I/O、设备端口的中断。接着，tvinit()调用trap.c中的代码初始化中断描述符表，关联vectors.S中的中断IDT表项，在调度开始前调用idtinit()设置32号时钟中断，最后在scheduler()中调用sti()开中断，完成中断管理初始化；</li><li>xv6在proc.c中的userinit()函数中，通过设置第一个进程的tf(trap frame)中cs ds es ss处于DPL_USER(用户模式) 完成第一个用户态进程的设置，然后在scheduler中进行初始化该进程页表、切换上下文等操作，最终第一个进程调用trapret，而此时第一个进程构造的tf中保存的寄存器转移到CPU中，设置了 %cs 的低位，使得进程的用户代码运行在 CPL = 3 的情况下，完成内核态到用户态的转变；</li><li>xv6的硬件中断由picirq.c ioapic.c timer.c中的代码对可编程中断控制器进行设置和管理，比如通过调用ioapicenable控制IOAPIC中断。处理器可以通过设置 eflags 寄存器中的 IF 位来控制自己是否想要收到中断，xv6中通过命令cli关中断，sti开中断；</li><li>中断的种类有：程序性中断：程序性质的错误等，如用户态下直接使用特权指令；外中断: 中央处理的外部装置引发，如时钟中断；I/O中断: 输入输出设备正常结束或发生错误时引发，如读取磁盘完成；硬件故障中断: 机器发生故障时引发，如电源故障；访管中断: 对操作系统提出请求时引发，如读写文件。</li></ul><ol start="3"><li>什么是中断描述符，中断描述符表（IDT）? 在XV6里是用什么数据结构表示的?</li></ol><ul><li>中断描述符表的每一项是一个中断描述符，在x86系统中，中断处理程序定义存储在IDT中。XV6的IDT有256个入口点，每个入口点中对应的处理程序不同，在出发trap时，只要找到对应编号的入口，就能得到对应的处理程序；</li><li>XV6中的数据结构中中断描述符用struct gatedesc表示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// trap.c</span><br><span class="line"><span class="comment"># generated by vectors.pl - do not edit</span></span><br><span class="line"><span class="comment"># handlers</span></span><br><span class="line">.globl alltraps</span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">  pushl <span class="variable">$0</span></span><br><span class="line">  pushl <span class="variable">$0</span></span><br><span class="line">  jmp alltraps</span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">  pushl <span class="variable">$0</span></span><br><span class="line">  pushl <span class="variable">$1</span></span><br><span class="line">  jmp alltraps</span><br><span class="line">.globl vector2</span><br><span class="line">……</span><br></pre></td></tr></table></figure><ul><li>alltraps继续保存处理器的寄存器，设置数据和CPU段，然后压入 %esp，调用trap，到此时已完成用户态到内核态的转变；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// trapasm.S</span><br><span class="line">  <span class="comment"># vectors.S sends all traps here.</span></span><br><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">  <span class="comment"># Build trap frame.</span></span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Set up data and per-cpu segments. 设置数据和CPU段</span></span><br><span class="line">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es</span><br><span class="line">  movw $(SEG_KCPU&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %fs</span><br><span class="line">  movw %ax, %gs</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Call trap(tf), where tf=%esp 压入 %esp</span></span><br><span class="line">  pushl %esp  <span class="comment"># 调用trap</span></span><br><span class="line">  call <span class="built_in">trap</span></span><br><span class="line">  addl <span class="variable">$4</span>, %esp</span><br></pre></td></tr></table></figure><ul><li>trap会根据%esp指向对应的tf，首先根据trapno判断该中断是否是系统调用，之后判断硬件中断，由于除零不是以上两种，于是判断为代码错误中断，并且是发生在用户空间的。接着处理程序将该进程标记为killed，并退出，继续下一个进程的调度；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// trap.c</span><br><span class="line">//PAGEBREAK: 41</span><br><span class="line">void <span class="built_in">trap</span>(struct trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(tf-&gt;trapno == T_SYSCALL)&#123; // 判断该中断是否为系统调用</span><br><span class="line">    <span class="keyword">if</span>(proc-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    proc-&gt;tf = tf;</span><br><span class="line">    syscall();</span><br><span class="line">    <span class="keyword">if</span>(proc-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch(tf-&gt;trapno)&#123;</span><br><span class="line">  </span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">  // PAGEBREAK: 13  </span><br><span class="line">  // tf-&gt;trapno与其他<span class="keyword">case</span>语句对不上,除零被视为代码错误中断,进入这里杀掉进程</span><br><span class="line">  default: </span><br><span class="line">    <span class="keyword">if</span>(proc == 0 || (tf-&gt;cs&amp;3) == 0)&#123;</span><br><span class="line">      // In kernel, it must be our mistake.</span><br><span class="line">      cprintf(<span class="string">"unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n"</span>,</span><br><span class="line">              tf-&gt;trapno, cpu-&gt;id, tf-&gt;eip, rcr2());</span><br><span class="line">      panic(<span class="string">"trap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    // In user space, assume process misbehaved.  </span><br><span class="line">    cprintf(<span class="string">"pid %d %s: trap %d err %d on cpu %d "</span></span><br><span class="line">            <span class="string">"eip 0x%x addr 0x%x--kill proc\n"</span>,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, tf-&gt;trapno, tf-&gt;err, cpu-&gt;id, tf-&gt;eip, </span><br><span class="line">            rcr2());</span><br><span class="line">    proc-&gt;killed = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>涉及到的主要数据结构：中断描述符表IDT(trap.c +12)、（vi x86.h +150）、（vi vector.S）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// trap.c</span><br><span class="line">// Interrupt descriptor table (shared by all CPUs).</span><br><span class="line">struct gatedesc idt[256];</span><br><span class="line">extern uint vectors[];  // <span class="keyword">in</span> vectors.S: array of 256 entry pointers</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">// x86.h</span><br><span class="line">//PAGEBREAK: 36</span><br><span class="line">// Layout of the <span class="built_in">trap</span> frame built on the stack by the</span><br><span class="line">// hardware and by trapasm.S, and passed to <span class="built_in">trap</span>().</span><br><span class="line">struct trapframe &#123;</span><br><span class="line">  // registers as pushed by pusha</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      // useless &amp; ignored</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line">  ……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// vector.S  0～255共256个</span><br><span class="line">vectors:</span><br><span class="line">  .long vector0</span><br><span class="line">  .long vector1</span><br><span class="line">  .long vector2</span><br><span class="line">  .long vector3</span><br><span class="line">  .long vector4</span><br><span class="line">  .long vector5</span><br><span class="line">  .long vector6</span><br><span class="line">  .long vector7</span><br><span class="line">  .long vector8</span><br><span class="line">  .long vector9</span><br><span class="line">  ……</span><br></pre></td></tr></table></figure><ol start="4"><li>请以系统调用setrlimit(该系统调用的作用是设置资源使用限制)为例，叙述如何在XV6中实现一个系统调用。(提示:需要添加系统调用号，系统调用函数，用户接口等等)。</li></ol><ul><li>在syscall.h中添加系统调用号 #define SYS_setrlimit 22；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// syscall.h</span><br><span class="line">……</span><br><span class="line"><span class="comment">#define SYS_mkdir  20</span></span><br><span class="line"><span class="comment">#define SYS_close  21</span></span><br><span class="line"><span class="comment">#define  SYS_setrlimit  22 // add by yangyu</span></span><br></pre></td></tr></table></figure><ul><li>在syscall.c中添加对应的处理程序的调用接口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// syscall.c</span><br><span class="line">……</span><br><span class="line">static int (*syscalls[])(void) = &#123;</span><br><span class="line">……</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_setrlimit]   SYS_setrlimit, // add by yangyu</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在sysproc.c中添加系统调用函数int sys_setrlimit(void)，具体实现对于进程资源使用限制的设置；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// syspro.c</span><br><span class="line">……</span><br><span class="line">int sys_uptime(void)</span><br><span class="line">&#123;</span><br><span class="line">  uint xticks;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  xticks = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="built_in">return</span> xticks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在这里面写逻辑,限制进程资源的使用</span><br><span class="line">int sys_setrlimit(void)</span><br><span class="line">&#123;</span><br><span class="line">    // to <span class="keyword">do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在user.h中声明系统调用接口int setrlimit(int resource, const struct rlimit * rlim)；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// syspro.c</span><br><span class="line">……</span><br><span class="line">// system calls</span><br><span class="line">int fork(void);</span><br><span class="line">int <span class="built_in">exit</span>(void) __attribute__((noreturn));</span><br><span class="line">…… // 调用该接口陷入内核执行系统调用</span><br><span class="line">int setrlimit(int resource, const struct rlimit *rlim);</span><br></pre></td></tr></table></figure><ul><li>在usys.S添加SYSCALL(setrlimit)。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// usys.S</span><br><span class="line">……</span><br><span class="line">SYSCALL(sleep)</span><br><span class="line">SYSCALL(uptime)</span><br><span class="line">SYSCALL(setrlimit)  // add by yangyu</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/qiangua/articles/3794696.html" rel="external nofollow noopener noreferrer" target="_blank">xv6 idt初始化</a><br>[2] <a href="https://th0ar.gitbooks.io/xv6- chinese/content/content/chapter3.html" rel="external nofollow noopener noreferrer" target="_blank">xv6中文文档</a><br>[3] <a href="https://www.cnblogs.com/qiangua/articles/3794696.html" rel="external nofollow noopener noreferrer" target="_blank">xv6 alltraps</a><br>[4] <a href="http://ybin.cc/os/xv6-trap-and-interrupt/" rel="external nofollow noopener noreferrer" target="_blank">xv6 trap/interrupt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Exercise1-源代码阅读&quot;&gt;&lt;a href=&quot;#Exercise1-源代码阅读&quot; class=&quot;headerlink&quot; title=&quot;Exercise1 源代码阅读&quot;&gt;&lt;/a&gt;Exercise1 源代码阅读&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;启动部分: bootas
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="XV6" scheme="https://icoty.github.io/tags/XV6/"/>
    
      <category term="中断" scheme="https://icoty.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="系统调用" scheme="https://icoty.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="中断描述符表IDT" scheme="https://icoty.github.io/tags/%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8IDT/"/>
    
  </entry>
  
  <entry>
    <title>XV6源代码阅读-进程线程</title>
    <link href="https://icoty.github.io/2019/06/09/xv6-process-thread/"/>
    <id>https://icoty.github.io/2019/06/09/xv6-process-thread/</id>
    <published>2019-06-09T01:29:07.000Z</published>
    <updated>2019-06-09T05:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h2><ol><li>基本头文件：types.h param.h memlayout.h defs.h x86.h asm.h mmu.h elf.h</li></ol><ul><li>types.h：仅仅是定义uint, ushort, uchar pde_t别名；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int   uint;</span><br><span class="line">typedef unsigned short ushort;</span><br><span class="line">typedef unsigned char  uchar;</span><br><span class="line">typedef uint pde_t;</span><br></pre></td></tr></table></figure><ul><li>parame.h 利用宏定义了进程最大数量，进程的内核栈大小，CPU的最大数量，进程能打开的文件描述符数等；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define NPROC        64  // maximum number of processes</span></span><br><span class="line"><span class="comment">#define KSTACKSIZE 4096  // size of per-process kernel stack</span></span><br><span class="line"><span class="comment">#define NCPU          8  // maximum number of CPUs</span></span><br><span class="line"><span class="comment">#define NOFILE       16  // open files per process</span></span><br><span class="line"><span class="comment">#define NFILE       100  // open files per system</span></span><br><span class="line"><span class="comment">#define NBUF         10  // size of disk block cache</span></span><br><span class="line"><span class="comment">#define NINODE       50  // maximum number of active i-nodes</span></span><br><span class="line"><span class="comment">#define NDEV         10  // maximum major device number</span></span><br><span class="line"><span class="comment">#define ROOTDEV       1  // device number of file system root disk</span></span><br><span class="line"><span class="comment">#define MAXARG       32  // max exec arguments</span></span><br><span class="line"><span class="comment">#define LOGSIZE      10  // max data sectors in on-disk log</span></span><br></pre></td></tr></table></figure><ul><li>memlayout.h：利用宏定义内存空间范围，地址和偏移的转换等；</li><li>defs.h：内部包含了许多前向声明，同时声明了许多全局函数，这些全局函数的实现在具体使用的模块定义；</li><li>x86.h：定义了许多C代码与汇编指令交互的内敛函数，同时定义了从用户态陷入内核态的数据结构struct trapframe; </li><li>asm.h：汇编宏定义；</li><li>mmu.h：内存管理单元，进程地址空间详细数据结构；</li><li>elf.h：声明了elf格式的目标文件有关的数据结构。</li></ul><ol start="2"><li>进程线程部分：vm.c proc.h proc.c swtch.S kalloc.c以及相关其他文件代码</li></ol><ul><li>vm.c：内存管理接口，比如页表申请，页表释放，页目录的转换，cpu与进程的绑定等；</li><li>proc.h：声明了cpu、进程、进程上下文等数据结构；<br>swtch.S：内部是上下文切换的汇编指令，保存换出进程的现场，加载换入进程的现场；</li><li>kalloc.c：物理内存的申请和释放。主要接口：void kinit1(void <em> vstart, void </em> vend), kinit2(void <em> vstart, void </em> vend), char <em> kalloc(void), void kfree(char </em> v)。</li></ul><h2 id="Exercise2-带着问题阅读"><a href="#Exercise2-带着问题阅读" class="headerlink" title="Exercise2 带着问题阅读"></a>Exercise2 带着问题阅读</h2><ol><li>什么是进程？什么是线程？操作系统的资源分配单位和调度单位分别是什么？XV6 中的进程和线程分别是什么，都实现了吗?    </li></ol><ul><li>进程是在多道程序系统出现以后，为了描述系统内部各作业的活动规律而引进的概念。进程有3个基本状态：运行状态、就绪状态和等待状态；进程是具有独立功能的程序关于某个数据集合上的一次运行活动；</li><li>线程是轻量级的进程，线程是进程内的一个相对独立的可执行的单元，若把进程称为任务的话，那么线程则是应用中的一个子任务的执行；</li><li>操作系统的资源分配的单位是进程，处理机调度的单位是线程；</li><li>xv6操作系统实现了一个基于进程 (没有实现线程) 的简单进程管理机制。XV6中进程和CPU的数据结构见proc.h。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// proc.h </span><br><span class="line">// 上下文切换现场</span><br><span class="line">struct context &#123;</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br><span class="line">// 枚举进程状态</span><br><span class="line">enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line">// Per-process state</span><br><span class="line">struct proc &#123;</span><br><span class="line">  uint sz;                     // Size of process memory (bytes)</span><br><span class="line">  pde_t* pgdir;                // Page table</span><br><span class="line">  char *kstack;                // Bottom of kernel stack <span class="keyword">for</span> this process</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  volatile int pid;            // Process ID</span><br><span class="line">  struct proc *parent;         // Parent process</span><br><span class="line">  struct trapframe *tf;        // Trap frame <span class="keyword">for</span> current syscall</span><br><span class="line">  struct context *context;     // swtch() here to run process</span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>进程管理的数据结构是什么？在 Windows，Linux，XV6 中分别叫什么名字？其中包含哪些内容？操作系统是如何进行管理进程管理数据结构的？它们是如何初始化的？</li></ol><ul><li>进程管理的数据结构是进程控制块 (PCB );</li><li>Linux下为/include/linux/sched.h内部的struct task_struct，其中包括管理进程所需的各种信息。创建一个新进程时，系统在内存中申请一个空的task_struct ，并填入所需信息。同时将指向该结构的指针填入到task[]数组中。当前处于运行状态进程的PCB用指针数组current_set[]来指出。这是因为 Linux 支持多处理机系统，系统内可能存在多个同时运行的进程，故 current_set定义成指针数组；</li><li>Windows下用EPROCESS(执行体进程对象)表示 ， PCB 也称为内核进程块KPROCESS(KPROCESS即内核进程对象 )，EPOCESS和KPROCESS位于内核空间 ；</li><li>XV6下在proc .h内声明，包括进程 ID ，进程状态 ，父进程，context，cpu记录了内存地址和栈指针等。XV6中通过get_raw_proc()对进程进行控制管理，get_raw_proc()方法可以创建一个新的进程并对进程进行初始化分配进程页表和内核堆栈。</li></ul><ol start="3"><li>XV6中进程有哪些状态? 请画出XV6 的进程状态转化图。在Linux中，进程的状态分别包括哪些? 你认为操作系统的设计者为什么会有这样的设计思路?</li></ol><ul><li>XV6中进程各状态及转换图如下：</li></ul><p><img src="/2019/06/09/xv6-process-thread/process-status.png" alt="cmd"></p><ul><li>Linux 的进程状态可分为R (TASK_RUNNING)，可执行状态，S (TASK_INTERRUPTIBLE)，可中断的睡眠状态，D(TASK_UNINTERRUPTIBLE)不可中断的睡眠状态，T(TASK_STOPPED or TASK_TRACED)暂停状态或跟踪状态，Z(TASK_DEAD - EXIT_ZOMBIE)退出状态但资源未回收，称为僵尸进程，X (TASK_DEAD - EXIT_DEAD)退出状态，进程即将被销毁。</li><li>设计这这样设计的目的，是为了cpu能够根据进程的状态进行更好的调度，提高cpu的利用率，适应io密集型和cpu密集型的进程，避免cpu的浪费。</li></ul><ol start="4"><li>如何启动多进程(创建子进程)? 如何调度多进程，调度算法有哪些? 操作系统为何要限制一个CPU最大支持的进程数?  XV6中的最大进程数是多少？如何执行进程的切换? 什么是进程上下文? 多进程和多CPU有什么关系? </li></ol><ul><li>父进程可以利用fork()函数创建多个子进程。首先，为每个新建的子进程分配一个空闲的proc结构并赋予子进程唯一标识pid；其次，以一次一页的方式复制父进程地址空间（采用cow写时复制），获得子进程继承的共享资源的指针；最后将子进程加入就绪队列，对子进程返回标识符0，向父进程返回子进程pid；</li><li>cpu使用规定的调度算法从就绪队列选择一个进程执行，常用调度算法：时间片轮转调度、先来先服务、短作业优先调度策略、基于优先级的可抢占调度策略、基于优先级的不可抢占式调度策略、最短剩余时间优先算法、高响应比优先算法、多级反馈队列算法等；</li><li>一是内存空间有限，如果读入的进程数量过多，势必会吃掉大量的内存空间，而cpu在调度过程中也会从栈或堆上申请空间，如果申请失败则无法继续运行。二是增加了缺页中断的可能性，会导致cpu不断的执行页面换入换出，使得大部分时间浪费在无意义的事情上；</li><li>XV6的最大进程数见param.h文件中的#define NPROC 64，最大64；</li><li>进程切换是一个进程让出处理器，由另一个进程占用处理器的过程。进程的切换是由进程状态的变化引起的，而进程状态的变化又与出现的事件有关。当有事件(中断或异常)发生时，当前运行进程暂停，保存当前进程的现场，然后根据调度算法从就绪队列选一个进程换入CPU，同时加载换入进程的现场进行执行；</li><li>进程的上下文包括当前进程的程序计数 器PC和当前运行的CPU中各个寄存器的内容。当进程切换和发生中断的时候这些信息要保存下来以便于下次运行时使用；</li><li>同一时刻每个cpu上只能有一个进程被执行，且同一时刻一个进程只能被一个cpu调度，同一时刻多个cpu可以同时调度不同的进程，同一时间段内每个cpu可以调度多个进程。</li></ul><ol start="5"><li>内核态进程是什么? 用户态进程是什么? 它们有什么区别?  </li></ol><ul><li>多数系统将处理器工作状态划分为内核态和用户态。前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为特权态、系统态或管态；后者一般指用户程序运行时的状态；具有较低的特权级别，又称为普通态、目态。区分了用户态和内核态就是限定用户什么操作可以做，什么操作不能让用户直接做。如果遇到不能让用户直接做的操作，用户就必须请求操作系统做系统调用，这样操作系统就会进入内核态进行系统操作。内核态的进程就是系统进入内核态之后进行系统操作所产生的进程；</li><li>用户态进程是用户通过请求操作而产生的进程；</li><li>区别: 运行在不同的系统状态，用户态进程执行在用户态，内核态进程执行在内核态；进入方式不同，用户态进程可直接进入，内核态必须通过运行系统调用命令；返回方式不同，用户态进程直接返回，内核态进程有重新调度过程；内核态进程优先级要高于用户态进程，并且内核态进程特权级别最高，它可以执行系统级别的代码。</li></ul><ol start="6"><li>进程在内存中是如何布局的？ 进程的堆和栈有什么区别? </li></ol><ul><li>内存分为内核空间和用户空间，内核空间一般运行操作系统程序，而用户空间一般运行用户程序。主要目的是对系统程序进行包含。进程在内存中包含堆、栈、数据段、代码段。代码段 : 保存程序的执行码，在进程并发时，代码段是共享的且只读的，在存储器中只需有一个副本。数据段 : 此段又称为初始化数据段，它包含了程序中已初始化的全局变量、全局静态变量、局部静态变量。</li><li>栈 : 程序执行前静态分配的内存空间，栈的大小可在编译时指定，Linux环境下默认为 8M。栈段是存放程序执行时局部变量、函数调用信息、中断现场保留信息的空间。程序执行时，CPU堆栈段指针会在栈顶根据执行情况进行上下移动。</li><li>堆 : 程序执行时, 按照程序需要动态分配的内存空间，使用malloc、 calloc、realloc函数分配的空间都在堆上分配。</li></ul><p><img src="/2019/06/09/xv6-process-thread/addr-space" alt="来源于网络"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/thecrazyboy/article/details/12121297" rel="external nofollow noopener noreferrer" target="_blank">xv6进程与内存管理-CSDN</a><br>[2] <a href="https://www.cnblogs.com/wuchanming/p/4339770.html" rel="external nofollow noopener noreferrer" target="_blank">linux进程地址空间-博客园</a><br>[3] <a href="https://wenku.baidu.com/view/07c61910ec3a87c24128c464.html" rel="external nofollow noopener noreferrer" target="_blank">xv6进程线程-百度文库</a><br>[4] 操作系统-进程线程模型课件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Exercise1-源代码阅读&quot;&gt;&lt;a href=&quot;#Exercise1-源代码阅读&quot; class=&quot;headerlink&quot; title=&quot;Exercise1 源代码阅读&quot;&gt;&lt;/a&gt;Exercise1 源代码阅读&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本头文件：types.
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="XV6" scheme="https://icoty.github.io/tags/XV6/"/>
    
      <category term="进程" scheme="https://icoty.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="https://icoty.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>XV6源代码阅读-同步机制</title>
    <link href="https://icoty.github.io/2019/06/08/xv6-synch/"/>
    <id>https://icoty.github.io/2019/06/08/xv6-synch/</id>
    <published>2019-06-08T15:28:40.000Z</published>
    <updated>2019-06-09T06:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h2><p>锁部分：spinlock.h/spinlock.c以及相关其他文件代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// Mutual exclusion lock.</span><br><span class="line">struct spinlock &#123;</span><br><span class="line">  uint locked; // 0未被占用, 1已被占用</span><br><span class="line">  </span><br><span class="line">  // For debugging:</span><br><span class="line">  char *name;        // Name of lock.</span><br><span class="line">  struct cpu *cpu;   // The cpu holding the lock.</span><br><span class="line">  uint pcs[10];      // The call stack (an array of program counters)</span><br><span class="line">                     // that locked the lock.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化自旋锁</span><br><span class="line">void initlock(struct spinlock *lk, char *name)</span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = 0;</span><br><span class="line">  lk-&gt;cpu = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Acquire the lock.</span><br><span class="line">// Loops (spins) until the lock is acquired.</span><br><span class="line">// Holding a lock <span class="keyword">for</span> a long time may cause</span><br><span class="line">// other CPUs to waste time spinning to acquire it.</span><br><span class="line">void acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  // 关中断</span><br><span class="line">  pushcli(); // <span class="built_in">disable</span> interrupts to avoid deadlock.</span><br><span class="line">  <span class="keyword">if</span>(holding(lk)) // 判断锁的持有是否为当前cpu</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  // The xchg is atomic.</span><br><span class="line">  // It also serializes, so that reads after acquire are not</span><br><span class="line">  // reordered before it. </span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, 1) != 0); // 拿不到锁开始自旋</span><br><span class="line"></span><br><span class="line">  // Record info about lock acquisition <span class="keyword">for</span> debugging.</span><br><span class="line">  lk-&gt;cpu = cpu;</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Release the lock.</span><br><span class="line">void release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[0] = 0;</span><br><span class="line">  lk-&gt;cpu = 0;</span><br><span class="line"></span><br><span class="line">  // The xchg serializes, so that reads before release are </span><br><span class="line">  // not reordered after it.  The 1996 PentiumPro manual (Volume 3,</span><br><span class="line">  // 7.2) says reads can be carried out speculatively and <span class="keyword">in</span></span><br><span class="line">  // any order, <span class="built_in">which</span> implies we need to serialize here.</span><br><span class="line">  // But the 2007 Intel 64 Architecture Memory Ordering White</span><br><span class="line">  // Paper says that Intel 64 and IA-32 will not move a load</span><br><span class="line">  // after a store. So lock-&gt;locked = 0 would work here.</span><br><span class="line">  // The xchg being asm volatile ensures gcc emits it after</span><br><span class="line">  // the above assignments (and after the critical section).</span><br><span class="line">  xchg(&amp;lk-&gt;locked, 0);</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise2-带着问题阅读"><a href="#Exercise2-带着问题阅读" class="headerlink" title="Exercise2 带着问题阅读"></a>Exercise2 带着问题阅读</h2><ol><li>什么是临界区? 什么是同步和互斥? 什么是竞争状态? 临界区操作时中断是否应该开启? 中断会有什么影响? XV6的锁是如何实现的，有什么操作? xchg 是什么指令，该指令有何特性?</li></ol><ul><li>临界区(Critical Section)：访问临界区的那段代码，多个进程/线程必须互斥进入临界区；</li><li>同步(Synchronization)：指多个进程/线程能够按照程序员期望的方式来协调执行顺序，为了实现这个目的，必须要借助于同步机制(如信号量，条件变量，管程等)；</li><li>互斥(Mutual Exclusion)：互斥的目的是保护临界区；</li><li>竞争状态：竞争是基于并发环境下的，单个进程/线程不存在竞争，在并发环境下，多个进程/线程都需要请求某资源的时候，只有竞争到该资源的进程/线程才能够执行，释放资源后，剩余进程/线程按照预定的算法策略重新竞争；</li><li>操作临界区必须关中断，对临界区的操作是原子性的；</li><li>中断影响：中断降低了并发性能，同时中断也会导致频繁的上下文切换，上下文切换会导致tlb快表失效，因此要尽可能的缩减中断处理的时间；</li><li>自旋锁(Spinlock)：xv6中利用该数据结构实现多个进程/线程同步和互斥访问临界区。当进程/线程请求锁失败时进入循环，直至锁可用并成功拿到后返回，对于单cpu系统自旋锁浪费CPU资源，不利于并发，自旋锁的优势体现在多CPU系统下，XV6支持多CPU。主要接口有void initlock(struct spinlock <em> lk, char </em> name)、void initlock(struct spinlock <em> lk, char </em> name)、void release(struct spinlock * lk)；</li><li>xchg：xchg()函数使用GCC的内联汇编语句，该函数中通过xchg原子性交换spinlock.locked和newval，并返回spinlock.locked原来的值。当返回值为1时，说明其他线程占用了该锁，继续循环等待；当返回值为0时，说明其他地方没有占用该锁，同时locked本设置成1了，所以该锁被此处占用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// x86.h 调用方式如xchg(&amp;lk-&gt;locked, 1)</span><br><span class="line">static inline uint xchg(volatile uint *addr, uint newval)</span><br><span class="line">&#123;</span><br><span class="line">  uint result;</span><br><span class="line">  </span><br><span class="line">  // The + <span class="keyword">in</span> <span class="string">"+m"</span> denotes a <span class="built_in">read</span>-modify-write operand.</span><br><span class="line">  asm volatile(<span class="string">"lock; xchgl %0, %1"</span> :</span><br><span class="line">               <span class="string">"+m"</span> (*addr), <span class="string">"=a"</span> (result) :</span><br><span class="line">               <span class="string">"1"</span> (newval) :</span><br><span class="line">               <span class="string">"cc"</span>);</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>基于XV6的spinlock, 请给出实现信号量、读写锁、信号机制的设计方案(三选二，请写出相应的伪代码)?</li></ol><ul><li>信号量实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore &#123;</span><br><span class="line">  int value;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct proc *queue[NPROC]; // 进程等待队列,这是一个循环队列</span><br><span class="line">  int end;   // 队尾</span><br><span class="line">  int start; // 队头</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化信号量</span><br><span class="line">void sem_init(struct semaphore *s, int value) &#123;</span><br><span class="line">  s-&gt;value = value;</span><br><span class="line">  initlock(&amp;s-&gt;lock, <span class="string">"semaphore_lock"</span>);</span><br><span class="line">  end = start = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sem_wait(struct semaphore *s) &#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock); // 竞争锁,如果竞争不到进入自旋</span><br><span class="line">  s-&gt;value--; </span><br><span class="line">  <span class="keyword">if</span> (s-&gt;value &lt; 0) &#123;</span><br><span class="line">    s-&gt;queue[s-&gt;end] = myproc(); // myproc()获取当前进程, 放入队尾</span><br><span class="line">    s-&gt;end = (s-&gt;end + 1) % NPROC; // 循环队列计算新的队尾</span><br><span class="line">    // 1. 释放锁(下一个sem_wait的进程才能进入acquire),</span><br><span class="line">    // 2. 然后进入睡眠等待, 被唤醒时重新竞争锁</span><br><span class="line">    sleep(myproc(), &amp;s-&gt;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sem_signal(struct semaphore *s) &#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock); // 竞争锁</span><br><span class="line">  s-&gt;value++;</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;value &lt;= 0) &#123;</span><br><span class="line">    wakeup(s-&gt;queue[s-&gt;start]); // 唤醒循环队列头的进程</span><br><span class="line">    s-&gt;queue[s-&gt;start] = 0; </span><br><span class="line">    s-&gt;start = (s-&gt;start + 1) % NPROC; // 重新计算队头</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// proc.h</span><br><span class="line">// Per-process state</span><br><span class="line">struct proc &#123;</span><br><span class="line">  uint sz;                     // Size of process memory (bytes)</span><br><span class="line">  pde_t* pgdir;                // Page table</span><br><span class="line">  char *kstack;                // Bottom of kernel stack <span class="keyword">for</span> this process</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  volatile int pid;            // Process ID</span><br><span class="line">  struct proc *parent;         // Parent process</span><br><span class="line">  struct trapframe *tf;        // Trap frame <span class="keyword">for</span> current syscall</span><br><span class="line">  struct context *context;     // swtch() here to run process</span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.cnblogs.com/hehao98/p/10678493.html" rel="external nofollow noopener noreferrer" target="_blank">xv6锁-博客园</a><br>[2] <a href="https://www.cnblogs.com/hygblog/p/9361888.html" rel="external nofollow noopener noreferrer" target="_blank">xv6锁-xchg</a><br>[3] <a href="https://blog.csdn.net/qq_25426415/article/details/54631192" rel="external nofollow noopener noreferrer" target="_blank">xv6锁-CSDN</a><br>[4] <a href="https://wenku.baidu.com/view/339ba16e7e21af45b307a8e6.html" rel="external nofollow noopener noreferrer" target="_blank">xv6整体报告-百度文库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Exercise1-源代码阅读&quot;&gt;&lt;a href=&quot;#Exercise1-源代码阅读&quot; class=&quot;headerlink&quot; title=&quot;Exercise1 源代码阅读&quot;&gt;&lt;/a&gt;Exercise1 源代码阅读&lt;/h2&gt;&lt;p&gt;锁部分：spinlock.h/spi
      
    
    </summary>
    
      <category term="同步机制" scheme="https://icoty.github.io/categories/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="XV6" scheme="https://icoty.github.io/tags/XV6/"/>
    
      <category term="自旋锁" scheme="https://icoty.github.io/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
      <category term="中断" scheme="https://icoty.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>XV6源代码阅读-文件系统</title>
    <link href="https://icoty.github.io/2019/06/08/xv6-filesystem/"/>
    <id>https://icoty.github.io/2019/06/08/xv6-filesystem/</id>
    <published>2019-06-08T07:33:09.000Z</published>
    <updated>2019-06-09T05:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exercise1-源代码阅读"><a href="#Exercise1-源代码阅读" class="headerlink" title="Exercise1 源代码阅读"></a>Exercise1 源代码阅读</h2><p>文件系统部分 buf.h fcntl.h stat.h fs.h file.h ide.c bio.c log.c fs.c file.c sysfile.c exec.c</p><ol><li>buf.h：对xv6中磁盘块数据结构进行定义，块大小为512字节。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// xv6中磁盘块数据结构,块大小512字节</span><br><span class="line">struct buf &#123;</span><br><span class="line">  int flags; // DIRTY, VALID</span><br><span class="line">  uint dev;</span><br><span class="line">  uint sector; // 对应扇区</span><br><span class="line">  struct buf *prev; // LRU cache list</span><br><span class="line">  struct buf *next; // 链式结构用于连接</span><br><span class="line">  struct buf *qnext; // disk queue</span><br><span class="line">  uchar data[512];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#define B_BUSY  0x1  // buffer is locked by some process</span></span><br><span class="line"><span class="comment">#define B_VALID 0x2  // buffer has been read from disk</span></span><br><span class="line"><span class="comment">#define B_DIRTY 0x4  // buffer needs to be written to disk</span></span><br></pre></td></tr></table></figure><ol start="2"><li>fcntl.h：宏定义操作权限。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define O_RDONLY  0x000 // 只读</span></span><br><span class="line"><span class="comment">#define O_WRONLY  0x001 // 只写</span></span><br><span class="line"><span class="comment">#define O_RDWR    0x002 // 读写</span></span><br><span class="line"><span class="comment">#define O_CREATE  0x200 // 创建</span></span><br></pre></td></tr></table></figure><ol start="3"><li>stat.h：声明文件或目录属性数据结构。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define T_DIR  1   // Directory</span></span><br><span class="line"><span class="comment">#define T_FILE 2   // File</span></span><br><span class="line"><span class="comment">#define T_DEV  3   // Device</span></span><br><span class="line"></span><br><span class="line">struct <span class="built_in">stat</span> &#123;</span><br><span class="line">  short <span class="built_in">type</span>;  // Type of file</span><br><span class="line">  int dev;     // File system<span class="string">'s disk device</span></span><br><span class="line"><span class="string">  uint ino;    // Inode number</span></span><br><span class="line"><span class="string">  short nlink; // Number of links to file</span></span><br><span class="line"><span class="string">  uint size;   // Size of file in bytes</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>fs.h / fs.c：声明超级块、dinode、文件和目录数据结构，以及相关的宏定义。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ROOTINO 1  // root i-number</span></span><br><span class="line"><span class="comment">#define BSIZE 512  // block size</span></span><br><span class="line"></span><br><span class="line">// File system super block</span><br><span class="line">struct superblock &#123;</span><br><span class="line">  uint size;         // Size of file system image (blocks)</span><br><span class="line">  uint nblocks;      // Number of data blocks</span><br><span class="line">  uint ninodes;      // Number of inodes.</span><br><span class="line">  uint nlog;         // Number of <span class="built_in">log</span> blocks</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define NDIRECT 12</span></span><br><span class="line"><span class="comment">#define NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="comment">#define MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"></span><br><span class="line">// 磁盘上inode节点体现形式</span><br><span class="line">// On-disk inode structure</span><br><span class="line">struct dinode &#123;</span><br><span class="line">  short <span class="built_in">type</span>;           // File <span class="built_in">type</span></span><br><span class="line">  short major;          // Major device number (T_DEV only)</span><br><span class="line">  short minor;          // Minor device number (T_DEV only)</span><br><span class="line">  short nlink;          // Number of links to inode <span class="keyword">in</span> file system</span><br><span class="line">  uint size;            // Size of file (bytes)</span><br><span class="line">  uint addrs[NDIRECT+1];   // Data block addresses</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Inodes per block.</span><br><span class="line"><span class="comment">#define IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"></span><br><span class="line">// Block containing inode i</span><br><span class="line"><span class="comment">#define IBLOCK(i)     ((i) / IPB + 2)</span></span><br><span class="line"></span><br><span class="line">// Bitmap bits per block</span><br><span class="line"><span class="comment">#define BPB           (BSIZE*8)</span></span><br><span class="line"></span><br><span class="line">// Block containing bit <span class="keyword">for</span> block b</span><br><span class="line"><span class="comment">#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)</span></span><br><span class="line"></span><br><span class="line">// Directory is a file containing a sequence of dirent structures.</span><br><span class="line"><span class="comment">#define DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line">// 文件或目录据结构，目录本身是以文件的方式存储到磁盘上的，叫做目录文件。</span><br><span class="line">struct dirent &#123;</span><br><span class="line">  ushort inum; // i节点</span><br><span class="line">  char name[DIRSIZ]; // 文件或目录名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>file.h：声明inode、file数据结构。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">  // 分为管道文件,设备文件,普通文件</span><br><span class="line">  enum &#123; FD_NONE, FD_PIPE, FD_INODE &#125; <span class="built_in">type</span>; </span><br><span class="line">  int ref; // reference count</span><br><span class="line">  char readable;</span><br><span class="line">  char writable;</span><br><span class="line">  struct pipe *pipe;</span><br><span class="line">  struct inode *ip; // 指向inode节点</span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在内存中inode节点体现形式</span><br><span class="line">// <span class="keyword">in</span>-memory copy of an inode</span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  int flags;          // I_BUSY, I_VALID</span><br><span class="line"></span><br><span class="line">  // 下面这些编程都是dinode的拷贝</span><br><span class="line">  // copy of disk inode</span><br><span class="line">  short <span class="built_in">type</span>;         </span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+1];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#define I_BUSY 0x1</span></span><br><span class="line"><span class="comment">#define I_VALID 0x2</span></span><br><span class="line"></span><br><span class="line">// table mapping major device number to device <span class="built_in">functions</span></span><br><span class="line">struct devsw &#123;</span><br><span class="line">  int (*<span class="built_in">read</span>)(struct inode*, char*, int);</span><br><span class="line">  int (*write)(struct inode*, char*, int);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern struct devsw devsw[];</span><br><span class="line"></span><br><span class="line"><span class="comment">#define CONSOLE 1</span></span><br></pre></td></tr></table></figure><ol start="6"><li>ide.c：磁盘IO的具体实现，xv6维护了一个进程请求磁盘操作的队列(idequeue)。当进程调用<strong>void iderw(struct buf *b)</strong>请求读写磁盘时，该请求被加入等待队列idequeue，同时进程进入睡眠状态。当一个磁盘读写操作完成时，会触发一个中断，中断处理程序ideintr()会移除队列开头的请求，唤醒队列开头请求所对应的进程。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// idequeue points to the buf now being <span class="built_in">read</span>/written to the disk.</span><br><span class="line">// idequeue-&gt;qnext points to the next buf to be processed.</span><br><span class="line">// You must hold idelock <span class="keyword">while</span> manipulating queue.</span><br><span class="line"></span><br><span class="line">static struct spinlock idelock; // 保护 idequeue</span><br><span class="line">static struct buf *idequeue; // 磁盘读写操作的请求队列</span><br><span class="line">……</span><br><span class="line">// 等待磁盘进入空闲状态</span><br><span class="line">// Wait <span class="keyword">for</span> IDE disk to become ready.</span><br><span class="line">static int idewait(int checkerr)</span><br><span class="line">&#123;</span><br><span class="line">  ……</span><br><span class="line">  // </span><br><span class="line">  <span class="keyword">while</span>(((r = inb(0x1f7)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化IDE磁盘IO</span><br><span class="line">void ideinit(void)</span><br><span class="line">&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始一个磁盘读写请求</span><br><span class="line">// Start the request <span class="keyword">for</span> b.  Caller must hold idelock.</span><br><span class="line">static void idestart(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当磁盘请求完成后中断处理程序会调用的函数</span><br><span class="line">// Interrupt handler.</span><br><span class="line">void ideintr(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 处理完一个磁盘IO请求后，唤醒等待在等待队列头的那个进程</span><br><span class="line">  wakeup(b);</span><br><span class="line">  </span><br><span class="line">  // 如果队列不为空，继续处理下一个磁盘IO任务</span><br><span class="line">  // Start disk on next buf <span class="keyword">in</span> queue.</span><br><span class="line">  <span class="keyword">if</span>(idequeue != 0)</span><br><span class="line">    idestart(idequeue);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//PAGEBREAK!  上层文件系统调用的磁盘IO接口</span><br><span class="line">// Sync buf with disk. </span><br><span class="line">// If B_DIRTY is <span class="built_in">set</span>, write buf to disk, clear B_DIRTY, <span class="built_in">set</span> B_VALID.</span><br><span class="line">// Else <span class="keyword">if</span> B_VALID is not <span class="built_in">set</span>, <span class="built_in">read</span> buf from disk, <span class="built_in">set</span> B_VALID.</span><br><span class="line">void iderw(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 竞争锁</span><br><span class="line">  acquire(&amp;idelock);  //DOC:acquire-lock</span><br><span class="line"></span><br><span class="line">  // Append b to idequeue.</span><br><span class="line">  b-&gt;qnext = 0;</span><br><span class="line">  <span class="keyword">for</span>(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext)  //DOC:insert-queue</span><br><span class="line">    ;</span><br><span class="line">  *pp = b;</span><br><span class="line">  </span><br><span class="line">  // Start disk <span class="keyword">if</span> necessary.  开始处理一个磁盘IO任务</span><br><span class="line">  <span class="keyword">if</span>(idequeue == b)</span><br><span class="line">    idestart(b);</span><br><span class="line">  </span><br><span class="line">  // Wait <span class="keyword">for</span> request to finish.  睡眠等待</span><br><span class="line">  <span class="keyword">while</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)&#123;</span><br><span class="line">    sleep(b, &amp;idelock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;idelock);  // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>bio.c：Buffer Cache的具体实现。因为读写磁盘操作效率不高，根据时间与空间局部性原理，这里将最近经常访问的磁盘块缓存在内存中。主要接口有struct buf<em> bread(uint dev, uint sector)、void bwrite(struct buf </em>b)，bread会首先从缓存中去寻找块是否存在，如果存在直接返回，如果不存在则请求磁盘读操作，读到缓存中后再返回结果。bwrite直接将缓存中的数据写入磁盘。</li><li>log.c：该模块主要是维护文件系统的一致性。引入log模块后，对于上层文件系统的全部磁盘操作都被切分为transaction，每个transaction都会首先将数据和其对应磁盘号写入磁盘上的log区域，且只有在log区域写入成功后，才将log区域的数据写入真正存储的数据块。因此，如果在写log的时候宕机，重启后文件系统视为该log区的写入不存在，如果从log区写到真实区域的时候宕机，则可根据log区域的数据恢复。</li><li>sysfile.c：主要定义了与文件相关的系统调用。主要接口及含义如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a file descriptor <span class="keyword">for</span> the given file.</span><br><span class="line">// Takes over file reference from <span class="built_in">caller</span> on success.</span><br><span class="line">static int fdalloc(struct file *f)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 申请一个未使用的文件句柄</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_dup(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 调用filedup对文件句柄的引用计数+1</span><br><span class="line">  filedup(f);</span><br><span class="line">  <span class="built_in">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_read(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 读取文件数据</span><br><span class="line">  <span class="built_in">return</span> fileread(f, p, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_write(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 向文件写数据</span><br><span class="line">  <span class="built_in">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_close(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 释放文件句柄资源</span><br><span class="line">  fileclose(f);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_fstat(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 修改文件统计信息</span><br><span class="line">  <span class="built_in">return</span> filestat(f, st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create the path new as a link to the same inode as old.</span><br><span class="line">int sys_link(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 为已有的inode创建一个新名字</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//PAGEBREAK!</span><br><span class="line">int sys_unlink(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 解除inode中的某个名字, 若名字全被移除, inode回被释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct inode* create(char *path, short <span class="built_in">type</span>, </span><br><span class="line">    short major, short minor)</span><br><span class="line">&#123;</span><br><span class="line">  …… // </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_mkdir(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 创建一个目录</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_mknod(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 创建一个新文件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_chdir(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 切换目录</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sys_pipe(void)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 创建一个管道文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>exec.c：只有一个exec接口，实质就是传入elf格式的可执行文件，装载到内存并分配内存页，argv是一个指针数组，用于携带参数。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">exec</span>(char *path, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  …… // 判断文件是否存在</span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == 0)</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  pgdir = 0;</span><br><span class="line"></span><br><span class="line">  // Check ELF header  检查elf头是否合法</span><br><span class="line">  <span class="keyword">if</span>(readi(ip, (char*)&amp;elf, 0, sizeof(elf)) &lt; sizeof(elf))</span><br><span class="line">    goto bad;</span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">  // Load program into memory.</span><br><span class="line">  sz = 0;</span><br><span class="line">  <span class="keyword">for</span>(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, (char*)&amp;ph, off, sizeof(ph)) != sizeof(ph))</span><br><span class="line">      goto bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="built_in">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      goto bad;</span><br><span class="line">    <span class="keyword">if</span>((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)</span><br><span class="line">      goto bad;</span><br><span class="line">    <span class="keyword">if</span>(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &lt; 0)</span><br><span class="line">      goto bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  ip = 0;</span><br><span class="line"></span><br><span class="line">  // Allocate two pages at the next page boundary.</span><br><span class="line">  // Make the first inaccessible.  Use the second as the user stack.</span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  <span class="keyword">if</span>((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)</span><br><span class="line">    goto bad;</span><br><span class="line">  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));</span><br><span class="line">  sp = sz;</span><br><span class="line"></span><br><span class="line">  // Push argument strings, prepare rest of stack <span class="keyword">in</span> ustack.</span><br><span class="line">  <span class="keyword">for</span>(argc = 0; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      goto bad;</span><br><span class="line">    sp = (sp - (strlen(argv[argc]) + 1)) &amp; ~3;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) &lt; 0)</span><br><span class="line">      goto bad;</span><br><span class="line">    ustack[3+argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pgdir)</span><br><span class="line">    freevm(pgdir);</span><br><span class="line">  <span class="keyword">if</span>(ip)</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">  <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise2-带着问题阅读"><a href="#Exercise2-带着问题阅读" class="headerlink" title="Exercise2 带着问题阅读"></a>Exercise2 带着问题阅读</h2><ol><li>了解 UNIX 文件系统的主要组成部分：超级块(superblock)，i节点(inode)，数据块(datablock)，目录块(directoryblock)，间接块(indirectionblock)。分别解释它们的作用。</li></ol><table><thead><tr><th style="text-align:center">boot</th><th style="text-align:center">super block</th><th style="text-align:center">dinode</th><th style="text-align:center">free bitmap blocks</th><th style="text-align:center">data blocks</th><th style="text-align:center">log blocks</th></tr></thead><tbody><tr><td style="text-align:center">第0块</td><td style="text-align:center">第1块</td><td style="text-align:center">superblock.ninodes块</td><td style="text-align:center">位图管理空闲区块</td><td style="text-align:center">superblock.nblocks块</td><td style="text-align:center">superblock.nlog块</td></tr></tbody></table><ul><li>bootloader引导区(第0块)：用于存放引导程序，系统启动从这里开始；</li><li>superblock超级块(第1块)：记录文件系统的元信息，如文件系统的总块数，数据块块数，i节点数，日志的块数；</li><li>i节点(inode)：从第2块开始存放 i 节点，每一块能够存放多个 i 节点；</li><li>bitmap空闲块管理区：用于存放空闲块位图，因为系统需要知道文件系统的使用情况，哪些块已经分配出去了，哪些块还未被分配；</li><li>数据块 (datablock)：数据块存储的是真真实实的文件内容；</li><li>目录块(directoryblock)：文件系统中除了文件外，还有目录，目录本身是一个文件目录(由很多FCB组成)，文件目录也需要以文件的形式存储到磁盘上，存储到磁盘上的这个文件叫做目录文件，目录文件就是存储到目录块中的；</li><li>间接块(indirectionblock)：xv6这里应该是指log日志块，这是文件系统执行磁盘IO操作的中间层，主要目的是维护文件系统的一致性。</li></ul><ol start="2"><li>阅读文件ide.c。这是一个简单的ide硬盘驱动程序，对其内容作大致了解。</li></ol><ul><li>xv6 的文件系统分6层实现，从底至顶如下：</li></ul><table><thead><tr><th style="text-align:center">System calls</th><th style="text-align:center">File descriptors</th></tr></thead><tbody><tr><td style="text-align:center">Pathnames</td><td style="text-align:center">Recursive lookup</td></tr><tr><td style="text-align:center">Directories</td><td style="text-align:center">Directory inodes</td></tr><tr><td style="text-align:center">Files</td><td style="text-align:center">Inodes and block allocator</td></tr><tr><td style="text-align:center">Transactions</td><td style="text-align:center">Logging</td></tr><tr><td style="text-align:center">Blocks</td><td style="text-align:center">Buffer cache</td></tr></tbody></table><ul><li>底层通过块缓冲Buffer cache读写IDE 硬盘，它同步了对磁盘的访问，保证同时只有一个内核进程可以修改磁盘块；</li><li>第二层Loggins向上层提供服务，该层实现了文件系统的一致性，使得更高层的接口可以将对磁盘的更新按会话打包，通过会话的方式来保证这些操作是原子操作(要么都被应用，要么都不被应用)；</li><li>第三层提供无名文件，每一个这样的文件由一个 i 节点和一连串的数据块组成；</li><li>第四层将目录实现为一种特殊的 i 节点，它的内容是一连串的目录项，每一个目录项包含一个文件名和对应的 i 节点；</li><li>第五层提供了层次路经名（如/usr/rtm/xv6/fs.c这样的），这一层通过递归的方式来查询路径对应的文件；</li><li>最后一层将许多 UNIX 的资源（如管道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。</li></ul><ol start="3"><li>阅读文件buf.h，bio.c。了解 XV6 文件系统中buffer cache层的内容和实现。描述buffer双链表数据结构及其初始化过程。了解 buffer的状态。了解对buffer的各种操作。</li></ol><ul><li>数据结构bcache维护了一个由struct buf组成的双向链表，同时bcache.lock用户互斥访问；</li><li>首先系统调用binit()初始化缓存，随即调用initlock初始化bcache.lock，然后循环遍历buf数组，采用头插法逐个链接到bcache.head后；</li><li>上层文件系统读磁盘时，调用bread()，随即调用bget()检查请求的磁盘块是否在缓存中，如果命中，返回缓存命中结果。如果未命中，转到底层的iderw()函数先将此磁盘块从磁盘加载进缓存中，再返回此磁盘块；</li><li>上层文件系统写磁盘时，调用bwrite()直接将缓存中的数据写入磁盘。Buffer Cache层不会尝试执行任何延迟写入的操作，何时调用bwrite()写入磁盘是由上层的文件系统控制的；</li><li>上层文件系统可通过调用brelse()释放一块不再使用的缓冲区。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// buf.h</span><br><span class="line">struct buf &#123;</span><br><span class="line">  int flags;</span><br><span class="line">  uint dev;</span><br><span class="line">  uint sector;</span><br><span class="line">  struct buf *prev; // LRU cache list</span><br><span class="line">  struct buf *next;</span><br><span class="line">  struct buf *qnext; // disk queue</span><br><span class="line">  uchar data[512];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// bio.c</span><br><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  // Linked list of all buffers, through prev/next.</span><br><span class="line">  // head.next is most recently used.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line">void binit(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf *b;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">"bcache"</span>);</span><br><span class="line"></span><br><span class="line">  //PAGEBREAK!  头插法,每次都是插入到bcache.head的后面</span><br><span class="line">  // Create linked list of buffers</span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    b-&gt;dev = -1;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Return a B_BUSY buf with the contents of the indicated disk sector.</span><br><span class="line">struct buf* bread(uint dev, uint sector)</span><br><span class="line">&#123;</span><br><span class="line">  struct buf *b;</span><br><span class="line">  // 优先查找缓存</span><br><span class="line">  b = bget(dev, sector);</span><br><span class="line">  <span class="keyword">if</span>(!(b-&gt;flags &amp; B_VALID))</span><br><span class="line">    iderw(b);  // 命中失败时调用下一次接口真真实实读磁盘</span><br><span class="line">  <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Write b<span class="string">'s contents to disk.  Must be B_BUSY.</span></span><br><span class="line"><span class="string">void bwrite(struct buf *b)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  if((b-&gt;flags &amp; B_BUSY) == 0)</span></span><br><span class="line"><span class="string">    panic("bwrite");</span></span><br><span class="line"><span class="string">  b-&gt;flags |= B_DIRTY;</span></span><br><span class="line"><span class="string">  iderw(b); // 立即写, 未延迟写</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>阅读文件log.c，了解XV6文件系统中的logging和transaction机制;<br>日志存在于磁盘末端已知的固定区域。它包含了一个起始块，紧接着一连串的数据块。起始块包含了一个扇区号的数组，每一个对应于日志中的数据块，起始块还包含了日志数据块的计数。xv6 在提交后修改日志的起始块，而不是之前，并且在将日志中的数据块都拷贝到文件系统之后将数据块计数清0。提交之后，清0之前的崩溃就会导致一个非0的计数值。</p></li><li><p>阅读文件fs.h/fs.c。了解XV6文件系统的硬盘布局。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// On-disk inode structure</span><br><span class="line">struct dinode &#123;</span><br><span class="line">  short <span class="built_in">type</span>;           // File <span class="built_in">type</span></span><br><span class="line">  short major;          // Major device number (T_DEV only)</span><br><span class="line">  short minor;          // Minor device number (T_DEV only)</span><br><span class="line">  short nlink;          // Number of links to inode <span class="keyword">in</span> file system</span><br><span class="line">  uint size;            // Size of file (bytes)</span><br><span class="line">  // NDIRECT = 12, 前12个为直接索引, </span><br><span class="line">  // 第13个为间接索引, 可容纳128个直接索引</span><br><span class="line">  uint addrs[NDIRECT+1];   // Data block addresses  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/08/xv6-filesystem/disk-inode.png" alt="php-app"></p><ol start="6"><li>阅读文件file.h/file.c。了解XV6的“文件”有哪些，以及文件，i节点，设备相关的数据结构。了解XV6对文件的基本操作有哪些。XV6最多支持多少个文件? 每个进程最多能打开多少个文件?</li></ol><ul><li>xv6文件分为管道文件，设备文件和普通文件；</li><li>XV6最多支持同时打开100个文件，也就是分配100个文件句柄；</li><li>单个进程最多能打开16个文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// param.h</span><br><span class="line"><span class="comment">#define NOFILE       16  // open files per process</span></span><br><span class="line"><span class="comment">#define NFILE       100  // open files per system</span></span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>阅读文件sysfile.c。了解与文件系统相关的系统调用，简述各个系统调用的作用。<br>参见源代码阅读部分，已经做出了完整解答。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter6.html" rel="external nofollow noopener noreferrer" target="_blank">xv6中文文档</a><br>[2] <a href="https://www.cnblogs.com/hehao98/p/10953777.html" rel="external nofollow noopener noreferrer" target="_blank">xv6文件系统博客园</a><br>[3] <a href="https://blog.csdn.net/fantasy_wxe/article/details/8120112" rel="external nofollow noopener noreferrer" target="_blank">xv6文件系统CSDN</a><br>[4] <a href="https://blog.csdn.net/zhanglei8893/article/details/6113868" rel="external nofollow noopener noreferrer" target="_blank">xv6文件系统CSDN</a><br>[5] 操作系统-文件系统课件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Exercise1-源代码阅读&quot;&gt;&lt;a href=&quot;#Exercise1-源代码阅读&quot; class=&quot;headerlink&quot; title=&quot;Exercise1 源代码阅读&quot;&gt;&lt;/a&gt;Exercise1 源代码阅读&lt;/h2&gt;&lt;p&gt;文件系统部分 buf.h fcntl
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="XV6" scheme="https://icoty.github.io/tags/XV6/"/>
    
      <category term="文件系统" scheme="https://icoty.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>epoll源码分析(基于linux-5.1.4)</title>
    <link href="https://icoty.github.io/2019/06/03/epoll-source/"/>
    <id>https://icoty.github.io/2019/06/03/epoll-source/</id>
    <published>2019-06-03T12:49:38.000Z</published>
    <updated>2019-06-08T02:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>epoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系。</p><ol><li><p>int epoll_create1(int size)；</p><p> 创建一个epfd句柄，size为0时等价于int epoll_create(0)。</p></li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p><p>向epfd上添加/修改/删除fd。</p></li><li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)；</p><p>返回所有就绪的fd。</p></li></ol><h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>先上一张UML类图，从整体进行把握，图中已经标出各个数据结构所在的文件。</p><p><img src="/2019/06/03/epoll-source/epoll-data-structure.png" alt="cmd"></p><p>下面贴出各个数据结构代码，切记，实际在过代码的时候，其实我们没有必要对每一个变量和每一行代码咬文嚼字，也不建议这样去做，我们只需要重点关注主要的数据成员和那些关键的代码行，把心思和精力投入到我们最该关注的那部分，从框架层面去把握整体，抓准各个模块的核心，各个模块之间如何耦合，如何同步，如何通信等，这才是能够让你快速进步的最优路线。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Each file descriptor added to the eventpoll interface will</span><br><span class="line">* have an entry of this <span class="built_in">type</span> linked to the <span class="string">"rbr"</span> RB tree.</span><br><span class="line">* Avoid increasing the size of this struct, there can be many thousands</span><br><span class="line">* of these on a server and we <span class="keyword">do</span> not want this to take another cache line.</span><br><span class="line">*/</span><br><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        /* RB tree node links this structure to the eventpoll RB tree */</span><br><span class="line">        struct rb_node rbn;</span><br><span class="line">        /* Used to free the struct epitem */</span><br><span class="line">        struct rcu_head rcu;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this structure to the eventpoll ready list */</span><br><span class="line">    struct list_head rdllink;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Works together <span class="string">"struct eventpoll"</span>-&gt;ovflist <span class="keyword">in</span> keeping the</span><br><span class="line">    * single linked chain of items.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *next;</span><br><span class="line"></span><br><span class="line">    /* The file descriptor information this item refers to */</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    /* Number of active <span class="built_in">wait</span> queue attached to poll operations */</span><br><span class="line">    int nwait;</span><br><span class="line"></span><br><span class="line">    /* List containing poll <span class="built_in">wait</span> queues */</span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"container"</span> of this item */</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this item to the <span class="string">"struct file"</span> items list */</span><br><span class="line">    struct list_head fllink;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when EPOLLWAKEUP is <span class="built_in">set</span> */</span><br><span class="line">    struct wakeup_source __rcu *ws;</span><br><span class="line"></span><br><span class="line">    /* The structure that describe the interested events and the <span class="built_in">source</span> fd */</span><br><span class="line">    struct epoll_event event;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* This structure is stored inside the <span class="string">"private_data"</span> member of the file</span><br><span class="line">* structure and represents the main data structure <span class="keyword">for</span> the eventpoll</span><br><span class="line">* interface.</span><br><span class="line">*/</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">    /*</span><br><span class="line">    * This mutex is used to ensure that files are not removed</span><br><span class="line">    * <span class="keyword">while</span> epoll is using them. This is held during the event</span><br><span class="line">    * collection loop, the file cleanup path, the epoll file <span class="built_in">exit</span></span><br><span class="line">    * code and the ctl operations.</span><br><span class="line">    */</span><br><span class="line">    struct mutex mtx;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by sys_epoll_wait() */</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by file-&gt;poll() */</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line"></span><br><span class="line">    /* List of ready file descriptors */</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">    /* Lock <span class="built_in">which</span> protects rdllist and ovflist */</span><br><span class="line">    rwlock_t lock;</span><br><span class="line"></span><br><span class="line">    /* RB tree root used to store monitored fd structs */</span><br><span class="line">    struct rb_root_cached rbr;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * This is a single linked list that chains all the <span class="string">"struct epitem"</span> that</span><br><span class="line">    * happened <span class="keyword">while</span> transferring ready events to userspace w/out</span><br><span class="line">    * holding -&gt;lock.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *ovflist;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when ep_scan_ready_list is running */</span><br><span class="line">    struct wakeup_source *ws;</span><br><span class="line"></span><br><span class="line">    /* The user that created the eventpoll descriptor */</span><br><span class="line">    struct user_struct *user;</span><br><span class="line"></span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* used to optimize loop detection check */</span><br><span class="line">    int visited;</span><br><span class="line">    struct list_head visited_list_link;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">    /* used to track busy poll napi_id */</span><br><span class="line">    unsigned int napi_id;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* eppoll_entry主要完成epitem和epitem事件发生时的callback（ep_poll_callback）</span><br><span class="line"> * 函数之间的关联，并将上述两个数据结构包装成一个链表节点，</span><br><span class="line"> * 挂载到目标文件file的waithead中。</span><br><span class="line"> * Wait structure used by the poll hooks</span><br><span class="line"> */</span><br><span class="line">struct eppoll_entry &#123;</span><br><span class="line">    /* List header used to link this structure to the <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct list_head llink;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"base"</span> pointer is <span class="built_in">set</span> to the container <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct epitem *base;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wait queue item that will be linked to the target file <span class="built_in">wait</span></span><br><span class="line">     * queue head.</span><br><span class="line">     */</span><br><span class="line">    wait_queue_entry_t <span class="built_in">wait</span>;</span><br><span class="line"></span><br><span class="line">    /* The <span class="built_in">wait</span> queue head that linked the <span class="string">"wait"</span> <span class="built_in">wait</span> queue item */</span><br><span class="line">    wait_queue_head_t *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* ep_pqueue主要完成epitem和callback函数的关联。</span><br><span class="line"> * 然后通过目标文件的poll函数调用callback函数ep_ptable_queue_proc。</span><br><span class="line"> * Poll函数一般由设备驱动提供，以网络设备为例，</span><br><span class="line"> * 他的poll函数为sock_poll然后根据sock类型调用不同的poll函数如：</span><br><span class="line"> * packet_poll。packet_poll在通过datagram_poll调用sock_poll_wait，</span><br><span class="line"> * 最后在poll_wait实际调用callback函数（ep_ptable_queue_proc）</span><br><span class="line"> * Wrapper struct used by poll queueing</span><br><span class="line"> */</span><br><span class="line">struct ep_pqueue &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Used by the ep_send_events() <span class="keyword">function</span> as callback private data */</span><br><span class="line">struct ep_send_events_data &#123;</span><br><span class="line">    int maxevents;</span><br><span class="line">    struct epoll_event __user *events;</span><br><span class="line">    int res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fd &#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    unsigned int flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="全局调用关系"><a href="#全局调用关系" class="headerlink" title="全局调用关系"></a>全局调用关系</h2><p>再贴一张各个API从用户进程陷入到内核态并执行系统调用的详细过程，以及client发数据过来时触发ep_poll_callback回调函数的执行流程。</p><p><img src="/2019/06/03/epoll-source/epoll-sequence" alt="cmd"></p><h2 id="epoll模块初始化-amp-内存池开辟"><a href="#epoll模块初始化-amp-内存池开辟" class="headerlink" title="epoll模块初始化&amp;内存池开辟"></a>epoll模块初始化&amp;内存池开辟</h2><p>epoll是内核的一个module，内核启动时会初始化这个module。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">static int __init eventpoll_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sysinfo si;</span><br><span class="line"></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    /*</span><br><span class="line">     * Allows top 4% of lomem to be allocated <span class="keyword">for</span> epoll watches (per user).</span><br><span class="line">     */</span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    BUG_ON(max_user_watches &lt; 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Initialize the structure used to perform epoll file descriptor</span><br><span class="line">     * inclusion loops checks.</span><br><span class="line">     */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    /* Initialize the structure used to perform safe poll <span class="built_in">wait</span> head wake ups */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We can have many thousands of epitems, so prevent this from</span><br><span class="line">     * using an extra cache line on 64-bit (and smaller) CPUs</span><br><span class="line">     */</span><br><span class="line">    BUILD_BUG_ON(sizeof(void *) &lt;= 8 &amp;&amp; sizeof(struct epitem) &gt; 128);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_epi内存池,UML时序图的第21步alloc时直接从内存池里取,</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct epitem"</span> items */</span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, </span><br><span class="line">        sizeof(struct epitem),0, placehold_flag, 0);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_pwq内存池,UML时序图的第28步alloc时直接从内存池里取</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct eppoll_entry"</span> */</span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,</span><br><span class="line">        sizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(eventpoll_init);</span><br></pre></td></tr></table></figure><h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>用户空间调用epoll_create(0)或epoll_create1(int)，其实质就是在名为”eventpollfs”的文件系统里创建了一个新文件，同时为该文件申请一个fd，绑定一个inode，最后返回该文件句柄。</p><h3 id="epoll-create-epoll-create1陷入内核"><a href="#epoll-create-epoll-create1陷入内核" class="headerlink" title="epoll_create/epoll_create1陷入内核"></a>epoll_create/epoll_create1陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create, int, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-epoll-create-ep-alloc"><a href="#do-epoll-create-ep-alloc" class="headerlink" title="do_epoll_create/ep_alloc"></a>do_epoll_create/ep_alloc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Open an eventpoll file descriptor.</span><br><span class="line"> */</span><br><span class="line">static int do_epoll_create(int flags)</span><br><span class="line">&#123;</span><br><span class="line">    int error, fd;</span><br><span class="line">    struct eventpoll *ep = NULL;</span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* Check the EPOLL_* constant <span class="keyword">for</span> consistency.  */</span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    /*</span><br><span class="line">     * 申请一个struct eventpoll内存空间,执行初始化后赋给ep</span><br><span class="line">     * Create the internal data structure (<span class="string">"struct eventpoll"</span>).</span><br><span class="line">     */</span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> error;</span><br><span class="line">    /*</span><br><span class="line">     * 获取一个未使用的fd句柄</span><br><span class="line">     * Creates all the items needed to setup an eventpoll file. That is,</span><br><span class="line">     * a file structure and a free file descriptor.</span><br><span class="line">     */</span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; 0) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        goto out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                              O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        goto out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    // 绑定fd和file</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    // 这个fd就是epfd句柄,返回给用户进程的</span><br><span class="line">    <span class="built_in">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// fs/eventpoll.c</span><br><span class="line">// 形参是一个二级指针,该接口就是简单的分配一个struct eventpoll,然后执行初始化工作</span><br><span class="line">static int ep_alloc(struct eventpoll **pep)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct user_struct *user;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    user = get_current_user();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = kzalloc(sizeof(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!ep))</span><br><span class="line">        goto free_uid;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;ep-&gt;mtx);</span><br><span class="line">    rwlock_init(&amp;ep-&gt;lock);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;wq);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;poll_wait);</span><br><span class="line">    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);</span><br><span class="line">    ep-&gt;rbr = RB_ROOT_CACHED;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line"></span><br><span class="line">    *pep = ep;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">free_uid:</span><br><span class="line">    free_uid(user);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="anon-inode-getfile-alloc-file-pseudo-alloc-file"><a href="#anon-inode-getfile-alloc-file-pseudo-alloc-file" class="headerlink" title="anon_inode_getfile/alloc_file_pseudo/alloc_file"></a>anon_inode_getfile/alloc_file_pseudo/alloc_file</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * fs/anon_inodes.c</span><br><span class="line"> * anon_inode_getfile - creates a new file instance by hooking it up to an</span><br><span class="line"> *                      anonymous inode, and a dentry that describe the <span class="string">"class"</span></span><br><span class="line"> *                      of the file</span><br><span class="line"> *</span><br><span class="line"> * @name:    [<span class="keyword">in</span>]    name of the <span class="string">"class"</span> of the new file</span><br><span class="line"> * @fops:    [<span class="keyword">in</span>]    file operations <span class="keyword">for</span> the new file</span><br><span class="line"> * @priv:    [<span class="keyword">in</span>]    private data <span class="keyword">for</span> the new file (will be file<span class="string">'s private_data)</span></span><br><span class="line"><span class="string"> * @flags:   [in]    flags</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Creates a new file by hooking it on a single inode. This is useful for files</span></span><br><span class="line"><span class="string"> * that do not need to have a full-fledged inode in order to operate correctly.</span></span><br><span class="line"><span class="string"> * All the files created with anon_inode_getfile() will share a single inode,</span></span><br><span class="line"><span class="string"> * hence saving memory and avoiding code duplication for the file/inode/dentry</span></span><br><span class="line"><span class="string"> * setup.  Returns the newly created file* or an error pointer.</span></span><br><span class="line"><span class="string"> * 在一个inode上挂接一个新文件,这对于不需要完整inode才能正确操作的文件非常有用。</span></span><br><span class="line"><span class="string"> * 使用anon_inode_getfile()创建的所有文件都将共享一个inode，</span></span><br><span class="line"><span class="string"> * 因此可以节省内存并避免文件/inode/dentry设置的代码重复。</span></span><br><span class="line"><span class="string"> * 返回新创建的文件*或错误指针。</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct file *anon_inode_getfile(const char *name,const struct file_operations *fops,void *priv, int flags)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (IS_ERR(anon_inode_inode))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENODEV);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (fops-&gt;owner &amp;&amp; !try_module_get(fops-&gt;owner))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOENT);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * We know the anon_inode inode count is always greater than zero,</span></span><br><span class="line"><span class="string">    * so ihold() is safe.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    ihold(anon_inode_inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // 创建一个名字为“[eventpoll]”的eventpollfs文件描述符</span></span><br><span class="line"><span class="string">    file = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,</span></span><br><span class="line"><span class="string">                             flags &amp; (O_ACCMODE | O_NONBLOCK), fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        goto err;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = anon_inode_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // file-&gt;private_data指向传进来的priv( = struct eventpoll *ep)</span></span><br><span class="line"><span class="string">    file-&gt;private_data = priv;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err:</span></span><br><span class="line"><span class="string">    iput(anon_inode_inode);</span></span><br><span class="line"><span class="string">    module_put(fops-&gt;owner);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL_GPL(anon_inode_getfile);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// fs/file_table.c</span></span><br><span class="line"><span class="string">struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,</span></span><br><span class="line"><span class="string">    const char *name, int flags,const struct file_operations *fops)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    static const struct dentry_operations anon_ops = &#123;</span></span><br><span class="line"><span class="string">        .d_dname = simple_dname</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    struct qstr this = QSTR_INIT(name, strlen(name));</span></span><br><span class="line"><span class="string">    struct path path;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 挂载名为“[eventpoll]”的eventpollfs文件系统</span></span><br><span class="line"><span class="string">    path.dentry = d_alloc_pseudo(mnt-&gt;mnt_sb, &amp;this);</span></span><br><span class="line"><span class="string">    if (!path.dentry)</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOMEM);</span></span><br><span class="line"><span class="string">    if (!mnt-&gt;mnt_sb-&gt;s_d_op)</span></span><br><span class="line"><span class="string">        d_set_d_op(path.dentry, &amp;anon_ops);</span></span><br><span class="line"><span class="string">    path.mnt = mntget(mnt);</span></span><br><span class="line"><span class="string">    d_instantiate(path.dentry, inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // inode和file绑定，返回绑定后的file结构</span></span><br><span class="line"><span class="string">    file = alloc_file(&amp;path, flags, fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file)) &#123;</span></span><br><span class="line"><span class="string">        ihold(inode);</span></span><br><span class="line"><span class="string">        path_put(&amp;path);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL(alloc_file_pseudo);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/file_table.c</span></span><br><span class="line"><span class="string"> * alloc_file - allocate and initialize a '</span>struct file<span class="string">'</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @path: the (dentry, vfsmount) pair for the new file</span></span><br><span class="line"><span class="string"> * @flags: O_... flags with which the new file will be opened</span></span><br><span class="line"><span class="string"> * @fop: the '</span>struct file_operations<span class="string">' for the new file</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static struct file *alloc_file(const struct path *path, int flags,</span></span><br><span class="line"><span class="string">    const struct file_operations *fop)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 申请一个空的file结构</span></span><br><span class="line"><span class="string">    file = alloc_empty_file(flags, current_cred());</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_path = *path;</span></span><br><span class="line"><span class="string">    file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string">    file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(fop-&gt;read || fop-&gt;read_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_READ;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(fop-&gt;write || fop-&gt;write_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_WRITE;</span></span><br><span class="line"><span class="string">    file-&gt;f_mode |= FMODE_OPENED;</span></span><br><span class="line"><span class="string">    file-&gt;f_op = fop;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span></span><br><span class="line"><span class="string">        i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p>用户进程调用int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)，op可填EPOLL_CTL_ADD(注册fd到epfd)、EPOLL_CTL_MOD(修改已注册fd监听的事件)和EPOLL_CTL_DEL(从epfd中删除fd)。</p><h3 id="epoll-ctl陷入内核"><a href="#epoll-ctl陷入内核" class="headerlink" title="epoll_ctl陷入内核"></a>epoll_ctl陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * The following <span class="keyword">function</span> implements the controller interface <span class="keyword">for</span></span><br><span class="line"> * the eventpoll file that enables the insertion/removal/change of</span><br><span class="line"> * file descriptors inside the interest <span class="built_in">set</span>.</span><br><span class="line"> */</span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,</span><br><span class="line">                struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    int full_check = 0;</span><br><span class="line"></span><br><span class="line">    struct fd f, tf;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct epoll_event epds;</span><br><span class="line">    struct eventpoll *tep = NULL;</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    // copy_from_user将用户空间关注的event事件拷贝到内核空间</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))</span><br><span class="line">    goto error_return;</span><br><span class="line"></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        goto error_return;</span><br><span class="line"></span><br><span class="line">    /* Get the <span class="string">"struct file *"</span> <span class="keyword">for</span> the target file */</span><br><span class="line">    tf = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tf.file)</span><br><span class="line">        goto error_fput;</span><br><span class="line"></span><br><span class="line">    /* The target file descriptor must support poll */</span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">        goto error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* 如果系统设置了自动休眠模式（通过/sys/power/autosleep），</span><br><span class="line">    * 当唤醒设备的事件发生时，设备驱动会保持唤醒状态，直到事件进入排队状态。</span><br><span class="line">    * 为了保持设备唤醒直到事件处理完成，必须使用epoll EPOLLWAKEUP 标记。</span><br><span class="line">    * 一旦给structe poll_event中的events字段设置了EPOLLWAKEUP标记，系统会在事件排队时就保持唤醒，</span><br><span class="line">    * 从epoll_wait调用开始，持续要下一次epoll_wait调用。</span><br><span class="line">    */</span><br><span class="line">    /* Check <span class="keyword">if</span> EPOLLWAKEUP is allowed */</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">        ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check that the file structure underneath the file descriptor</span><br><span class="line">    * the user passed to us _is_ an eventpoll file. And also we <span class="keyword">do</span> not permit</span><br><span class="line">    * adding an epoll file descriptor inside itself.</span><br><span class="line">    */</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">        goto error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span><br><span class="line">    * so EPOLLEXCLUSIVE is not allowed <span class="keyword">for</span> a EPOLL_CTL_MOD operation.</span><br><span class="line">    * Also, we <span class="keyword">do</span> not currently supported nested exclusive wakeups.</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">            goto error_tgt_fput;</span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">                                    (epds.events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">            goto error_tgt_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * At this point it is safe to assume that the <span class="string">"private_data"</span> contains</span><br><span class="line">    * our own data structure.</span><br><span class="line">    */</span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * When we insert an epoll file descriptor, inside another epoll file</span><br><span class="line">    * descriptor, there is the change of creating closed loops, <span class="built_in">which</span> are</span><br><span class="line">    * better be handled here, than <span class="keyword">in</span> more critical paths. While we are</span><br><span class="line">    * checking <span class="keyword">for</span> loops we also determine the list of files reachable</span><br><span class="line">    * and hang them on the tfile_check_list, so we can check that we</span><br><span class="line">    * haven<span class="string">'t created too many possible wakeup paths.</span></span><br><span class="line"><span class="string">    *</span></span><br><span class="line"><span class="string">    * We do not need to take the global '</span>epumutex<span class="string">' on EPOLL_CTL_ADD when</span></span><br><span class="line"><span class="string">    * the epoll file descriptor is attaching directly to a wakeup source,</span></span><br><span class="line"><span class="string">    * unless the epoll file descriptor is nested. The purpose of taking the</span></span><br><span class="line"><span class="string">    * '</span>epmutex<span class="string">' on add is to prevent complex toplogies such as loops and</span></span><br><span class="line"><span class="string">    * deep wakeup paths from forming in parallel through multiple</span></span><br><span class="line"><span class="string">    * EPOLL_CTL_ADD operations.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">    if (op == EPOLL_CTL_ADD) &#123;</span></span><br><span class="line"><span class="string">        if (!list_empty(&amp;f.file-&gt;f_ep_links) ||</span></span><br><span class="line"><span class="string">            is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">            full_check = 1;</span></span><br><span class="line"><span class="string">            mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string">            mutex_lock(&amp;epmutex);</span></span><br><span class="line"><span class="string">            if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">                error = -ELOOP;</span></span><br><span class="line"><span class="string">                if (ep_loop_check(ep, tf.file) != 0) &#123;</span></span><br><span class="line"><span class="string">                    clear_tfile_check_list();</span></span><br><span class="line"><span class="string">                    goto error_tgt_fput;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                list_add(&amp;tf.file-&gt;f_tfile_llink,</span></span><br><span class="line"><span class="string">                         &amp;tfile_check_list);</span></span><br><span class="line"><span class="string">            mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">            if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">                tep = tf.file-&gt;private_data;</span></span><br><span class="line"><span class="string">                mutex_lock_nested(&amp;tep-&gt;mtx, 1);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * Try to lookup the file inside our RB tree, Since we grabbed "mtx"</span></span><br><span class="line"><span class="string">    * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="string">    * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="string">    * 从红黑树中寻找添加的fd是否存在，存在则返回到ep中，否则返回NULL</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    epi = ep_find(ep, tf.file, fd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    error = -EINVAL;</span></span><br><span class="line"><span class="string">    switch (op) &#123;</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_ADD:</span></span><br><span class="line"><span class="string">            // 若ep为空说明红黑树中不存在,执行ep_insert添加到红黑树中</span></span><br><span class="line"><span class="string">            if (!epi) &#123;</span></span><br><span class="line"><span class="string">                epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">                // 如果不存在则添加，已经存在不重复添加</span></span><br><span class="line"><span class="string">                error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                error = -EEXIST;</span></span><br><span class="line"><span class="string">            if (full_check)</span></span><br><span class="line"><span class="string">                clear_tfile_check_list();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        // 删除fd调用ep_remove</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_DEL:</span></span><br><span class="line"><span class="string">            if (epi)</span></span><br><span class="line"><span class="string">                error = ep_remove(ep, epi);</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                error = -ENOENT;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        // 修改已注册fd所监听的事件,调用ep_modify</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_MOD:</span></span><br><span class="line"><span class="string">            if (epi) &#123;</span></span><br><span class="line"><span class="string">                if (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span></span><br><span class="line"><span class="string">                    epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">                    error = ep_modify(ep, epi, &amp;epds);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                error = -ENOENT;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (tep != NULL)</span></span><br><span class="line"><span class="string">        mutex_unlock(&amp;tep-&gt;mtx);</span></span><br><span class="line"><span class="string">    mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_tgt_fput:</span></span><br><span class="line"><span class="string">    if (full_check)</span></span><br><span class="line"><span class="string">        mutex_unlock(&amp;epmutex);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fdput(tf);</span></span><br><span class="line"><span class="string">error_fput:</span></span><br><span class="line"><span class="string">    fdput(f);</span></span><br><span class="line"><span class="string">error_return:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ep-find"><a href="#ep-find" class="headerlink" title="ep_find"></a>ep_find</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Search the file inside the eventpoll tree. The RB tree operations</span><br><span class="line"> * are protected by the <span class="string">"mtx"</span> mutex, and ep_find() must be called with</span><br><span class="line"> * <span class="string">"mtx"</span> held.</span><br><span class="line"> */</span><br><span class="line">static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int kcmp;</span><br><span class="line">    struct rb_node *rbp;</span><br><span class="line">    struct epitem *epi, *epir = NULL;</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">    </span><br><span class="line">    // 从红黑树根节开始二分查找,判断左右子树</span><br><span class="line">    <span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">        kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">        <span class="keyword">if</span> (kcmp &gt; 0)</span><br><span class="line">            rbp = rbp-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; 0)</span><br><span class="line">            rbp = rbp-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            epir = epi;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> epir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ep-insert"><a href="#ep-insert" class="headerlink" title="ep_insert"></a>ep_insert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Must be called with <span class="string">"mtx"</span> held.</span><br><span class="line"> */</span><br><span class="line">static int ep_insert(struct eventpoll *ep, const struct epoll_event *event,</span><br><span class="line">                     struct file *tfile, int fd, int full_check)</span><br><span class="line">&#123;</span><br><span class="line">    int error, pwake = 0;</span><br><span class="line">    __poll_t revents;</span><br><span class="line">    long user_watches;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    struct ep_pqueue epq;</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">        <span class="built_in">return</span> -ENOSPC;</span><br><span class="line">    </span><br><span class="line">    // epi_cache内存池在epoll模块初始化时已经分配,这里根据slab直接取一个epitem</span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    // 初始化 epitem</span><br><span class="line">    /* Item initialization follow here ... */</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = 0;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">        error = ep_create_wakeup_source(epi);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            goto error_create_wakeup_source;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RCU_INIT_POINTER(epi-&gt;ws, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个struct ep_pqueue epq, 并与epitem(epi)关联</span><br><span class="line">    /* Initialize the poll table using the queue callback */</span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    </span><br><span class="line">    /* 设置epq的回调函数为ep_ptable_queue_proc,当调用poll_wait时会调用该回调函数，</span><br><span class="line">     * 而函数体ep_ptable_queue_proc内部所做的主要工作,</span><br><span class="line">     * 就是把epitem对应fd的事件到来时的回调函数设置为ep_poll_callback。</span><br><span class="line">     * ep_poll_callback所做的主要工作就是把就绪的fd放到就绪链表rdllist上,</span><br><span class="line">     * 然后唤醒epoll_wait的调用者, 被唤醒的进程再把rdllist上就绪的fd的events拷贝给用户进程,</span><br><span class="line">     * 完成一个闭环。</span><br><span class="line">     */</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Attach the item to the poll hooks and get current event bits.</span><br><span class="line">     * We can safely use the file* here because its usage count has</span><br><span class="line">     * been increased by the <span class="built_in">caller</span> of this <span class="keyword">function</span>. Note that after</span><br><span class="line">     * this operation completes, the poll callback can start hitting</span><br><span class="line">     * the new item.</span><br><span class="line">     * 判断当前插入的event是否刚好发生，返回就绪事件的掩码赋给revents,</span><br><span class="line">     * 如果发生，那么做一个ready动作，</span><br><span class="line">     * 后面的<span class="keyword">if</span>语句将epitem加入到rdlist中，并对epoll上的<span class="built_in">wait</span>队列调用wakeup</span><br><span class="line">     */</span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt, 1);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check <span class="keyword">if</span> something went wrong during the poll <span class="built_in">wait</span> queue</span><br><span class="line">    * install process. Namely an allocation <span class="keyword">for</span> a <span class="built_in">wait</span> queue failed due</span><br><span class="line">    * high memory pressure.</span><br><span class="line">    */</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; 0)</span><br><span class="line">        goto error_unregister;</span><br><span class="line"></span><br><span class="line">    /* Add the current item to the list of active epoll hook <span class="keyword">for</span> this file */</span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    </span><br><span class="line">    // 每个文件会将所有监听自己的epitem链起来</span><br><span class="line">    list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Add the current item to the RB tree. All RB tree operations are</span><br><span class="line">    * protected by <span class="string">"mtx"</span>, and ep_insert() is called with <span class="string">"mtx"</span> held.</span><br><span class="line">    * 将epitem插入到对应的eventpoll红黑树中去,红黑树用一个互斥锁进行保护</span><br><span class="line">    */</span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    /* now check <span class="keyword">if</span> we<span class="string">'ve created too many backpaths */</span></span><br><span class="line"><span class="string">    error = -EINVAL;</span></span><br><span class="line"><span class="string">    if (full_check &amp;&amp; reverse_path_check())</span></span><br><span class="line"><span class="string">        goto error_remove_epi;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line"><span class="string">    write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* record NAPI ID of new item if present */</span></span><br><span class="line"><span class="string">    ep_set_busy_poll_napi_id(epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* If the file is already "ready" we drop it inside the ready list */</span></span><br><span class="line"><span class="string">    if (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span></span><br><span class="line"><span class="string">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span></span><br><span class="line"><span class="string">        ep_pm_stay_awake(epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* Notify waiting tasks that events are available */</span></span><br><span class="line"><span class="string">        if (waitqueue_active(&amp;ep-&gt;wq))</span></span><br><span class="line"><span class="string">            wake_up(&amp;ep-&gt;wq);</span></span><br><span class="line"><span class="string">        if (waitqueue_active(&amp;ep-&gt;poll_wait))</span></span><br><span class="line"><span class="string">            pwake++;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* We have to call this outside the lock */</span></span><br><span class="line"><span class="string">    if (pwake)</span></span><br><span class="line"><span class="string">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_remove_epi:</span></span><br><span class="line"><span class="string">    spin_lock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string">    list_del_rcu(&amp;epi-&gt;fllink);</span></span><br><span class="line"><span class="string">    spin_unlock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_unregister:</span></span><br><span class="line"><span class="string">    ep_unregister_pollwait(ep, epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * We need to do this because an event could have been arrived on some</span></span><br><span class="line"><span class="string">    * allocated wait queue. Note that we don'</span>t care about the ep-&gt;ovflist</span><br><span class="line">    * list, since that is used/cleaned only inside a section bound by <span class="string">"mtx"</span>.</span><br><span class="line">    * And ep_insert() is called with <span class="string">"mtx"</span> held.</span><br><span class="line">    */</span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(epi))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line"></span><br><span class="line">error_create_wakeup_source:</span><br><span class="line">    kmem_cache_free(epi_cache, epi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmem-cache-alloc"><a href="#kmem-cache-alloc" class="headerlink" title="kmem_cache_alloc"></a>kmem_cache_alloc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * slab算法从内存池cachep中分配一个实例返回</span><br><span class="line"> * mm/slab.c</span><br><span class="line"> * kmem_cache_alloc - Allocate an object</span><br><span class="line"> * @cachep: The cache to allocate from.</span><br><span class="line"> * @flags: See kmalloc().</span><br><span class="line"> *</span><br><span class="line"> * Allocate an object from this cache.  The flags are only relevant</span><br><span class="line"> * <span class="keyword">if</span> the cache has no available objects.</span><br><span class="line"> *</span><br><span class="line"> * Return: pointer to the new object or %NULL <span class="keyword">in</span> <span class="keyword">case</span> of error</span><br><span class="line"> */</span><br><span class="line">void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    void *ret = slab_alloc(cachep, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">    trace_kmem_cache_alloc(_RET_IP_, ret,</span><br><span class="line">                           cachep-&gt;object_size, cachep-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_alloc);</span><br></pre></td></tr></table></figure><h3 id="init-poll-funcptr-ep-ptable-queue-proc-ep-poll-callback-init-waitqueue-func-entry"><a href="#init-poll-funcptr-ep-ptable-queue-proc-ep-poll-callback-init-waitqueue-func-entry" class="headerlink" title="init_poll_funcptr/ep_ptable_queue_proc/ep_poll_callback/init_waitqueue_func_entry"></a>init_poll_funcptr/ep_ptable_queue_proc/ep_poll_callback/init_waitqueue_func_entry</h3><p>init_poll_funcptr：设置epq的回调函数为ep_ptable_queue_proc，当调用poll_wait时会调用该回调函数；<br>ep_ptable_queue_proc：该函数内部所做的主要工作，就是把epitem对应fd的事件到来时的回调函数设置为ep_poll_callback。<br>ep_poll_callback：主要工作就是把就绪的fd放到就绪链表rdllist上，然后唤醒epoll_wait的调用者，被唤醒的进程再把rdllist上就绪的fd的events拷贝给用户进程，完成一个闭环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 设置回调</span><br><span class="line"> * include/linux/poll.h</span><br><span class="line"> */</span><br><span class="line">static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)</span><br><span class="line">&#123;</span><br><span class="line">    pt-&gt;_qproc = qproc;</span><br><span class="line">    pt-&gt;_key   = ~(__poll_t)0; /* all events enabled */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This is the callback that is used to add our <span class="built_in">wait</span> queue to the</span><br><span class="line"> * target file wakeup lists.</span><br><span class="line"> * struct file *file（目标文件）= epi-&gt;ffd.file,</span><br><span class="line"> * wait_queue_head_t *whead（目标文件的waitlist）= eventpoll-&gt;poll_wait,</span><br><span class="line"> * poll_table *pt（前面生成的poll_table）</span><br><span class="line"> */</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">    struct epitem *epi = ep_item_from_epqueue(pt);</span><br><span class="line">    // 创建一个struct eppoll_entry,与对应的epitem关联上</span><br><span class="line">    struct eppoll_entry *pwq;</span><br><span class="line">    </span><br><span class="line">    // 从pwq_cache内存池中取一个struct eppoll_entry</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        // 把每个epitem对应的回调函数设置为ep_poll_callback,</span><br><span class="line">        // 当epitem关注的事件中断到来时会执行回调函数ep_poll_callback</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;<span class="built_in">wait</span>, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        // 关联上epitem</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        // 通过add_wait_queue将epoll_entry挂载到目标文件的waitlist。</span><br><span class="line">        // 完成这个动作后，epoll_entry已经被挂载到waitlist</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">            add_wait_queue_exclusive(whead, &amp;pwq-&gt;<span class="built_in">wait</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add_wait_queue(whead, &amp;pwq-&gt;<span class="built_in">wait</span>);</span><br><span class="line">        // eppoll_entry-&gt;llink执行epitem-&gt;pwqlist</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /* We have to signal that an error occurred */</span><br><span class="line">        epi-&gt;nwait = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// include/linux/wait.h</span><br><span class="line">static inline void init_waitqueue_func_entry(struct wait_queue_entry *wq_entry,</span><br><span class="line">                                            wait_queue_func_t func)</span><br><span class="line">&#123;</span><br><span class="line">    wq_entry-&gt;flags        = 0;</span><br><span class="line">    wq_entry-&gt;private      = NULL;</span><br><span class="line">    wq_entry-&gt;func         = func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * This is the callback that is passed to the <span class="built_in">wait</span> queue wakeup</span><br><span class="line"> * mechanism. It is called by the stored file descriptors when they</span><br><span class="line"> * have events to report.</span><br><span class="line"> *</span><br><span class="line"> * This callback takes a <span class="built_in">read</span> lock <span class="keyword">in</span> order not to content with concurrent</span><br><span class="line"> * events from another file descriptors, thus all modifications to -&gt;rdllist</span><br><span class="line"> * or -&gt;ovflist are lockless.  Read lock is paired with the write lock from</span><br><span class="line"> * ep_scan_ready_list(), <span class="built_in">which</span> stops all list modifications and guarantees</span><br><span class="line"> * that lists state is seen correctly.</span><br><span class="line"> *</span><br><span class="line"> * Another thing worth to mention is that ep_poll_callback() can be called</span><br><span class="line"> * concurrently <span class="keyword">for</span> the same @epi from different CPUs <span class="keyword">if</span> poll table was inited</span><br><span class="line"> * with several <span class="built_in">wait</span> queues entries.  Plural wakeup from different CPUs of a</span><br><span class="line"> * single <span class="built_in">wait</span> queue is serialized by wq.lock, but the <span class="keyword">case</span> when multiple <span class="built_in">wait</span></span><br><span class="line"> * queues are used should be detected accordingly.  This is detected using</span><br><span class="line"> * cmpxchg() operation.</span><br><span class="line"> */</span><br><span class="line">static int ep_poll_callback(wait_queue_entry_t *<span class="built_in">wait</span>, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    struct epitem *epi = ep_item_from_wait(<span class="built_in">wait</span>);</span><br><span class="line">    struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line">    __poll_t pollflags = key_to_poll(key);</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    int ewake = 0;</span><br><span class="line">    </span><br><span class="line">    read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    </span><br><span class="line">    ep_set_busy_poll_napi_id(epi);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * If the event mask does not contain any poll(2) event, we consider the</span><br><span class="line">     * descriptor to be disabled. This condition is likely the effect of the</span><br><span class="line">     * EPOLLONESHOT bit that disables the descriptor when an event is received,</span><br><span class="line">     * until the next EPOLL_CTL_MOD will be issued.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        goto out_unlock;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * Check the events coming with the callback. At this stage, not</span><br><span class="line">     * every device reports the events <span class="keyword">in</span> the <span class="string">"key"</span> parameter of the</span><br><span class="line">     * callback. We need to be able to handle both cases here, hence the</span><br><span class="line">     * <span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"key"</span> != NULL before the event match <span class="built_in">test</span>.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        goto out_unlock;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * If we are transferring events to userspace, we can hold no locks</span><br><span class="line">     * (because we<span class="string">'re accessing user memory, and because of linux f_op-&gt;poll()</span></span><br><span class="line"><span class="string">     * semantics). All the events that happen during that period of time are</span></span><br><span class="line"><span class="string">     * chained in ep-&gt;ovflist and requeued later on.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    if (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span></span><br><span class="line"><span class="string">        // epi-&gt;next == EP_UNACTIVE_PTR说明rdllist当前被其他进程持有,</span></span><br><span class="line"><span class="string">        // 因此调用chain_epi_lockless把epitem放入vovflist上</span></span><br><span class="line"><span class="string">        if (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp; chain_epi_lockless(epi))</span></span><br><span class="line"><span class="string">            ep_pm_stay_awake_rcu(epi);</span></span><br><span class="line"><span class="string">        goto out_unlock;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // rdllist抢占成功,调用list_add_tail_lockless把epitem挂入rdllist上</span></span><br><span class="line"><span class="string">    /* If this file is already in the ready list we exit soon */</span></span><br><span class="line"><span class="string">    if (!ep_is_linked(epi) &amp;&amp; list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span></span><br><span class="line"><span class="string">        ep_pm_stay_awake_rcu(epi);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="string">     * wait list.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    if (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span></span><br><span class="line"><span class="string">        if ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span></span><br><span class="line"><span class="string">            !(pollflags &amp; POLLFREE)) &#123;</span></span><br><span class="line"><span class="string">            switch (pollflags &amp; EPOLLINOUT_BITS) &#123;</span></span><br><span class="line"><span class="string">                case EPOLLIN:</span></span><br><span class="line"><span class="string">                    if (epi-&gt;event.events &amp; EPOLLIN)</span></span><br><span class="line"><span class="string">                        ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                case EPOLLOUT:</span></span><br><span class="line"><span class="string">                    if (epi-&gt;event.events &amp; EPOLLOUT)</span></span><br><span class="line"><span class="string">                        ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                case 0:</span></span><br><span class="line"><span class="string">                    ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 同时唤醒eventpoll的wq等待队列,也就是唤醒poll_wait的调用者</span></span><br><span class="line"><span class="string">        wake_up(&amp;ep-&gt;wq);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (waitqueue_active(&amp;ep-&gt;poll_wait))</span></span><br><span class="line"><span class="string">        pwake++;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">out_unlock:</span></span><br><span class="line"><span class="string">    read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* We have to call this outside the lock */</span></span><br><span class="line"><span class="string">    if (pwake)</span></span><br><span class="line"><span class="string">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span></span><br><span class="line"><span class="string">        ewake = 1;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (pollflags &amp; POLLFREE) &#123;</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">         * If we race with ep_remove_wait_queue() it can miss</span></span><br><span class="line"><span class="string">         * -&gt;whead = NULL and do another remove_wait_queue() after</span></span><br><span class="line"><span class="string">         * us, so we can'</span>t use __remove_wait_queue().</span><br><span class="line">         */</span><br><span class="line">        list_del_init(&amp;<span class="built_in">wait</span>-&gt;entry);</span><br><span class="line">        /*</span><br><span class="line">         * -&gt;whead != NULL protects us from the race with ep_free()</span><br><span class="line">         * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span><br><span class="line">         * held by the <span class="built_in">caller</span>. Once we nullify it, nothing protects</span><br><span class="line">         * ep/epi or even <span class="built_in">wait</span>.</span><br><span class="line">         */</span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(<span class="built_in">wait</span>)-&gt;whead, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ep-item-poll-poll-wait-ep-scan-ready-list"><a href="#ep-item-poll-poll-wait-ep-scan-ready-list" class="headerlink" title="ep_item_poll/poll_wait/ep_scan_ready_list"></a>ep_item_poll/poll_wait/ep_scan_ready_list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Differs from ep_eventpoll_poll() <span class="keyword">in</span> that internal callers already have</span><br><span class="line"> * the ep-&gt;mtx so we need to start from depth=1, such that mutex_lock_nested()</span><br><span class="line"> * is correctly annotated.</span><br><span class="line"> */</span><br><span class="line">static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,int depth)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    bool locked;</span><br><span class="line"></span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">        <span class="built_in">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">    // 拿到eventpoll,回头过去看UML数据结构,private_data是指向eventpoll的</span><br><span class="line">    ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">    // 这里面会执行前面设置的ep_ptable_queue_proc回调体</span><br><span class="line">    // ep_ptable_queue_proc函数体的工作在前面已经介绍过</span><br><span class="line">    poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">    locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    // 把就绪链表rdllist拷贝到用户空间</span><br><span class="line">    <span class="built_in">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">                              ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">                              locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// include/linux/poll.h</span><br><span class="line">static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address,</span><br><span class="line">                             poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ep_scan_ready_list - Scans the ready list <span class="keyword">in</span> a way that makes possible <span class="keyword">for</span></span><br><span class="line"> *                      the scan code, to call f_op-&gt;poll(). Also allows <span class="keyword">for</span></span><br><span class="line"> *                      O(NumReady) performance.</span><br><span class="line"> *</span><br><span class="line"> * @ep: Pointer to the epoll private data structure.</span><br><span class="line"> * @sproc: Pointer to the scan callback.</span><br><span class="line"> * @priv: Private opaque data passed to the @sproc callback.</span><br><span class="line"> * @depth: The current depth of recursive f_op-&gt;poll calls.</span><br><span class="line"> * @ep_locked: <span class="built_in">caller</span> already holds ep-&gt;mtx</span><br><span class="line"> *</span><br><span class="line"> * Returns: The same <span class="built_in">integer</span> error code returned by the @sproc callback.</span><br><span class="line"> */</span><br><span class="line">static __poll_t ep_scan_ready_list(struct eventpoll *ep,</span><br><span class="line">                                   __poll_t (*sproc)(struct eventpoll *,</span><br><span class="line">                                   struct list_head *, void *),void *priv,</span><br><span class="line">                                   int depth, bool ep_locked)</span><br><span class="line">&#123;</span><br><span class="line">    __poll_t res;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    struct epitem *epi, *nepi;</span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We need to lock this because we could be hit by</span><br><span class="line">    * eventpoll_release_file() and epoll_ctl().</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_locked)</span><br><span class="line">        mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Steal the ready list, and re-init the original one to the</span><br><span class="line">    * empty list. Also, <span class="built_in">set</span> ep-&gt;ovflist to NULL so that events</span><br><span class="line">    * happening <span class="keyword">while</span> looping w/out locks, are not lost. We cannot</span><br><span class="line">    * have the poll callback to queue directly on ep-&gt;rdllist,</span><br><span class="line">    * because we want the <span class="string">"sproc"</span> callback to be able to <span class="keyword">do</span> it</span><br><span class="line">    * <span class="keyword">in</span> a lockless way.</span><br><span class="line">    */</span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    // 把就绪链表rdllist赋给临时的txlist,执行该操作后rdllist会被清空,</span><br><span class="line">    // 因为rdllist需要腾出来给其他进程继续往上放内容,</span><br><span class="line">    // 从而把txlist内epitem对应fd的就绪events复制到用户空间</span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    WRITE_ONCE(ep-&gt;ovflist, NULL);</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * sproc就是前面设置好的ep_poll_callback,事件到来了执行该回调体,</span><br><span class="line">    * sproc会把就绪的epitem放入rdllist或ovflist上</span><br><span class="line">    * Now call the callback <span class="keyword">function</span>.</span><br><span class="line">    */</span><br><span class="line">    res = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    /*</span><br><span class="line">    * During the time we spent inside the <span class="string">"sproc"</span> callback, some</span><br><span class="line">    * other events might have been queued by the poll callback.</span><br><span class="line">    * We re-insert them inside the main ready-list here.</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != NULL;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        /*</span><br><span class="line">        * We need to check <span class="keyword">if</span> the item is already <span class="keyword">in</span> the list.</span><br><span class="line">        * During the <span class="string">"sproc"</span> callback execution time, items are</span><br><span class="line">        * queued into -&gt;ovflist but the <span class="string">"txlist"</span> might already</span><br><span class="line">        * contain them, and the list_splice() below takes care of them.</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">            /*</span><br><span class="line">            * -&gt;ovflist is LIFO, so we have to reverse it <span class="keyword">in</span> order</span><br><span class="line">            * to keep <span class="keyword">in</span> FIFO.</span><br><span class="line">            */</span><br><span class="line">            list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">                ep_pm_stay_awake(epi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    * We need to <span class="built_in">set</span> back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span><br><span class="line">    * releasing the lock, events will be queued <span class="keyword">in</span> the normal way inside</span><br><span class="line">    * ep-&gt;rdllist.</span><br><span class="line">    */</span><br><span class="line">    WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * 把水平触发EPOLLLT属性的epitem依旧挂回到rdllist,</span><br><span class="line">    * 因为我们希望即使没有新的数据到来,只要数据还没被用户空间读完,就继续上报</span><br><span class="line">    * Quickly re-inject items left on <span class="string">"txlist"</span>.</span><br><span class="line">    */</span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">    __pm_relax(ep-&gt;ws);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        /*</span><br><span class="line">        * Wake up (<span class="keyword">if</span> active) both the eventpoll <span class="built_in">wait</span> list and</span><br><span class="line">        * the -&gt;poll() <span class="built_in">wait</span> list (delayed after we release the lock).</span><br><span class="line">        * wake_up唤醒epoll_wait的调用者</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_locked)</span><br><span class="line">        mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    /* We have to call this outside the lock */</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，epoll_ctl的分析就已经完了，这里只描述的EPOLL_CTL_ADD调用。EPOLL_CTL_MOD/EPOLL_CTL_DEL相对就简单很多，这三个操作差异主要体现在fs/eventpoll.c文件内接口SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,struct epoll_event __user*, event)的switch语句部分，EPOLL_CTL_MOD和EPOLL_CTL_DEL分别对应ep_modify和ep_remove，这两个函数就是从红黑树中去找到对应的节点进行修改和删除操作，因此这里没有贴代码。</p><h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><h3 id="epoll-wait陷入内核"><a href="#epoll-wait陷入内核" class="headerlink" title="epoll_wait陷入内核"></a>epoll_wait陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *,</span><br><span class="line">                events,int, maxevents, int, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_wait(epfd, events, maxevents, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-epoll-wait-ep-poll-ep-send-events-ep-send-events-proc"><a href="#do-epoll-wait-ep-poll-ep-send-events-ep-send-events-proc" class="headerlink" title="do_epoll_wait/ep_poll/ep_send_events/ep_send_events_proc"></a>do_epoll_wait/ep_poll/ep_send_events/ep_send_events_proc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Implement the event <span class="built_in">wait</span> interface <span class="keyword">for</span> the eventpoll file. It is the kernel</span><br><span class="line"> * part of the user space epoll_wait(2).</span><br><span class="line"> */</span><br><span class="line">static int do_epoll_wait(int epfd, struct epoll_event __user *events,</span><br><span class="line">                         int maxevents, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    // struct fd结构在数据结构部分代码已经列出</span><br><span class="line">    struct fd f;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* The maximum number of event must be greater than zero */</span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* Verify that the area passed by the user is writeable */</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(events, maxevents * sizeof(struct epoll_event)))</span><br><span class="line">        <span class="built_in">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    /* Get the <span class="string">"struct file *"</span> <span class="keyword">for</span> the eventpoll file */</span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="built_in">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check that the file structure underneath the fd</span><br><span class="line">    * the user passed to us _is_ an eventpoll file.</span><br><span class="line">    */</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(f.file))</span><br><span class="line">        goto error_fput;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * At this point it is safe to assume that the <span class="string">"private_data"</span> contains</span><br><span class="line">    * our own data structure.</span><br><span class="line">    * 直接拿到eventpoll对象</span><br><span class="line">    */</span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    // ep_poll时主循环体,当rdllist为空时调用者根据设置的超时参数,</span><br><span class="line">    // 决定是等待还是返回</span><br><span class="line">    /* Time to fish <span class="keyword">for</span> events ... */</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ep_poll - Retrieves ready events, and delivers them to the <span class="built_in">caller</span> supplied</span><br><span class="line"> *           event buffer.</span><br><span class="line"> *</span><br><span class="line"> * @ep: Pointer to the eventpoll context.</span><br><span class="line"> * @events: Pointer to the userspace buffer <span class="built_in">where</span> the ready events should be</span><br><span class="line"> *          stored.</span><br><span class="line"> * @maxevents: Size (<span class="keyword">in</span> terms of number of events) of the <span class="built_in">caller</span> event buffer.</span><br><span class="line"> * @timeout: Maximum timeout <span class="keyword">for</span> the ready events fetch operation, <span class="keyword">in</span></span><br><span class="line"> *           milliseconds. If the @timeout is zero, the <span class="keyword">function</span> will not block,</span><br><span class="line"> *           <span class="keyword">while</span> <span class="keyword">if</span> the @timeout is less than zero, the <span class="keyword">function</span> will block</span><br><span class="line"> *           until at least one event has been retrieved (or an error</span><br><span class="line"> *           occurred).</span><br><span class="line"> *</span><br><span class="line"> * Returns: Returns the number of ready events <span class="built_in">which</span> have been fetched, or an</span><br><span class="line"> *          error code, <span class="keyword">in</span> <span class="keyword">case</span> of error.</span><br><span class="line"> */</span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span><br><span class="line">                   int maxevents, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, eavail, timed_out = 0;</span><br><span class="line">    u64 slack = 0;</span><br><span class="line">    bool waiter = <span class="literal">false</span>;</span><br><span class="line">    wait_queue_entry_t <span class="built_in">wait</span>;</span><br><span class="line">    ktime_t expires, *to = NULL;</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    // 超时设置</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; 0) &#123;</span><br><span class="line">        struct timespec64 end_time = ep_set_mstimeout(timeout);</span><br><span class="line"></span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">        to = &amp;expires;</span><br><span class="line">        *to = timespec64_to_ktime(end_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == 0) &#123; // 立即返回</span><br><span class="line">        /*</span><br><span class="line">        * Avoid the unnecessary trip to the <span class="built_in">wait</span> queue loop, <span class="keyword">if</span> the</span><br><span class="line">        * <span class="built_in">caller</span> specified a non blocking operation. We still need</span><br><span class="line">        * lock because we could race and not see an epi being added</span><br><span class="line">        * to the ready list <span class="keyword">while</span> <span class="keyword">in</span> irq callback. Thus incorrectly</span><br><span class="line">        * returning 0 back to userspace.</span><br><span class="line">        */</span><br><span class="line">        timed_out = 1;</span><br><span class="line"></span><br><span class="line">        write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        eavail = ep_events_available(ep);</span><br><span class="line">        write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">        goto send_events;</span><br><span class="line">    &#125;// 否则是永久等待,直到有新的事件到来</span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep))</span><br><span class="line">        ep_busy_loop(ep, timed_out);</span><br><span class="line"></span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line">    <span class="keyword">if</span> (eavail)</span><br><span class="line">        goto send_events;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Busy poll timed out.  Drop NAPI ID <span class="keyword">for</span> now, we can add</span><br><span class="line">    * it back <span class="keyword">in</span> when we have moved a socket with a valid NAPI</span><br><span class="line">    * ID onto the ready list.</span><br><span class="line">    */</span><br><span class="line">    ep_reset_busy_poll_napi_id(ep);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We don<span class="string">'t have any available event to return to the caller.  We need</span></span><br><span class="line"><span class="string">    * to sleep here, and we will be woken by ep_poll_callback() when events</span></span><br><span class="line"><span class="string">    * become available.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    if (!waiter) &#123;</span></span><br><span class="line"><span class="string">        waiter = true;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        // ep-&gt;rdllist存放的是已就绪(read)的fd，为空时说明当前没有就绪的fd,</span></span><br><span class="line"><span class="string">        // 创建一个等待队列,并使用当前进程（current）初始化</span></span><br><span class="line"><span class="string">        init_waitqueue_entry(&amp;wait, current);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">        // 将当前进程添加到等待队列</span></span><br><span class="line"><span class="string">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span></span><br><span class="line"><span class="string">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for (;;) &#123;</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">        * We don'</span>t want to sleep <span class="keyword">if</span> the ep_poll_callback() sends us</span><br><span class="line">        * a wakeup <span class="keyword">in</span> between. That<span class="string">'s why we set the task state</span></span><br><span class="line"><span class="string">        * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="string">        */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        set_current_state(TASK_INTERRUPTIBLE);</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">        * Always short-circuit for fatal signals to allow</span></span><br><span class="line"><span class="string">        * threads to make a timely exit without the chance of</span></span><br><span class="line"><span class="string">        * finding more events available and fetching</span></span><br><span class="line"><span class="string">        * repeatedly.</span></span><br><span class="line"><span class="string">        */</span></span><br><span class="line"><span class="string">        if (fatal_signal_pending(current)) &#123;</span></span><br><span class="line"><span class="string">            res = -EINTR;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // ep_events_available内部会判断rdllist是否为空</span></span><br><span class="line"><span class="string">        eavail = ep_events_available(ep);</span></span><br><span class="line"><span class="string">        if (eavail)</span></span><br><span class="line"><span class="string">            break; // 循环体,如果rdllist不为空,则跳出循环体,进入send_events</span></span><br><span class="line"><span class="string">        if (signal_pending(current)) &#123;</span></span><br><span class="line"><span class="string">            res = -EINTR;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span></span><br><span class="line"><span class="string">            timed_out = 1;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __set_current_state(TASK_RUNNING);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">send_events:</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="string">    * there'</span>s still timeout left over, we go trying again <span class="keyword">in</span> search of</span><br><span class="line">    * more luck.</span><br><span class="line">    * ep_send_events接口复制txlist内epitem对应fd的就绪events到用户空间</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp; !(res = ep_send_events(ep, events, maxevents))</span><br><span class="line">        &amp;&amp; !timed_out)</span><br><span class="line">        goto fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waiter) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        // 将当前进程移出等待队列</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;<span class="built_in">wait</span>);</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs/eventpoll.c</span><br><span class="line">static int ep_send_events(struct eventpoll *ep,</span><br><span class="line">                          struct epoll_event __user *events, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    struct ep_send_events_data esed;</span><br><span class="line"></span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line"></span><br><span class="line">    // 传入ep_send_events_proc</span><br><span class="line">    ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">return</span> esed.res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实际执行复制到用户空间的工作是由该函数体负责</span><br><span class="line">static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head,void *priv)</span><br><span class="line">&#123;</span><br><span class="line">    struct ep_send_events_data *esed = priv;</span><br><span class="line">    __poll_t revents;</span><br><span class="line">    struct epitem *epi, *tmp;</span><br><span class="line">    struct epoll_event __user *uevent = esed-&gt;events;</span><br><span class="line">    struct wakeup_source *ws;</span><br><span class="line">    poll_table pt;</span><br><span class="line"></span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);</span><br><span class="line">    esed-&gt;res = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We can loop without lock because we are passed a task private list.</span><br><span class="line">    * Items cannot vanish during the loop because ep_scan_ready_list() is</span><br><span class="line">    * holding <span class="string">"mtx"</span> during this call.</span><br><span class="line">    */</span><br><span class="line">    lockdep_assert_held(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    // lambda表达式</span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">        <span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent</span><br><span class="line">        * triggering auto-suspend here (<span class="keyword">in</span> <span class="keyword">case</span> we reactive epi-&gt;ws</span><br><span class="line">        * below).</span><br><span class="line">        *</span><br><span class="line">        * This could be rearranged to delay the deactivation of epi-&gt;ws</span><br><span class="line">        * instead, but <span class="keyword">then</span> epi-&gt;ws would temporarily be out of sync</span><br><span class="line">        * with ep_is_linked().</span><br><span class="line">        */</span><br><span class="line">        ws = ep_wakeup_source(epi);</span><br><span class="line">        <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">                __pm_stay_awake(ep-&gt;ws);</span><br><span class="line">            __pm_relax(ws);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        * If the event mask intersect the <span class="built_in">caller</span>-requested one,</span><br><span class="line">        * deliver the event to userspace. Again, ep_scan_ready_list()</span><br><span class="line">        * is holding ep-&gt;mtx, so no operations coming from userspace</span><br><span class="line">        * can change the item.</span><br><span class="line">        */</span><br><span class="line">        revents = ep_item_poll(epi, &amp;pt, 1);</span><br><span class="line">        <span class="keyword">if</span> (!revents)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">        // 复制到用户空间</span><br><span class="line">        <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">            __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">            list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">            ep_pm_stay_awake(epi);</span><br><span class="line">            <span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">                esed-&gt;res = -EFAULT;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        esed-&gt;res++;</span><br><span class="line">        uevent++;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">            epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">            /*</span><br><span class="line">            * If this file has been added with Level</span><br><span class="line">            * Trigger mode, we need to insert back inside</span><br><span class="line">            * the ready list, so that the next call to</span><br><span class="line">            * epoll_wait() will check again the events</span><br><span class="line">            * availability. At this point, no one can insert</span><br><span class="line">            * into ep-&gt;rdllist besides us. The epoll_ctl()</span><br><span class="line">            * callers are locked out by</span><br><span class="line">            * ep_scan_ready_list() holding <span class="string">"mtx"</span> and the</span><br><span class="line">            * poll callback will queue them <span class="keyword">in</span> ep-&gt;ovflist.</span><br><span class="line">            */</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            ep_pm_stay_awake(epi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/rankun1/article/details/69938640" rel="external nofollow noopener noreferrer" target="_blank">epoll react</a><br>[2] <a href="https://blog.csdn.net/zhaobryant/article/details/80557262" rel="external nofollow noopener noreferrer" target="_blank">linux epoll源码分析</a><br>[3] <a href="https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">IO复用select/poll/epoll</a><br>[4] <a href="https://www.cnblogs.com/Anker/p/3263780.html" rel="external nofollow noopener noreferrer" target="_blank">IO复用epoll</a><br>[5] <a href="https://www.linuxidc.com/Linux/2019-02/157109.htm" rel="external nofollow noopener noreferrer" target="_blank">linux epoll源码</a><br>[6] <a href="http://blog.chinaunix.net/uid-28541347-id-4238524.html" rel="external nofollow noopener noreferrer" target="_blank">linux poll/epoll实现</a><br>[7] <a href="https://github.com/torvalds/linux" rel="external nofollow noopener noreferrer" target="_blank">linux源码github仓库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;p&gt;epoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内
      
    
    </summary>
    
      <category term="IO多路复用模型" scheme="https://icoty.github.io/categories/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="UML" scheme="https://icoty.github.io/categories/UML/"/>
    
      <category term="linux源码" scheme="https://icoty.github.io/categories/linux%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="epoll" scheme="https://icoty.github.io/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>基于线程池、消息队列和epoll模型实现并发服务器架构</title>
    <link href="https://icoty.github.io/2019/05/25/cs-threadpool-message-queue/"/>
    <id>https://icoty.github.io/2019/05/25/cs-threadpool-message-queue/</id>
    <published>2019-05-25T08:16:55.000Z</published>
    <updated>2019-06-10T10:17:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>并发是什么？企业在进行产品开发过程中为什么需要考虑这个问题？想象一下天猫的双11和京东的618活动，一秒的点击量就有几十万甚至上百万，这么多请求一下子涌入到服务器，服务器需要对这么多的请求逐个进行消化掉，假如服务器一秒的处理能力就几万，那么剩下的不能及时得到处理的这些请求作何处理？总不能让用户界面一直等着，因此消息队列应运而生，所有的请求都统一放入消息队列，工作线程从消息队列不断的消费，消息队列相当于一个缓冲区，可达到解藕、异步和削峰的目的。</p><p>Kafka、ActiveMQ、RabbitMQ和RockerMQ都是消息队列的典型，每一种都有其自身的优势和劣势。本文我用自己编写的Buffer类模拟消息队列，如果是企业级需要上线的应用，一般都是基于业界已有的MQ框架上开发。</p><h2 id="需求原型"><a href="#需求原型" class="headerlink" title="需求原型"></a>需求原型</h2><ol><li>N个Client从标准输入接收数据，然后连续不断的发送到Server端；</li><li>Server端接收来自每个Client的数据，将数据中的小写字母全部转换成大写字母，其他字符保持不变，最后把转换结果发送给对应的Client。</li></ol><h2 id="需求分解"><a href="#需求分解" class="headerlink" title="需求分解"></a>需求分解</h2><ol><li>拿到需求，第一步要做的就是分析需求并选择合适的设计架构，考虑到Server需要和Client进行通信，Client来自四面八方，端对端通信自然选择TCP，因此Server端需要能够监听新的连接请求和已有连接的业务请求；</li><li>又由于Server需要响应多个Client的业务请求，我们希望把业务处理交给Server端的工作线程（消费者）来做；</li><li>同时还需要一个IO线程负责监听Socket描述符，当IO线程监听到已有连接的业务请求时，立即把请求内容封装成一个任务推入消息队列尾；</li><li>IO线程与工作线程互斥访问消息队列，当然工作线程消费一个任务或者IO线程添加一个任务都需要通知对方，也就是同步；</li><li>工作线程处理完毕后，把处理结果交给IO线程，由IO线程负责把结果发送给对应的Client，也就是IO线程与工作线程的分离，这里工作线程通知IO线程的方式我用eventfd来实现；</li><li>我们希望引入Log4cpp记录服务端的日志，并能够保存到文件中；</li><li>分析完这些，一个整体架构和大体的样子在脑海中就已经形成了，接着就需要编写设计文档和画流程图、类图和时序图了。</li></ol><h2 id="详细设计文档"><a href="#详细设计文档" class="headerlink" title="详细设计文档"></a>详细设计文档</h2><ol><li>UML静态类图：</li></ol><p><img src="/2019/05/25/cs-threadpool-message-queue/cs-uml" alt="cmd"></p><ol start="2"><li>UML动态时序图：</li></ol><p><img src="/2019/05/25/cs-threadpool-message-queue/cs-sequence" alt="cmd"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li>如图，开了三个Client，运行结果正确：</li></ol><p><img src="/2019/05/25/cs-threadpool-message-queue/cs-ret.png" alt="cmd"></p><ol start="2"><li>Server端通过Log4cpp把日志写到文件中：</li></ol><p><img src="/2019/05/25/cs-threadpool-message-queue/cs-log.png" alt="cmd"></p><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p><a href="https://github.com/icoty/cs_threadpool_epoll_mq" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/icoty/cs_threadpool_epoll_mq</a></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── client // 客户端Demo</span><br><span class="line">│   ├── Client.cc</span><br><span class="line">│   ├── Client.exe</span><br><span class="line">│   ├── client.sh // 进入该目录下启动Client Demo: sh client.sh</span><br><span class="line">│   ├── Log4func.cc // 引入日志模块重新疯转</span><br><span class="line">│   ├── Log4func.h</span><br><span class="line">│   └── Makefile // 编译方式：make</span><br><span class="line">├── conf</span><br><span class="line">│   └── my.conf // IP,Port配置文件, 从这里进行修改</span><br><span class="line">├── include // 头文件</span><br><span class="line">│   ├── Configuration.hpp // 配置文件,单例类,my.conf的内存化</span><br><span class="line">│   ├── FileName.hpp // 全局定义,Configuration会用到</span><br><span class="line">│   ├── <span class="built_in">log</span> // 日志模块头文件</span><br><span class="line">│   │   └── Log4func.hpp</span><br><span class="line">│   ├── net // 网络框架模块头文件</span><br><span class="line">│   │   ├── EpollPoller.hpp</span><br><span class="line">│   │   ├── InetAddress.hpp</span><br><span class="line">│   │   ├── Socket.hpp</span><br><span class="line">│   │   ├── SockIO.hpp</span><br><span class="line">│   │   ├── TcpConnection.hpp</span><br><span class="line">│   │   └── TcpServer.hpp</span><br><span class="line">│   ├── String2Upper.hpp // 工作线程转换成大写实际走的这里面的接口</span><br><span class="line">│   ├── String2UpperServer.hpp // Server端的整个工厂</span><br><span class="line">│   └── threadpool // 线程池、锁、条件变量和消息队列的封装</span><br><span class="line">│       ├── Buffer.hpp</span><br><span class="line">│       ├── Condition.hpp</span><br><span class="line">│       ├── MutexLock.hpp</span><br><span class="line">│       ├── Noncopyable.hpp</span><br><span class="line">│       ├── Pthread.hpp</span><br><span class="line">│       ├── Task.hpp</span><br><span class="line">│       └── Threadpool.hpp</span><br><span class="line">├── <span class="built_in">log</span> // Server端的日志通过Log4cpp记录到这个文件中</span><br><span class="line">│   └── log4test.log</span><br><span class="line">├── Makefile // 编译方式：make</span><br><span class="line">├── README.md </span><br><span class="line">├── server // server端Demo</span><br><span class="line">│   ├── server.exe</span><br><span class="line">│   └── server.sh // 进入该目录下启动Server Demo：sh server.sh</span><br><span class="line">└── src // 源文件</span><br><span class="line">    ├── Configuration.cpp</span><br><span class="line">    ├── <span class="built_in">log</span></span><br><span class="line">    │   └── Log4func.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── net</span><br><span class="line">    │   ├── EpollPoller.cpp</span><br><span class="line">    │   ├── InetAddress.cpp</span><br><span class="line">    │   ├── Socket.cpp</span><br><span class="line">    │   ├── SockIO.cpp</span><br><span class="line">    │   ├── TcpConnection.cpp</span><br><span class="line">    │   └── TcpServer.cpp</span><br><span class="line">    ├── String2Upper.cpp</span><br><span class="line">    ├── String2UpperServer.cpp</span><br><span class="line">    └── threadpool</span><br><span class="line">    ├── Buffer.cpp</span><br><span class="line">    ├── Condition.cpp</span><br><span class="line">    ├── MutexLock.cpp // MutexLockGuard封装</span><br><span class="line">    ├── Pthread.cpp</span><br><span class="line">    └── Threadpool.cpp</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] UNIX环境高级编程第3版<br>[2] <a href="https://en.cppreference.com/w/" rel="external nofollow noopener noreferrer" target="_blank">cpp reference</a><br>[3] <a href="https://www.cnblogs.com/downey/p/4890830.html" rel="external nofollow noopener noreferrer" target="_blank">UML时序图</a><br>[4] <a href="https://sourceforge.net/projects/log4cpp/" rel="external nofollow noopener noreferrer" target="_blank">Log4cpp官网下载</a><br>[5] <a href="https://blog.csdn.net/sinat_26003209/article/details/46522953" rel="external nofollow noopener noreferrer" target="_blank">Log4cpp安装</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;并发是什么？企业在进行产品开发过程中为什么需要考虑这个问题？想象一下天猫的双11和京东的618活动，一秒的点击量就有几十万甚至上百万，这么多
      
    
    </summary>
    
      <category term="IO多路复用模型" scheme="https://icoty.github.io/categories/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="同步机制" scheme="https://icoty.github.io/categories/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="并发服务器架构" scheme="https://icoty.github.io/categories/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    
      <category term="互斥机制" scheme="https://icoty.github.io/categories/%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="TCP" scheme="https://icoty.github.io/categories/TCP/"/>
    
      <category term="线程池" scheme="https://icoty.github.io/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="UML" scheme="https://icoty.github.io/categories/UML/"/>
    
      <category term="C++" scheme="https://icoty.github.io/categories/C/"/>
    
      <category term="IPC" scheme="https://icoty.github.io/categories/IPC/"/>
    
    
      <category term="eventfd" scheme="https://icoty.github.io/tags/eventfd/"/>
    
      <category term="STL" scheme="https://icoty.github.io/tags/STL/"/>
    
      <category term="线程池" scheme="https://icoty.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="TCP/Socket编程" scheme="https://icoty.github.io/tags/TCP-Socket%E7%BC%96%E7%A8%8B/"/>
    
      <category term="消息队列" scheme="https://icoty.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="条件变量" scheme="https://icoty.github.io/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    
      <category term="锁" scheme="https://icoty.github.io/tags/%E9%94%81/"/>
    
      <category term="面向对象编程" scheme="https://icoty.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
      <category term="单例模式" scheme="https://icoty.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="epoll" scheme="https://icoty.github.io/tags/epoll/"/>
    
      <category term="Log4cpp" scheme="https://icoty.github.io/tags/Log4cpp/"/>
    
      <category term="Makefile" scheme="https://icoty.github.io/tags/Makefile/"/>
    
      <category term="智能指针" scheme="https://icoty.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="UML" scheme="https://icoty.github.io/tags/UML/"/>
    
      <category term="C++" scheme="https://icoty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo引入Mermaid流程图和MathJax数学公式</title>
    <link href="https://icoty.github.io/2019/05/23/markdown-mermaid-mathjax/"/>
    <id>https://icoty.github.io/2019/05/23/markdown-mermaid-mathjax/</id>
    <published>2019-05-23T00:30:10.000Z</published>
    <updated>2019-06-09T06:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来用Markdown写文章，越来越不喜欢插入图片了，一切能用语法解决的问题坚决不放图，原因有二：</p><ol><li><p>如果把流程图和数学公式都以图片方式放到文章内，当部署到Github上后，访问博客时图片加载实在太慢，有时一篇文章需要画10来个流程图，那你就得截图10来多次，还得给这些图片想一个合适的名字，同时插入图片的时候还要注意图片的插入位置和顺序；</p></li><li><p>如果你要把文章发布到其他博客平台，如CSDN、博客园，在每一个平台上你都要插入10来多次图片，作为程序员，这种笨拙又耗时的方法，我实在不能忍。</p></li></ol><p>于是愤而搜索，<a href="https://github.com/knsv/mermaid" rel="external nofollow noopener noreferrer" target="_blank">Mermaid语法</a>可实现流程图功能，<a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044%20MathJax%20basic%20tutorial%20and%20quick%20reference" rel="external nofollow noopener noreferrer" target="_blank">MathJax语法</a>可实现数学公式和特殊符号的功能，只需要遵循其语法规则即可，这也不由得让我想起：“苏乞儿打完降龙十八掌前17掌之后幡然领悟出第18掌的奥妙时说的那句话：我实在是太聪明了！”。下面都以next主题为例，我的主题是<a href="https://github.com/theme-next/hexo-theme-next" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/theme-next/hexo-theme-next</a></p><h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><ol><li>如果你用的主题和我的主题仓库是同一个，你只需修改blog/themes/next/_config.yml内mermaid模块enable为true，其他的啥也不用做。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> blog/  <span class="comment"># 走到博客根目录</span></span><br><span class="line"><span class="variable">$yarn</span> add hexo-filter-mermaid-diagrams  <span class="comment"># 安装mermaid插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line">mermaid:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  theme: forest</span><br><span class="line">  cdn: //cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js</span><br><span class="line">  <span class="comment">#cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果你的不是next主题或者你的next主题是github上旧版本仓库，你首先需要查看themes/next/_config.yml内是否有mermaid模块，如果有，按照前面的方法1，执行完方法1后，如果不奏效，不要改回去，接着下面的内容继续配置。如果没有mermaid模块，仍然着接下面内容继续配置。</li></ol><ul><li><p>编辑博客根目录下的blog/_config.yml，在最后添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line">mermaid: <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  version: <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  options:  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure></li><li><p>编辑blog/themes/next/layout/_partials/footer.swig，在最后添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script src=<span class="string">'https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果你的主题下没有footer.swig文件，你需要在你的主题目录下搜索文件名为after-footer.ejs和after_footer.pug的文件，根据文件名的不同在其最后添加不同的内容，这点在github上的 <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" rel="external nofollow noopener noreferrer" target="_blank">hexo-filter-mermaid-diagrams</a> 教程已经明确交代了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若是after_footer.pug，在最后添加内容</span></span><br><span class="line"><span class="keyword">if</span> theme.mermaid.enable == <span class="literal">true</span></span><br><span class="line">  script(<span class="built_in">type</span>=<span class="string">'text/javascript'</span>, id=<span class="string">'maid-script'</span> mermaidoptioins=theme.mermaid.options src=<span class="string">'https://unpkg.com/mermaid@'</span>+ theme.mermaid.version + <span class="string">'/dist/mermaid.min.js'</span> + <span class="string">'?v='</span> + theme.version)</span><br><span class="line">  script.</span><br><span class="line">    <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">      var options = JSON.parse(document.getElementById(<span class="string">'maid-script'</span>).getAttribute(<span class="string">'mermaidoptioins'</span>));</span><br><span class="line">      mermaid.initialize(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是after-footer.ejs，在最后添加</span></span><br><span class="line">&lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=<span class="string">'https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: <span class="string">'forest'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><ul><li>最后，赶紧部署到github上观看效果吧，如果不奏效的话，把blog/_config.yml中的external_link设置为false和设置为true都试下，这点在github教程上也已经交代了，因为我的next版本不涉及这个问题，请君多试。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!!Notice: <span class="keyword">if</span> you want to use <span class="string">'Class diagram'</span>, please edit your <span class="string">'_config.yml'</span> file, <span class="built_in">set</span> external_link: <span class="literal">false</span>. - hexo bug.</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>前两步做完后，如果都不奏效，这里还有一招绝杀技，那就是打开blog/public目录下你写的文章的index.html。</li></ol><ul><li><p>搜索“mermaid”，所有的流程图都应该是括在一个标签类的，如果你的流程图没有class = “mermaid”，那就是第一步安装的hexo-filter-mermaid-diagrams插件没有解析成功，可能是hexo，node，yarn版本问题所致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 流程图解析为：&lt;pre class="mermaid"&gt;流程图&lt;/pre&gt;</span></span><br><span class="line">&lt;pre class=<span class="string">"mermaid"</span>&gt;graph LR</span><br><span class="line">A[Bob&lt;br&gt;输入明文P] --&gt;|P|B[<span class="string">"Bob的私钥PRbob&lt;br&gt;加密算法(如RSA)&lt;br&gt;C=E(PRbob,P)"</span>];</span><br><span class="line">B --&gt;|传输数字签名C|C[<span class="string">"Alice的公钥环&#123;PUbob,……&#125;&lt;br&gt;解密算法(如RSA)&lt;br&gt;P=D(PUbob,C)"</span>];</span><br><span class="line">C --&gt;|P|D[<span class="string">"Alice&lt;br&gt;输出明文P"</span>];&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li><li><p>若流程图确实解析成功了，但是web仍然不显示流程图，说明js文件引入失败，继续在index.html中搜索“mermaid.min.js”，正常情况下需要有如下内容，如果没有，在文件最后的”body”之前添加上，之后再部署观看效果，到此理论上应该可以了，如果还是不行，仔细检查下有没有遗漏步骤，考验你解bug的时候到了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">if</span> (window.mermaid) &#123;</span><br><span class="line">    mermaid.initialize(&#123;theme: <span class="string">'forest'</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p>我的主题只需修改blog/themes/next/_config.yml内math模块enable为true即可，不需要安装任何插件，修改之后，在文章的Front Matter栏添加”mathjax: true”才能解析，其他主题也可以试下该方法可行否，都大同小异。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Math Equations Render Support</span></span><br><span class="line">math:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># 这里改为true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front Matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  per_page: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  <span class="comment">#engine: katex</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support.</span></span><br><span class="line">  mathjax:</span><br><span class="line">    cdn: //cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br><span class="line">    <span class="comment">#cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="comment">#mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span><br><span class="line">    <span class="comment">#mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) needed to full Katex support.</span></span><br><span class="line">  katex:</span><br><span class="line">    cdn: //cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css</span><br><span class="line">    <span class="comment">#cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css</span></span><br><span class="line"></span><br><span class="line">    copy_tex:</span><br><span class="line">      <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">      <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">      copy_tex_js: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js</span><br><span class="line">      copy_tex_css: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章引入方式</span></span><br><span class="line">---</span><br><span class="line">title: 常用加密算法的应用</span><br><span class="line">date: 2019-05-20 13:58:36</span><br><span class="line">tags: [对称加密算法,非对称加密算法/公钥算法,Hash函数/散列函数/摘要函数,消息认证,流密码,数字签名/指纹/消息摘要]</span><br><span class="line">categories:</span><br><span class="line">  - [密码学与信息安全]</span><br><span class="line">copyright: <span class="literal">true</span></span><br><span class="line">mathjax: <span class="literal">true</span>  <span class="comment"># 添加这行，文章才会解析</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044%20MathJax%20basic%20tutorial%20and%20quick%20reference" rel="external nofollow noopener noreferrer" target="_blank">MathJax语法规则</a><br><a href="https://www.jianshu.com/p/7ddbb7dc8fec" rel="external nofollow noopener noreferrer" target="_blank">Mermaid语法规则</a><br><a href="https://mermaidjs.github.io/demos.html" rel="external nofollow noopener noreferrer" target="_blank">Mermaid官方教程</a><br><a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" rel="external nofollow noopener noreferrer" target="_blank">Mermaid Github仓库</a><br><a href="https://github.com/mathjax/MathJax" rel="external nofollow noopener noreferrer" target="_blank">MathJax Github仓库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近来用Markdown写文章，越来越不喜欢插入图片了，一切能用语法解决的问题坚决不放图，原因有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果把流程图和数学公式都以图片方式放到文章内，当部署到Github上后，访问博客时图片加载实在太慢，有时一篇文章需要画10来个流程图，那你就得
      
    
    </summary>
    
      <category term="Hexo" scheme="https://icoty.github.io/categories/Hexo/"/>
    
    
      <category term="Mermaid" scheme="https://icoty.github.io/tags/Mermaid/"/>
    
      <category term="MathJax" scheme="https://icoty.github.io/tags/MathJax/"/>
    
      <category term="MarkDown" scheme="https://icoty.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>常用加密算法的应用</title>
    <link href="https://icoty.github.io/2019/05/20/crypt/"/>
    <id>https://icoty.github.io/2019/05/20/crypt/</id>
    <published>2019-05-20T13:58:36.000Z</published>
    <updated>2019-05-23T06:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>实际工作和开发过程中，网络通信过程中的数据传输和存储大多需要经过严格的加解密设计，比如用户的登陆与注册，敏感信息传输，支付网站和银行的交易信息，甚至为了防止被拖库，数据库的敏感信息存储也需要经过精心的设计。在进行安全设计过程中，或多或少涉及到密码学的一些概念，比如对称加密算法，非对称加密算法(也名公钥算法)，消息认证，Hash函数(也名散列函数或摘要算法)，数字签名(也名指纹或摘要)，流密码等。</p><p>一直以来，对于这些概念，你是否有一种模棱两可，似懂非懂的感觉？下面咱们一起揭开密码学这层神秘的面纱。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h4><p>密码体制是满足以下5个条件的五元组(P, C, K, E, D)，满足条件: </p><ol><li><p>P(Plaintext)是可能明文的有限集(明文空间); </p></li><li><p>C(Ciphertext)是可能密文的有限集(密文空间); </p></li><li><p>K(Key)是一切可能密钥构成的有限集(密钥空间);</p></li><li><p>E(Encrtption)和D(Decryption)是分别由密钥决定的所有加密算法和解密算法的集合;</p></li><li><p>存在：</p><p> $k \in K$ ,有加密算法 $e_k:P \rightarrow C$ , $e_k \in E$；同时有由 $ {k_1} \in K$ 决定的解密算法 $d_{k_1} : C \rightarrow P，d_{k_1} \in D$；满足关系 $d_{k_1} (e_k(x)) = x, x \in P$。</p></li></ol><h4 id="密码破译"><a href="#密码破译" class="headerlink" title="密码破译"></a>密码破译</h4><p>密码破译根本目的在于破译出密钥或密文，假设破译者Oscar是在已知密码体制的前提下来破译Bob使用的密钥。这个假设被称为Kerckhoff准则，最常见的破解类型有如下5种，从1～5，Oscar的破译难度逐渐降低。</p><ol><li>唯密文攻击：Oscar仅具有密文串c，Oscar只能通过统计特性分析密文串p的规律；</li><li>已知明文攻击：Oscar具有一些明文串p和相应的密文c，{p，c}可以是{P，C}的任意非空子集；</li><li>选择明文攻击：Oscar可获得对加密机的暂时访问，因此他能选择特定明文串p并构造出相应的密文串c；</li><li>选择密文攻击：Oscar可暂时接近解密机，因此他能选择特定密文串c并构造出相应的明文串p。</li><li>选择文本攻击：Oscar可以制造任意明文(p) / 密文(c)并得到对应的密文(c) / 明文(p)。</li></ol><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p>对称加密算法的加密密钥和解密密钥相同，常见的对称加密算法有：AES、DES、2DES、3DES、RC4、RC5、RC6，Blowfish和IDEA，目前使用最广泛的是DES、AES。</p><pre class="mermaid">graph LRA[发送方Bob<br>输入明文P] -->|P|B["发送方Bob与接收方Alice<br>共用相同密钥K<br>加密算法(如DES)<br>C=E(K,P)"];B -->|传输密文C|C["接收方Alice与发送方Bob<br>共用相同密钥K<br>解密算法(如DES)<br>P=D(K,C)"];C -->|P|D["Alice接收方<br>输出明文P"];</pre><h4 id="非对称加密算法-公钥算法"><a href="#非对称加密算法-公钥算法" class="headerlink" title="非对称加密算法(公钥算法)"></a>非对称加密算法(公钥算法)</h4><p>公钥算法的加密算法和解密算法使用不同的密钥，分别为公钥和私钥，这两个密钥中的任何一个都可以用来加密，而另一个用来解密。常见的公钥算法有：椭圆曲线(ECC)、RSA、Diffie-Hellman、El Gamal(安全性建立在基于求解离散对数是困难的)、DSA(适用于数字签名)。</p><h5 id="公钥算法的应用"><a href="#公钥算法的应用" class="headerlink" title="公钥算法的应用"></a>公钥算法的应用</h5><ol><li>发送方Bob用接收方Alice的公钥对消息进行加密，接收方Alice用自己的私钥进行解密，可提供消息传输过程中的保密性。</li></ol><pre class="mermaid">graph LRA[Bob<br>输入明文P] -->|P|B["Bob的公钥环{PUalice,……}<br>加密算法<br>C=E(PUalice,P)"];B -->|传输密文C|C["Alice私钥PRalice<br>解密算法<br>P=D(PRalice,C)"];C -->|P|D["Alice<br>输出明文P"];</pre><ol start="2"><li>发送方Bob采用自己的私钥对明文进行加密，虽然任何持有Bob公钥的人都能够解密，但是只有拥有Bob私钥的人才能产生密文C，而Bob的私钥只有自己知道，因此密文C也叫做数字签名，数字签名C可用于认证源和数据的完整性。</li></ol><pre class="mermaid">graph LRA[Bob<br>输入明文P] -->|P|B["Bob的私钥PRbob<br>加密算法(如RSA)<br>C=E(PRbob,P)"];B -->|传输数字签名C|C["Alice的公钥环{PUbob,……}<br>解密算法(如RSA)<br>P=D(PUbob,C)"];C -->|P|D["Alice<br>输出明文P"];</pre><ol start="3"><li>发送方Bob首先采用自己的私钥对明文进行加密，然后使用接收方Alice的公钥再进行一次加密后传输，则既可提供认证功能，又可提供消息传输过程中的保密性。</li></ol><pre class="mermaid">graph LRA[Bob<br>输入明文P] -->|P|B["Bob的私钥PRbob<br>加密算法(如RSA)<br>C=E(PRbob,P)"];B -->|数字签名C|C["Bob的公钥环{PUalice,……}<br>加密算法(如RSA)<br>C1=E(PUalice,C)"];C -->|传输密文C1|D["Alice的私钥PRalice<br>解密算法(如RSA)<br>C=D(PRalice,C1)"];D -->|数字签名C|E["Alice的公钥环{PUbob,……}<br>解密算法(如RSA)<br>P=D(PUbob,C)"];E -->|P|F["Alice<br>输出明文P"];</pre><ol start="4"><li>发送方Bob用接收方Alic的公钥对自己的私钥进行加密，然后发送给Alice，Alic用自己的私钥解密即可得到发送方Bob的私钥，从而实现密钥交换功能。</li></ol><pre class="mermaid">graph LRA[Bob的私钥<br>PRbob] -->|Bob的私钥PRbob|B["Bob的公钥环{PUalice,……}<br>加密算法(如RSA)<br>C=E(PUalice,PRbob)"];B -->|传输密文C|C["Alice的私钥PRalice<br>解密算法(如RSA)<br>PRbob=D(PRalice,C)"];C -->|PRbob|D["Alice<br>Bob的私钥PRbob"];</pre><p>另外需要说明一下，Diffie-Hellman的密钥交换算法与此方法不同，如果你学过密码学，应该清楚其中的差异。并且并不是所有的公钥算法都支持加密/解密、数字签名和密钥交换功能，有的公钥算法只支持其中的一种或两种，下表列出部分公钥算法锁支持的应用。</p><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">加密/解密</th><th style="text-align:center">数字签名</th><th style="text-align:center">密钥交换</th></tr></thead><tbody><tr><td style="text-align:center">RSA<br>安全性建立在基于大素数分解是困难的</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">椭圆曲线/ECC<br>安全性建立在椭圆曲线对数问题之上<br>(即由kP和P确定k是困难的)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Diff-Hellman<br>安全性建立在计算离散对数是很困难的</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">DSS</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr></tbody></table><h4 id="Hash函数-散列函数或摘要函数"><a href="#Hash函数-散列函数或摘要函数" class="headerlink" title="Hash函数(散列函数或摘要函数)"></a>Hash函数(散列函数或摘要函数)</h4><p>Hash函数将可变长度的消息映射为固定长度的<strong>Hash值</strong>或<strong>消息摘要</strong>，常见的Hash算法有：MD2、MD4、MD5、SHA-1、SHA-224、SHA-256、SHA-384、SHA-512、HAVAL、HMAC、HMAC-MD5、HMAC-SHA1。对于给定的密码学Hash函数y=Hash(x)，要求如下两种情况再计算上不可行：</p><ol><li>对给定的y，找到对应的x；</li><li>找到两个不同的x1和x2，使得Hash(x1)=Hash(x2)，具有抗碰撞性的特点。</li></ol><h5 id="Hash函数的应用"><a href="#Hash函数的应用" class="headerlink" title="Hash函数的应用"></a>Hash函数的应用</h5><ol><li><strong>消息认证</strong>是用来验证消息完整性的一种机制或服务，消息认证确认收到的数据确实和发送时的一样(即<strong>防篡改</strong>)，并且还要确保发送方的身份是真实有效的的(即<strong>防冒充</strong>)。下图以对称加密算法为例，因为对称密钥K只有Bob和Alice才有，保证了发送方的合法有效性，同时比较C3与C是否相等，可以确定传输过程中是否被篡改过。</li></ol><pre class="mermaid">graph LRA[Bob<br>输入明文P] -->|P|B["Bob<br>Hash函数<br>(如sha256)<br>C=Hash(P)"];B -->|C|C["Bob<br>C1=P||C"];A -->|P|C;C -->|"C1=P||C"|D["Bob和Alice公用的密钥K<br>对称加密算法(如DES)<br>C2=E(K,C1)"];D -->|传输密文C2|E["Alice和Bob公用的密钥K<br>对称解密算法(如DES)<br>C1=D(K,C2)"];E -->|"C1=P||C"|F["Alice<br>1.Hash函数(如sha256)<br>C3=Hash(P)<br>2.比较C3与C是否相等"];</pre><ol start="2"><li><p><strong>数字签名(也名指纹或摘要)</strong>是一种认证机制，它使得消息的产生者可以添加一个起签名作用的码字，通过计算消息的Hash值并用产生者的私钥加密Hash值来生成签名，签名保证了消息和来源和完整性。下图最后一步比较C3与C如果不相等，认证失败，该图没有提供保密性，因为传输过程中只是将P和C1简单的连接在一起，并没有对C2进行加密，如果需要提供保密性，可以使用Alic的私钥对C2加密后再传输。</p><pre class="mermaid">graph LRA[Bob<br>输入明文P] -->|P|B["Bob<br>Hash函数<br>(如sha256)<br>C=Hash(P)"];B -->|C|C["Bob的私钥PRbob<br>加密算法(如RSA)<br>C1=E(PRbob,C)"];C -->|C1|D["Bob<br>C2=P||C1"];A -->|P|D;D -->|传输C2|E["Alice的公钥环{PUbob,……}<br>1.解密算法(如RSA)<br>C=D(PUbob,C1)<br>2.Hash函数(如sha256)<br>C3=Hash(P)<br>3.比较C3与C是否相等"];</pre></li><li><p>用于产生单向口令文件，比如操作系统存储的都是口令的Hah值而不是口令本身，当用户输入口令时，计算其Hash值和之前存储的口令比对，这样即使操作系统被黑之后，也能保证用户口令的安全性。同样适用于入侵检测和病毒检测，如将你需要保护的文件的Hash值存储到安全系统中(比如只读设备中，不可修改也不可删除)，这样病毒入侵后只能修改文件而不能修改Hash值，于是可以通过重新计算文件的Hash值和之前保存的Hash值比对。</p></li></ol><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>典型的流密码是每次加密一个字节的密文，加密长度可以按需求设计，比如每次只加密一位或者大于一个字节的单元都行。实质上$Ci=Pi \oplus K1i，Pi=Ci \oplus K2i$，就是简单的异或，加密异或一次，解密再异或一次，即可恢复明文字节流。</p><pre class="mermaid">graph LRA["Bob<br>明文字节流P1~Pn"] -->|"P1~Pn"|C["Bob<br>加密函数<br>Ci=E(K1i,Pi)"];B["Bob 由密钥K1控制的<br>密钥流发生器K11～K1n<br>其中K1i=K2i"] -->|"K11～K1n"|C;C -->|"传输密文C1～Cn"|E["Alice<br>解密函数<br>Pi=D(K2i,Ci)"];D["Alice 由密钥K2控制的<br>密钥流发生器K21～K2n<br>其中K1i=K2i"] -->|"K21～K2n"|E;E -->|"明文字节流P1～Pn"|F["Alice<br>明文字节流P1~Pn"];</pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044%20MathJax%20basic%20tutorial%20and%20quick%20reference" rel="external nofollow noopener noreferrer" target="_blank">MathJax语法规则</a><br><a href="https://www.jianshu.com/p/7ddbb7dc8fec" rel="external nofollow noopener noreferrer" target="_blank">Mermaid语法规则</a><br><a href="https://mermaidjs.github.io/demos.html" rel="external nofollow noopener noreferrer" target="_blank">Mermaid官方教程</a><br><a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" rel="external nofollow noopener noreferrer" target="_blank">Mermaid Github仓库</a><br><a href="https://github.com/mathjax/MathJax" rel="external nofollow noopener noreferrer" target="_blank">MathJax Github仓库</a><br><a href="https://www.cnblogs.com/colife/p/5566789.html" rel="external nofollow noopener noreferrer" target="_blank">常用加密算法概述</a><br><a href="https://blog.csdn.net/u011779724/article/details/80776776" rel="external nofollow noopener noreferrer" target="_blank">HTTPS建立过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实际工作和开发过程中，网络通信过程中的数据传输和存储大多需要经过严格的加解密设计，比如用户的登陆与注册，敏感信息传输，支付网站和银行的交易信息，甚至为了防止被拖库，数据库的敏感信息存储也需要经过精心的设计。在进行安全设计过程中，或多或少涉及到密码学的一些概念，比如对称加密算
      
    
    </summary>
    
      <category term="密码学与信息安全" scheme="https://icoty.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="对称加密算法" scheme="https://icoty.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="非对称加密算法/公钥算法" scheme="https://icoty.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95-%E5%85%AC%E9%92%A5%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash函数/散列函数/摘要函数" scheme="https://icoty.github.io/tags/Hash%E5%87%BD%E6%95%B0-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0-%E6%91%98%E8%A6%81%E5%87%BD%E6%95%B0/"/>
    
      <category term="消息认证" scheme="https://icoty.github.io/tags/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/"/>
    
      <category term="流密码" scheme="https://icoty.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"/>
    
      <category term="数字签名/指纹/消息摘要" scheme="https://icoty.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E6%8C%87%E7%BA%B9-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>Nachos-Lab3-同步与互斥机制模块实现</title>
    <link href="https://icoty.github.io/2019/05/14/nachos-3-4-Lab3/"/>
    <id>https://icoty.github.io/2019/05/14/nachos-3-4-Lab3/</id>
    <published>2019-05-14T08:39:17.000Z</published>
    <updated>2019-06-09T06:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p><a href="https://github.com/icoty/nachos-3.4-Lab" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/icoty/nachos-3.4-Lab</a></p><h2 id="内容一：总体概述"><a href="#内容一：总体概述" class="headerlink" title="内容一：总体概述"></a>内容一：总体概述</h2><p>本实习希望通过修改Nachos系统平台的底层源代码，达到“扩展同步机制，实现同步互斥实例”的目标。</p><h2 id="内容二：任务完成情况"><a href="#内容二：任务完成情况" class="headerlink" title="内容二：任务完成情况"></a>内容二：任务完成情况</h2><h3 id="任务完成列表（Y-N）"><a href="#任务完成列表（Y-N）" class="headerlink" title="任务完成列表（Y/N）"></a>任务完成列表（Y/N）</h3><table><thead><tr><th></th><th>Exercise1</th><th>Exercise2</th><th>Exercise3</th><th>Exercise4</th><th>Challenge1</th><th>Challenge2</th><th>Challenge3</th></tr></thead><tbody><tr><td>第一部分</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><h3 id="具体Exercise的完成情况"><a href="#具体Exercise的完成情况" class="headerlink" title="具体Exercise的完成情况"></a>具体Exercise的完成情况</h3><h4 id="Exercise1-调研"><a href="#Exercise1-调研" class="headerlink" title="Exercise1  调研"></a>Exercise1  调研</h4><p>调研Linux或Windows中采用的进程/线程调度算法。具体内容见课堂要求。</p><ul><li><p>同步是指用于实现控制多个进程按照一定的规则或顺序访问某些系统资源的机制，进程间的同步方式有共享内存，套接字，管道，信号量，消息队列，条件变量；线程间的同步有套接字，消息队列，全局变量，条件变量，信号量。</p></li><li><p>互斥是指用于实现控制某些系统资源在任意时刻只能允许一个进程访问的机制。互斥是同步机制中的一种特殊情况。进程间的互斥方式有锁，信号量，条件变量；线程间的互斥方式有信号量，锁，条件变量。此外，通过硬件也能实现同步与互斥。</p></li><li>linux内核中提供的同步机制<ul><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#原子操作" rel="external nofollow noopener noreferrer" target="_blank">原子操作</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#自旋锁" rel="external nofollow noopener noreferrer" target="_blank">自旋锁</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#读写自旋锁" rel="external nofollow noopener noreferrer" target="_blank">读写自旋锁</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#信号量" rel="external nofollow noopener noreferrer" target="_blank">信号量</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#读写信号量" rel="external nofollow noopener noreferrer" target="_blank">读写信号量</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#互斥量" rel="external nofollow noopener noreferrer" target="_blank">互斥量</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#完成变量" rel="external nofollow noopener noreferrer" target="_blank">完成变量</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#大内核锁" rel="external nofollow noopener noreferrer" target="_blank">大内核锁</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#顺序锁" rel="external nofollow noopener noreferrer" target="_blank">顺序锁</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#禁止抢占" rel="external nofollow noopener noreferrer" target="_blank">禁止抢占</a></li><li><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446#顺序和屏障" rel="external nofollow noopener noreferrer" target="_blank">顺序和屏障</a></li></ul></li></ul><h4 id="Exercise2-源代码阅读"><a href="#Exercise2-源代码阅读" class="headerlink" title="Exercise2 源代码阅读"></a>Exercise2 源代码阅读</h4><p><strong>code/threads/synch.h和code/threads/synch.cc</strong>：Condition和Lock仅仅声明了未定义；Semaphore既声明又定义了。</p><ul><li><p><strong>Semaphore</strong>有一个初值和一个等待队列，提供P、V操作：</p><ul><li>P操作：当value等于0时，将当前运行线程放入线程等待队列，当前进程进入睡眠状态，并切换到其他线程运行；当value大于0时，value–。</li><li>V操作：如果线程等待队列中有等待该信号量的线程，取出其中一个将其设置成就绪态，准备运行，value++。</li></ul></li><li><p><strong>Lock</strong>：Nachos中没有给出锁机制的实现，接口有获得锁(Acquire)和释放锁(Release)，他们都是原子操作。</p><ul><li>Acquire：当锁处于BUSY态，进入睡眠状态。当锁处于FREE态，当前进程获得该锁，继续运行。</li><li>Release：释放锁（只能由拥有锁的线程才能释放锁），将锁的状态设置为FREE态，如果有其他线程等待该锁，将其中的一个唤醒，进入就绪态。</li></ul></li><li><p><strong>Condition</strong>：条件变量同信号量、锁机制不一样，条件变量没值。当一个线程需要的某种条件没有得到满足时，可以将自己作为一个等待条件变量的线程插入所有等待该条件变量的队列，只要条件一旦得到满足，该线程就会被唤醒继续运行。条件变量总是和锁机制一起使。主要接口Wait、Signal、BroadCast，这三个操作必须在当前线程获得一个锁的前提下，而且所有对一个条件变量进行的操作必须建立在同一个锁的前提下。</p><ul><li>Wait(Lock *conditionLock)：线程等待在条件变量上，把线程放入条件变量的等待队列上。</li><li>Signal(Lock *conditionLock)：从条件变量的等待队列中唤醒一个等待该条件变量的线程。</li><li>BroadCast(Lock *conditionLock)：唤醒所有等待该条件变量的线程。</li></ul></li></ul><p><strong>code/threads/synchlist.h和code/threads/synchlist.cc</strong>：利用锁、条件变量实现的一个消息队列，使多线程达到互斥访问和同步通信的目的，类内有一个Lock和List成员变量。提供了对List的Append()，Remove()和Mapcar()操作。每个操作都要先获得该锁，然后才能对List进行相应的操作。</p><h4 id="Exercise3-实现锁和条件变量"><a href="#Exercise3-实现锁和条件变量" class="headerlink" title="Exercise3 实现锁和条件变量"></a>Exercise3 <strong>实现锁和条件变量</strong></h4><p>可以使用sleep和wakeup两个原语操作（注意屏蔽系统中断），也可以使用Semaphore作为唯一同步原语（不必自己编写开关中断的代码）。</p><p>这里选择用1值信号量实现锁功能，Lock添加成员变量lock和owner，请求锁和释放锁都必须关中断，Condition添加一个成员变量queue，用于存放所有等待在该条件变量上的线程。代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// synch.h Lock声明部分</span><br><span class="line">class Lock &#123;</span><br><span class="line">……</span><br><span class="line">private:</span><br><span class="line">  char* name;// <span class="keyword">for</span> debugging</span><br><span class="line">  // add by yangyu</span><br><span class="line">  Semaphore *lock;</span><br><span class="line">  Thread* owner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Condition &#123;</span><br><span class="line">……</span><br><span class="line">private:</span><br><span class="line">  char* name;</span><br><span class="line">  // add by yangyu</span><br><span class="line">  List* queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// synch.cc Lock定义部分</span><br><span class="line">Lock::Lock(char* debugName) </span><br><span class="line">:lock(new Semaphore(<span class="string">"lock"</span>, 1))</span><br><span class="line">,name(debugName)</span><br><span class="line">,owner(NULL)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Lock::~Lock() </span><br><span class="line">&#123;</span><br><span class="line">    delete lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Lock::isHeldByCurrentThread()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> currentThread == owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Lock::Acquire() </span><br><span class="line">&#123;</span><br><span class="line">    IntStatus prev = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    lock-&gt;P();</span><br><span class="line">    owner = currentThread;</span><br><span class="line">    (void)interrupt-&gt;SetLevel(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Lock::<span class="function"><span class="title">Release</span></span>() &#123;</span><br><span class="line">    IntStatus prev = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">    ASSERT(currentThread == owner);</span><br><span class="line">    lock-&gt;V();</span><br><span class="line">    owner = NULL;</span><br><span class="line">    (void)interrupt-&gt;SetLevel(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// synch.cc Condition定义部分</span><br><span class="line">Condition::Condition(char* debugName)</span><br><span class="line">:name(debugName)</span><br><span class="line">,queue(new List)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">Condition::~Condition()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">void Condition::Wait(Lock* conditionLock) </span><br><span class="line">&#123;</span><br><span class="line">  //ASSERT(FALSE);</span><br><span class="line">  // 关中断</span><br><span class="line">  IntStatus prev = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">  // 锁和信号量不同，谁加锁必须由谁解锁，因此做下判断</span><br><span class="line">  ASSERT(conditionLock-&gt;isHeldByCurrentThread());</span><br><span class="line">  // 进入睡眠前把锁的权限释放掉，然后放到等待队列，直到被唤醒时重新征用锁</span><br><span class="line">  conditionLock-&gt;Release();</span><br><span class="line">  queue-&gt;Append(currentThread);</span><br><span class="line">  currentThread-&gt;Sleep();</span><br><span class="line">  conditionLock-&gt;Acquire();</span><br><span class="line">  (void)interrupt-&gt;SetLevel(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Condition::Signal(Lock* conditionLock) </span><br><span class="line">&#123;</span><br><span class="line">  IntStatus prev = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">  ASSERT(conditionLock-&gt;isHeldByCurrentThread()); </span><br><span class="line">  <span class="keyword">if</span>(!queue-&gt;IsEmpty())</span><br><span class="line">  &#123;</span><br><span class="line">// 唤醒一个等待的线程，挂入倒就绪队列中</span><br><span class="line">    Thread* next = (Thread*)queue-&gt;Remove();</span><br><span class="line">    scheduler-&gt;ReadyToRun(next);</span><br><span class="line">  &#125;</span><br><span class="line">  (void)interrupt-&gt;SetLevel(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Condition::Broadcast(Lock* conditionLock) </span><br><span class="line">&#123;</span><br><span class="line">  IntStatus prev = interrupt-&gt;SetLevel(IntOff);</span><br><span class="line">  ASSERT(conditionLock-&gt;isHeldByCurrentThread()); </span><br><span class="line">  // 唤醒等待在该条件变量上的所有线程</span><br><span class="line">  <span class="keyword">while</span>(!queue-&gt;IsEmpty())</span><br><span class="line">  &#123;</span><br><span class="line">Signal(conditionLock);</span><br><span class="line">  &#125;    </span><br><span class="line">  (void)interrupt-&gt;SetLevel(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exercise4-实现同步互斥实例"><a href="#Exercise4-实现同步互斥实例" class="headerlink" title="Exercise4 实现同步互斥实例"></a>Exercise4 <strong>实现同步互斥实例</strong></h4><p>基于Nachos中的信号量、锁和条件变量，采用两种方式实现同步和互斥机制应用（其中使用条件变量实现同步互斥机制为必选题目）。具体可选择“生产者-消费者问题”、“读者-写者问题”、“哲学家就餐问题”、“睡眠理发师问题”等。（也可选择其他经典的同步互斥问题）。</p><h5 id="生产者-消费者问题-Condition实现"><a href="#生产者-消费者问题-Condition实现" class="headerlink" title="生产者-消费者问题(Condition实现)"></a>生产者-消费者问题(Condition实现)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// threadtest.cc</span><br><span class="line">// 条件变量实现生产者消费者问题</span><br><span class="line">Condition* condc = new Condition(<span class="string">"ConsumerCondition"</span>);</span><br><span class="line">Condition* condp = new Condition(<span class="string">"ProducerCondition"</span>);</span><br><span class="line">Lock* pcLock = new Lock(<span class="string">"producerConsumerLock"</span>);</span><br><span class="line">int shareNum = 0; // 共享内容，生产+1，消费-1，互斥访问</span><br><span class="line"></span><br><span class="line">// lab3 条件变量实现生产者消费者问题</span><br><span class="line">void Producer1(int val)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1)&#123;</span><br><span class="line">    pcLock-&gt;Acquire();</span><br><span class="line">    // 缓冲区已满则等待在条件变量上，停止生产，等待消费后再生产</span><br><span class="line">    <span class="keyword">while</span>(shareNum &gt;= N)&#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Product alread full:[%d],threadId:[%d],wait consumer.\n"</span>,shareNum,currentThread-&gt;getThreadId());</span><br><span class="line">      condp-&gt;Wait(pcLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name:[%s],threadId:[%d],before:[%d],after:[%d]\n"</span>,currentThread-&gt;getName(),currentThread-&gt;getThreadId(),shareNum,shareNum+1);</span><br><span class="line">    ++shareNum;</span><br><span class="line"></span><br><span class="line">// 生产一个通知可消费，唤醒一个等待在condc上的消费者</span><br><span class="line">    condc-&gt;Signal(pcLock);</span><br><span class="line">    pcLock-&gt;Release();</span><br><span class="line">    sleep(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Customer1(int val)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1)&#123;</span><br><span class="line">    pcLock-&gt;Acquire();</span><br><span class="line">    // 为零表示已经消费完毕,等待在条件变量上，等待生产后再消费</span><br><span class="line">    <span class="keyword">while</span>(shareNum &lt;= 0)&#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"--&gt;Product alread empty:[%d],threadId:[%d],wait producer.\n"</span>,shareNum,currentThread-&gt;getThreadId());</span><br><span class="line">      condc-&gt;Wait(pcLock);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name:[%s],threadId:[%d],before:[%d],after:[%d]\n"</span>,currentThread-&gt;getName(),currentThread-&gt;getThreadId(),shareNum,shareNum-1);</span><br><span class="line">    --shareNum;</span><br><span class="line">    // 消费一个后通知生产者缓冲区不为满，可以生产</span><br><span class="line">    condp-&gt;Signal(pcLock);</span><br><span class="line">    pcLock-&gt;Release();</span><br><span class="line">    //sleep(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">ThreadProducerConsumerTest1</span></span>()&#123;</span><br><span class="line">  DEBUG(<span class="string">'t'</span>, <span class="string">"Entering ThreadProducerConsumerTest1"</span>);</span><br><span class="line">  // 两个生产者循环生产</span><br><span class="line">  Thread* p1 = new Thread(<span class="string">"Producer1"</span>);</span><br><span class="line">  Thread* p2 = new Thread(<span class="string">"Producer2"</span>);</span><br><span class="line">  p1-&gt;Fork(Producer1, 1);</span><br><span class="line">  p2-&gt;Fork(Producer1, 3);</span><br><span class="line"></span><br><span class="line">// 两个消费者循环消费</span><br><span class="line">  Thread* c1 = new Thread(<span class="string">"Consumer1"</span>);</span><br><span class="line">  Thread* c2 = new Thread(<span class="string">"Consumer2"</span>);</span><br><span class="line">  c1-&gt;Fork(Customer1, 1);</span><br><span class="line">  c2-&gt;Fork(Customer1, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ThreadTest()</span><br><span class="line">&#123;</span><br><span class="line">  switch (testnum) &#123;</span><br><span class="line">  <span class="keyword">case</span> 1:</span><br><span class="line">    ThreadTest1();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 2:</span><br><span class="line">    ThreadCountLimitTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 3:</span><br><span class="line">    ThreadPriorityTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 4:</span><br><span class="line">    ThreadProducerConsumerTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 5:</span><br><span class="line">    ThreadProducerConsumerTest1();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 6:</span><br><span class="line">    barrierThreadTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 7:</span><br><span class="line">    readWriteThreadTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  default:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No test specified.\n"</span>);</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果，需要-rs，否则可能没有中断发生，永远是一个线程在运行</span><br><span class="line">// 通过结果可以明确看出生产前和生产后，消费前和消费后的数值变化</span><br><span class="line">// 可以通过修改Producer1和Consumer1内的sleep(val)来调整不同的速度</span><br><span class="line">// 当生产满了会停止生产，消费完了也会停止消费</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -rs -q 5</span></span><br><span class="line">name:[Producer1],threadId:[1],before:[0],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">name:[Producer1],threadId:[1],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer2],threadId:[4],before:[2],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">name:[Producer1],threadId:[1],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer2],threadId:[4],before:[2],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">--&gt;name:[Consumer2],threadId:[4],before:[1],after:[0]</span><br><span class="line">name:[Producer1],threadId:[1],before:[0],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">name:[Producer1],threadId:[1],before:[2],after:[3]</span><br><span class="line">--&gt;name:[Consumer2],threadId:[4],before:[3],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">name:[Producer1],threadId:[1],before:[2],after:[3]</span><br><span class="line">--&gt;name:[Consumer2],threadId:[4],before:[3],after:[2]</span><br><span class="line">--&gt;name:[Consumer1],threadId:[3],before:[2],after:[1]</span><br><span class="line">name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">^C</span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure><h5 id="生产者-消费者问题-Semaphore实现"><a href="#生产者-消费者问题-Semaphore实现" class="headerlink" title="生产者-消费者问题(Semaphore实现)"></a>生产者-消费者问题(Semaphore实现)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// threadtest.cc</span><br><span class="line">// 信号量解决生产者消费者问题</span><br><span class="line"><span class="comment">#define N 1024 // 缓冲区大小</span></span><br><span class="line">Semaphore* empty = new Semaphore(<span class="string">"emptyBuffer"</span>, N);</span><br><span class="line">Semaphore* mutex = new Semaphore(<span class="string">"lockSemaphore"</span>, 1);</span><br><span class="line">Semaphore* full = new Semaphore(<span class="string">"fullBuffer"</span>, 0);</span><br><span class="line">int msgQueue = 0;</span><br><span class="line"></span><br><span class="line">void Producer(int val)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1) &#123;</span><br><span class="line">    empty-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    <span class="keyword">if</span>(msgQueue &gt;= N)&#123; // 已经满了则停止生产</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;Product alread full:[%d],wait consumer."</span>,msgQueue);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"--&gt;name:[%s],threadId:[%d],before:[%d],after:[%d]\n"</span>,\</span><br><span class="line">      currentThread-&gt;getName(),currentThread-&gt;getThreadId(),msgQueue,msgQueue+1);</span><br><span class="line">      ++msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    full-&gt;V();</span><br><span class="line"></span><br><span class="line">    sleep(val); // 休息下再生产</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Customer(int val)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1) &#123;</span><br><span class="line">    full-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    <span class="keyword">if</span>(msgQueue &lt;= 0)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Product alread empty:[%d],wait Producer."</span>,msgQueue);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"name:[%s] threadId:[%d],before:[%d],after:[%d]\n"</span>,\</span><br><span class="line">      currentThread-&gt;getName(),currentThread-&gt;getThreadId(),msgQueue,msgQueue-1);</span><br><span class="line">      --msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    empty-&gt;V();</span><br><span class="line"></span><br><span class="line">    sleep(val); // 休息下再消费</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">ThreadProducerConsumerTest</span></span>()&#123;</span><br><span class="line">  DEBUG(<span class="string">'t'</span>, <span class="string">"Entering ThreadProducerConsumerTest"</span>);</span><br><span class="line">  // 两个生产者</span><br><span class="line">  Thread* p1 = new Thread(<span class="string">"Producer1"</span>);</span><br><span class="line">  Thread* p2 = new Thread(<span class="string">"Producer2"</span>);</span><br><span class="line">  p1-&gt;Fork(Producer, 1);</span><br><span class="line">  p2-&gt;Fork(Producer, 3);</span><br><span class="line"></span><br><span class="line">// 两个消费者，可以关掉一个消费者，查看生产速率和消费速率的变化</span><br><span class="line">  Thread* c1 = new Thread(<span class="string">"Consumer1"</span>);</span><br><span class="line">  //Thread* c2 = new Thread(<span class="string">"Consumer2"</span>);</span><br><span class="line">  c1-&gt;Fork(Customer, 1);</span><br><span class="line">  //c2-&gt;Fork(Customer, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 通过结果可以明确看出生产前和生产后，消费前和消费后的数值变化</span><br><span class="line">// 可以通过修改Producer和Consumer内的sleep(val)来调整不同的速度</span><br><span class="line">// 当生产满了会停止生产，消费完了也会停止消费</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -rs -q 4</span></span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[0],after:[1]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[1],after:[2]</span><br><span class="line">name:[Consumer1] threadId:[3],before:[2],after:[1]</span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[1],after:[2]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[2],after:[3]</span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[3],after:[4]</span><br><span class="line">name:[Consumer1] threadId:[3],before:[4],after:[3]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[3],after:[4]</span><br><span class="line">name:[Consumer1] threadId:[3],before:[4],after:[3]</span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[3],after:[4]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[4],after:[5]</span><br><span class="line">name:[Consumer1] threadId:[3],before:[5],after:[4]</span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[4],after:[5]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[5],after:[6]</span><br><span class="line">--&gt;name:[Producer1],threadId:[1],before:[6],after:[7]</span><br><span class="line">--&gt;name:[Producer2],threadId:[2],before:[7],after:[8]</span><br><span class="line">name:[Consumer1] threadId:[3],before:[8],after:[7]</span><br><span class="line">^C</span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure><h4 id="Challenge1-实现barrier-至少选做一个Challenge"><a href="#Challenge1-实现barrier-至少选做一个Challenge" class="headerlink" title="Challenge1 实现barrier(至少选做一个Challenge)"></a>Challenge1 实现barrier(至少选做一个Challenge)</h4><p>可以使用Nachos 提供的同步互斥机制（如条件变量）来实现barrier，使得当且仅当若干个线程同时到达某一点时方可继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// threadtest.cc</span><br><span class="line">// 条件变量实现barrier</span><br><span class="line">Condition* barrCond = new Condition(<span class="string">"BarrierCond"</span>);</span><br><span class="line">Lock* barrLock = new Lock(<span class="string">"BarrierLock"</span>);</span><br><span class="line">int barrierCnt = 0;</span><br><span class="line">// 当且仅当barrierThreadNum个线程同时到达时才能往下运行</span><br><span class="line">const int barrierThreadNum = 5; </span><br><span class="line"></span><br><span class="line">void barrierFun(int num)</span><br><span class="line">&#123;</span><br><span class="line">  /*<span class="keyword">while</span>(1)*/</span><br><span class="line">  &#123;</span><br><span class="line">    barrLock-&gt;Acquire();</span><br><span class="line">    ++barrierCnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(barrierCnt == barrierThreadNum)&#123;</span><br><span class="line">// 最后一个线程到达后判断，条件满足则发送一个广播信号</span><br><span class="line">// 唤醒等待在该条件变量上的所有线程</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"threadName:[%s%d],barrierCnt:[%d],needCnt:[%d],Broadcast.\n"</span>,\</span><br><span class="line">      currentThread-&gt;getName(),num,barrierCnt,barrierThreadNum);</span><br><span class="line">      barrCond-&gt;Broadcast(barrLock);</span><br><span class="line">      barrLock-&gt;Release();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    // 每一个线程都执行判断，若条件不满足，线程等待在条件变量上</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"threadName:[%s%d],barrierCnt:[%d],needCnt:[%d],Wait.\n"</span>,\</span><br><span class="line">      currentThread-&gt;getName(),num,barrierCnt,barrierThreadNum);</span><br><span class="line">      barrCond-&gt;Wait(barrLock);</span><br><span class="line">      barrLock-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"threadName:[%s%d],continue to run.\n"</span>, currentThread-&gt;getName(),num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">barrierThreadTest</span></span>()&#123;</span><br><span class="line">  DEBUG(<span class="string">'t'</span>, <span class="string">"Entering barrierThreadTest"</span>);</span><br><span class="line">  <span class="keyword">for</span>(int i = 0; i &lt; barrierThreadNum; ++i)&#123;</span><br><span class="line">    Thread* t = new Thread(<span class="string">"barrierThread"</span>);</span><br><span class="line">    t-&gt;Fork(barrierFun,i+1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果，当第五个线程进入后判断条件满足，唤醒所有线程</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -rs -q 6</span></span><br><span class="line">threadName:[barrierThread1],barrierCnt:[1],needCnt:[5],Wait.</span><br><span class="line">threadName:[barrierThread2],barrierCnt:[2],needCnt:[5],Wait.</span><br><span class="line">threadName:[barrierThread3],barrierCnt:[3],needCnt:[5],Wait.</span><br><span class="line">threadName:[barrierThread4],barrierCnt:[4],needCnt:[5],Wait.</span><br><span class="line">threadName:[barrierThread5],barrierCnt:[5],needCnt:[5],Broadcast.</span><br><span class="line">threadName:[barrierThread5],<span class="built_in">continue</span> to run.</span><br><span class="line">threadName:[barrierThread2],<span class="built_in">continue</span> to run.</span><br><span class="line">threadName:[barrierThread1],<span class="built_in">continue</span> to run.</span><br><span class="line">threadName:[barrierThread4],<span class="built_in">continue</span> to run.</span><br><span class="line">threadName:[barrierThread3],<span class="built_in">continue</span> to run.</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 814, idle 4, system 810, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h4 id="Challenge2-实现read-write-lock"><a href="#Challenge2-实现read-write-lock" class="headerlink" title="Challenge2 实现read/write lock"></a>Challenge2 实现read/write lock</h4><p>基于Nachos提供的lock(synch.h和synch.cc)，实现read/write lock。使得若干线程可以同时读取某共享数据区内的数据，但是在某一特定的时刻，只有一个线程可以向该共享数据区写入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// threadtest.cc</span><br><span class="line">// Lab3 锁实现读者写者问题</span><br><span class="line">int rCnt = 0; // 记录读者数量</span><br><span class="line">Lock* rLock = new Lock(<span class="string">"rlock"</span>);</span><br><span class="line">// 必须用信号量，不能用锁，因为锁只能由加锁的线程解锁</span><br><span class="line">Semaphore* wLock = new Semaphore(<span class="string">"wlock"</span>,1); </span><br><span class="line">int bufSize = 0;</span><br><span class="line">// Lab3 锁实现读者写者问题</span><br><span class="line">void readFunc(int num)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1) &#123;</span><br><span class="line">    rLock-&gt;Acquire();</span><br><span class="line">    ++rCnt;</span><br><span class="line">    // 如果是第一个读者进入，需要竞争1值信号量wLock，竞争成功才能进入临界区</span><br><span class="line">    // 一旦竞争到wLock，由最后一个读者出临界区后释放，保证了读者优先</span><br><span class="line">    <span class="keyword">if</span>(rCnt == 1)&#123; </span><br><span class="line">    wLock-&gt;P();</span><br><span class="line">    &#125;</span><br><span class="line">    rLock-&gt;Release();</span><br><span class="line">    <span class="keyword">if</span>(0 == bufSize)&#123;</span><br><span class="line">// 没有数据可读</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"threadName:[%s],bufSize:[%d],current not data.\n"</span>,currentThread-&gt;getName(),bufSize);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">// 读取数据</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"threadName:[%s],bufSize:[%d],exec read operation.\n"</span>,currentThread-&gt;getName(),bufSize);</span><br><span class="line">    &#125;</span><br><span class="line">    rLock-&gt;Acquire();</span><br><span class="line">    --rCnt;</span><br><span class="line">    // 最后一个读者释放wLock</span><br><span class="line">    <span class="keyword">if</span>(rCnt == 0)&#123;</span><br><span class="line">    wLock-&gt;V();</span><br><span class="line">    &#125;</span><br><span class="line">    rLock-&gt;Release();</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    sleep(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writeFunc(int num)&#123;</span><br><span class="line">  <span class="keyword">while</span>(1) &#123;</span><br><span class="line">    wLock-&gt;P();</span><br><span class="line">    ++bufSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"writerThread:[%s],before:[%d],after:[%d]\n"</span>, currentThread-&gt;getName(), bufSize, bufSize+1);</span><br><span class="line">    wLock-&gt;V();</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    sleep(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readWriteThreadTest()</span><br><span class="line">&#123;</span><br><span class="line">  DEBUG(<span class="string">'t'</span>, <span class="string">"Entering readWriteThreadTest"</span>);</span><br><span class="line">  Thread * r1 = new Thread(<span class="string">"read1"</span>);</span><br><span class="line">  Thread * r2 = new Thread(<span class="string">"read2"</span>);</span><br><span class="line">  Thread * r3 = new Thread(<span class="string">"read3"</span>);</span><br><span class="line">  Thread * w1 = new Thread(<span class="string">"write1"</span>);</span><br><span class="line">  Thread * w2 = new Thread(<span class="string">"write2"</span>);</span><br><span class="line"></span><br><span class="line">// 3个读者2个写者</span><br><span class="line">  r1-&gt;Fork(readFunc,1);</span><br><span class="line">  w1-&gt;Fork(writeFunc,1);</span><br><span class="line">  r2-&gt;Fork(readFunc,1);</span><br><span class="line">  w2-&gt;Fork(writeFunc,1);</span><br><span class="line">  r3-&gt;Fork(readFunc,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果，第一个读者进入无数据可读</span><br><span class="line">// 可以发现读操作比写操作多</span><br><span class="line">// 一旦开始读，就要等所有线程读取完毕后，写线程才进入</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -rs -q 7</span></span><br><span class="line">threadName:[read1],Val:[0],current not data.</span><br><span class="line">writerThread:[write1],before:[0],after:[1]</span><br><span class="line">writerThread:[write2],before:[1],after:[2]</span><br><span class="line">writerThread:[write1],before:[2],after:[3]</span><br><span class="line">writerThread:[write2],before:[3],after:[4]</span><br><span class="line">threadName:[read2],readVal:[4],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read1],readVal:[4],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read3],readVal:[4],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">writerThread:[write1],before:[4],after:[5]</span><br><span class="line">threadName:[read2],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read3],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read2],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read3],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read2],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read3],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">threadName:[read1],readVal:[5],<span class="built_in">exec</span> <span class="built_in">read</span> operation.</span><br><span class="line">writerThread:[write2],before:[5],after:[6]</span><br><span class="line">writerThread:[write1],before:[6],after:[7]</span><br><span class="line">^C</span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="内容三：遇到的困难以及解决方法"><a href="#内容三：遇到的困难以及解决方法" class="headerlink" title="内容三：遇到的困难以及解决方法"></a>内容三：遇到的困难以及解决方法</h2><h3 id="困难1"><a href="#困难1" class="headerlink" title="困难1"></a>困难1</h3><p>刚开始没有加-rs参数，导致永远都只有一个线程在运行，原因是没有中断发生，运行的线程永远在执行循环体，加-rs参数，会在一个固定的时间短内发一个时钟中断，然后调度其他线程运行。</p><h2 id="内容四：收获及感想"><a href="#内容四：收获及感想" class="headerlink" title="内容四：收获及感想"></a>内容四：收获及感想</h2><p>可以说实际操作后，对信号量，条件变量的应用更加清晰了。</p><h2 id="内容五：对课程的意见和建议"><a href="#内容五：对课程的意见和建议" class="headerlink" title="内容五：对课程的意见和建议"></a>内容五：对课程的意见和建议</h2><p>暂无。</p><h2 id="内容六：参考文献"><a href="#内容六：参考文献" class="headerlink" title="内容六：参考文献"></a>内容六：参考文献</h2><p><a href="https://blog.csdn.net/FreeeLinux/article/details/54267446" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/FreeeLinux/article/details/54267446</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/icoty/nachos-3.4-Lab&quot; rel=&quot;externa
      
    
    </summary>
    
      <category term="同步机制" scheme="https://icoty.github.io/categories/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="互斥机制" scheme="https://icoty.github.io/categories/%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="条件变量" scheme="https://icoty.github.io/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    
      <category term="锁" scheme="https://icoty.github.io/tags/%E9%94%81/"/>
    
      <category term="信号量" scheme="https://icoty.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="Nachos-3.4" scheme="https://icoty.github.io/tags/Nachos-3-4/"/>
    
      <category term="生产者消费者问题" scheme="https://icoty.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="读者写者问题" scheme="https://icoty.github.io/tags/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="Barrier" scheme="https://icoty.github.io/tags/Barrier/"/>
    
  </entry>
  
  <entry>
    <title>Nachos-Lab2-线程调度模块实现</title>
    <link href="https://icoty.github.io/2019/05/14/nachos-3-4-Lab2/"/>
    <id>https://icoty.github.io/2019/05/14/nachos-3-4-Lab2/</id>
    <published>2019-05-14T04:57:24.000Z</published>
    <updated>2019-06-09T06:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p><a href="https://github.com/icoty/nachos-3.4-Lab" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/icoty/nachos-3.4-Lab</a></p><h2 id="内容一：总体概述"><a href="#内容一：总体概述" class="headerlink" title="内容一：总体概述"></a>内容一：总体概述</h2><p>本实习希望通过修改Nachos系统平台的底层源代码，达到“扩展调度算法”的目标。本次实验主要是要理解Timer、Scheduler和Interrupt之间的关系，从而理解线程之间是如何进行调度的。</p><h2 id="内容二：任务完成情况"><a href="#内容二：任务完成情况" class="headerlink" title="内容二：任务完成情况"></a>内容二：任务完成情况</h2><h3 id="任务完成列表（Y-N）"><a href="#任务完成列表（Y-N）" class="headerlink" title="任务完成列表（Y/N）"></a>任务完成列表（Y/N）</h3><table><thead><tr><th></th><th>Exercise1</th><th>Exercise2</th><th>Exercise3</th><th>Challenge1</th></tr></thead><tbody><tr><td>第一部分</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="具体Exercise的完成情况"><a href="#具体Exercise的完成情况" class="headerlink" title="具体Exercise的完成情况"></a>具体Exercise的完成情况</h3><h4 id="Exercise1-调研"><a href="#Exercise1-调研" class="headerlink" title="Exercise1  调研"></a>Exercise1  调研</h4><p>调研Linux或Windows中采用的进程/线程调度算法。具体内容见课堂要求。</p><ol><li><strong>linux-4.19.23进程调度策略</strong>：<strong>SCHED_OTHER</strong>分时调度策略，<strong>SCHED_FIFO</strong>实时调度策略（先到先服务），<strong>SCHED_RR</strong>实时调度策略（时间片轮转）。<ul><li>RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。</li><li>当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。</li><li>RR进程和FIFO进程都采用实时优先级做为调度的权值标准，RR是FIFO的一个延伸。FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的位置决定的，这样导致一些不公正性(优先级是一样的，为什么要让你一直运行?)，如果将两个优先级一样的任务的调度策略都设为RR，则保证了这两个任务可以循环执行，保证了公平。</li></ul></li></ol><ol start="2"><li><strong>内核代码</strong>：内核为每个cpu维护一个进程就绪队列，cpu只调度由其维护的队列上的进程：</li></ol><p><strong>vi linux-4.19.23/kernel/sched/core.c</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="comment">#define CREATE_TRACE_POINTS</span></span><br><span class="line"><span class="comment">#include &lt;trace/events/sched.h&gt;</span></span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><p>​    <strong>vi linux-4.19.23/kernel/sched/sched.h</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the main, per-CPU runqueue data structure.</span><br><span class="line"> *</span><br><span class="line"> * Locking rule: those places that want to lock multiple runqueues</span><br><span class="line"> * (such as the load balancing or the thread migration code), lock</span><br><span class="line"> * acquire operations must be ordered by ascending &amp;runqueue.</span><br><span class="line"> */</span><br><span class="line">struct rq &#123;</span><br><span class="line">/* runqueue lock: */</span><br><span class="line">raw_spinlock_tlock;// 锁保证互斥访问runqueue</span><br><span class="line">……</span><br><span class="line">struct cfs_rqcfs;// 所有普通进程的集合，采用cfs调度策略</span><br><span class="line">struct rt_rqrt;// 所有实时进程的集合，采用实时调度策略</span><br><span class="line">struct dl_rqdl;// struct dl_rq空闲进程集合</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// cfs_rq就绪队列是一棵红黑树。</span><br><span class="line">/* CFS-related fields <span class="keyword">in</span> a runqueue */</span><br><span class="line">struct cfs_rq &#123;</span><br><span class="line">……</span><br><span class="line">struct rb_root_cachedtasks_timeline;// 红黑树的树根</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * <span class="string">'curr'</span> points to currently running entity on this cfs_rq.</span><br><span class="line"> * It is <span class="built_in">set</span> to NULL otherwise (i.e when none are currently running).</span><br><span class="line"> */</span><br><span class="line">struct sched_entity*curr;// 指向当前正运行的进程</span><br><span class="line">struct sched_entity*next;// 指向将被唤醒的进程</span><br><span class="line">struct sched_entity*last;// 指向唤醒next进程的进程</span><br><span class="line">struct sched_entity*skip;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>​    <strong>vi linux-4.19.23/include/linux/sched.h</strong>：实时进程调度实体<strong>struct sched_rt_entity</strong>，双向链表组织形式；空闲进程调度实体<strong>struct sched_dl_entity</strong>，红黑树组织形式；普通进程的调度实体sched_entity，每个进程描述符中均包含一个该结构体变量，该结构体有两个作用：</p><ol><li>包含有进程调度的信息（比如进程的运行时间，睡眠时间等等，调度程序参考这些信息决定是否调度进程）；</li><li>使用该结构体来组织进程，struct rb_node类型结构体变量run_node是红黑树节点，struct sched_entity调度实体将被组织成红黑树的形式，同时意味着普通进程也被组织成红黑树的形式。parent指向了当前实体的上一级实体，cfs_rq指向了该调度实体所在的就绪队列。my_q指向了本实体拥有的就绪队列（调度组），该调度组（包括组员实体）属于下一个级别，和本实体不在同一个级别，该调度组中所有成员实体的parent域指向了本实体，depth代表了此队列（调度组）的深度，每个调度组都比其parent调度组深度大1。内核依赖my_q域实现组调度。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">// 普通进程的调度实体sched_entity，使用红黑树组织</span><br><span class="line">struct sched_entity &#123;</span><br><span class="line">/* For load-balancing: */</span><br><span class="line">struct load_weightload;</span><br><span class="line">unsigned longrunnable_weight;</span><br><span class="line">struct rb_noderun_node;// 红黑树节点</span><br><span class="line">struct list_headgroup_node;</span><br><span class="line">unsigned inton_rq;</span><br><span class="line">……</span><br><span class="line"><span class="comment">#ifdef CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">intdepth;</span><br><span class="line">struct sched_entity*parent;// 当前节点的父节点</span><br><span class="line">/* rq on <span class="built_in">which</span> this entity is (to be) queued: */</span><br><span class="line">struct cfs_rq*cfs_rq;// 当前节点所在的就绪队列</span><br><span class="line">/* rq <span class="string">"owned"</span> by this entity/group: */</span><br><span class="line">struct cfs_rq*my_q;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实时进程调度实体，采用双向链表组织</span><br><span class="line">struct sched_rt_entity &#123;</span><br><span class="line">struct list_headrun_list;// 链表组织</span><br><span class="line">unsigned longtimeout;</span><br><span class="line">unsigned longwatchdog_stamp;</span><br><span class="line">unsigned inttime_slice;</span><br><span class="line">unsigned shorton_rq;</span><br><span class="line">unsigned shorton_list;</span><br><span class="line"></span><br><span class="line">struct sched_rt_entity*back;</span><br><span class="line"><span class="comment">#ifdef CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">struct sched_rt_entity*parent;</span><br><span class="line">/* rq on <span class="built_in">which</span> this entity is (to be) queued: */</span><br><span class="line">struct rt_rq*rt_rq;// 当前节点所在的就绪队列</span><br><span class="line">/* rq <span class="string">"owned"</span> by this entity/group: */</span><br><span class="line">struct rt_rq*my_q;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line">// 空闲进程调度实体，采用红黑树组织</span><br><span class="line">struct sched_dl_entity &#123;</span><br><span class="line">struct rb_noderb_node;</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>​    <strong>vi linux-4.19.23/kernel/sched/sched.h</strong>：内核声明了一个调度类sched_class的结构体类型，用来实现不同的调度策略，可以看到该结构体成员都是函数指针，这些指针指向的函数就是调度策略的具体实现，所有和进程调度有关的函数都直接或者间接调用了这些成员函数，来实现进程调度。此外，每个进程描述符中都包含一个指向该结构体类型的指针sched_class，指向了所采用的调度类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">struct sched_class &#123;</span><br><span class="line">const struct sched_class *next;</span><br><span class="line"></span><br><span class="line">void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);</span><br><span class="line">void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);</span><br><span class="line">void (*yield_task)   (struct rq *rq);</span><br><span class="line">bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt);</span><br><span class="line"></span><br><span class="line">void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="Exercise2-源代码阅读"><a href="#Exercise2-源代码阅读" class="headerlink" title="Exercise2 源代码阅读"></a>Exercise2 源代码阅读</h4><p><strong>code/threads/scheduler.h和code/threads/scheduler.cc</strong>：scheduler类是nachos中的进程调度器，维护了一个挂起的中断队列，通过FIFO进行调度。</p><ul><li>void ReadyToRun(Thread* thread)；设置线程状态为READY，并放入就绪队列readyList。</li><li>Thread* FindNextToRun(int source); 从就绪队列中取出下一个上CPU的线程，实现基于优先级的抢占式调度和FIFO调度。</li><li>void Run(Thread* nextThread); 把下CPU的线程的寄存器和堆栈信息从CPU保存到线程本身的寄存器数据结构中， 执行线程切换，把上CPU的线程的寄存器和堆栈信息从线程本身的寄存器中拷贝到CPU的寄存器中，运行新线程。</li></ul><p><strong>code/threads/switch.s</strong>：switch.s模拟内容是汇编代码，负责CPU上进程的切换。切换过程中，首先保存当前进程的状态，然后恢复新运行进程的状态，之后切换到新进程的栈空间，开始运行新进程。</p><p><strong>code/machine/timer.h和code/machine/timer.cc</strong>：Timer类用以模拟硬件的时间中断。在TimerExired中，会调用TimeOfNextInterrupt，计算出下次时间中断的时间，并将中断插入中断队列中。初始化时会调用TimerExired，然后每次中断处理函数中都会调用一次TimerExired，从而时间系统时间一步步向前走。需要说明的是，在运行nachos时加入-rs选项，会初始化一个随机中断的Timer。当然你也可以自己声明一个非随机的Timer，每隔固定的时间片执行中断。时间片大小的定义位于ststs.h中，每次开关中断会调用OneTick()，当Ticks数目达到时间片大小时，会出发一次时钟中断。</p><h4 id="Exercise3-线程调度算法扩展"><a href="#Exercise3-线程调度算法扩展" class="headerlink" title="Exercise3 线程调度算法扩展"></a>Exercise3 <strong>线程调度算法扩展</strong></h4><p>扩展线程调度算法，实现基于优先级的抢占式调度算法。</p><p><strong>思路</strong>：更改Thread类，加入priority成员变量，同时更改初始化函数对其初始化，并完成对应的set和get函数。scheduler中的FindNextToRun负责找到下一个运行的进程，默认是FIFO，找到队列最开始时的线程返回。我们现在要实现的是根据优先级来返回，仅需将插入readyList队列的方法按照优先级从高到低顺序插入SortedInsert，那么插入时会维护队列中的Thread按照优先级排序，每次依旧从头取出第一个，即为优先级最高的队列。抢占式调度则需要在每次中断发生时尝试进行进程切换，如果有优先级更高的进程，则运行高优先级进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">// 基于优先级的可抢占式调度策略和FIFO调度策略</span><br><span class="line">Thread * Scheduler::FindNextToRun (bool bySleep)</span><br><span class="line">&#123;</span><br><span class="line">// called by threadsleep，直接调度，不用判断时间片</span><br><span class="line">  <span class="keyword">if</span>(bySleep)&#123; </span><br><span class="line">    lastSwitchTick = stats-&gt;systemTicks;</span><br><span class="line">    <span class="built_in">return</span> (Thread *)readyList-&gt;SortedRemove(NULL);  // 与Remove()等价，都是从队头取</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    int ticks = stats-&gt;systemTicks - lastSwitchTick;</span><br><span class="line">    </span><br><span class="line">    // 这里设置了运行的最短时间TimerSlice，防止频繁切换消耗CPU资源</span><br><span class="line">    // 测试优先级抢占调度时需要屏蔽这句，因为调用Yield()的线程运行时间很短</span><br><span class="line">    // 会直接返回NULL</span><br><span class="line">    /*<span class="keyword">if</span>(ticks &lt; TimerSlice)&#123;</span><br><span class="line">    // 不用切换</span><br><span class="line">    <span class="built_in">return</span> NULL; </span><br><span class="line">    &#125;<span class="keyword">else</span>*/&#123;</span><br><span class="line">      <span class="keyword">if</span>(readyList-&gt;IsEmpty())&#123;</span><br><span class="line">      <span class="built_in">return</span> NULL;</span><br><span class="line">      &#125;</span><br><span class="line">      Thread * next = (Thread *)readyList-&gt;SortedRemove(NULL);</span><br><span class="line">// 基于优先级可抢占调度策略,自己添加的宏，Makefile编译添加： -DSCHED_PRIORITY</span><br><span class="line"><span class="comment">#ifdef SCHED_PRIORITY  </span></span><br><span class="line">      // nextThread优先级高于当前线程则切换，否则不切换</span><br><span class="line">      <span class="keyword">if</span>(next-&gt;getPriority() &lt; currentThread-&gt;getPriority())&#123;</span><br><span class="line">      lastSwitchTick = stats-&gt;systemTicks;</span><br><span class="line">      <span class="built_in">return</span> next;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        readyList-&gt;SortedInsert(next, next-&gt;getPriority());</span><br><span class="line">        <span class="built_in">return</span> NULL;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">#else// FIFO策略需要取消Makefile编译选项：-DSCHED_PRIORITY</span></span><br><span class="line">      lastSwitchTick = stats-&gt;systemTicks;</span><br><span class="line">      <span class="built_in">return</span> next;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程主动让出cpu,在FIFO调度策略下能够看到多个线程按顺序运行</span><br><span class="line">void SimpleThread(int <span class="built_in">which</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (int num = 0; num &lt; 5; num++) &#123;</span><br><span class="line">    int ticks = stats-&gt;systemTicks - scheduler-&gt;getLastSwitchTick();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"userId=%d,threadId=%d,prio=%d,loop:%d,lastSwitchTick=%d,systemTicks=%d,usedTicks=%d,TimerSlice=%d\n"</span>,currentThread-&gt;getUserId(),currentThread-&gt;getThreadId(),currentThread-&gt;getPriority(),num,scheduler-&gt;getLastSwitchTick(),stats-&gt;systemTicks,ticks,TimerSlice);</span><br><span class="line">    // 时间片轮转算法，判断时间片是否用完，</span><br><span class="line">    // 如果用完主动让出cpu，针对nachos内核线程算法</span><br><span class="line">    /*<span class="keyword">if</span>(ticks &gt;= TimerSlice)&#123; </span><br><span class="line">    //<span class="built_in">printf</span>(<span class="string">"threadId=%d Yield\n"</span>,currentThread-&gt;getThreadId());</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    // 非抢占模式下，多个线程同时执行该接口的话，会交替执行，交替让出cpu</span><br><span class="line">    // 基于优先级抢占模式下，优先级高的线程运行结束后才调度低优先级线程</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">threadtest.cc:</span><br><span class="line">// 创建四个线程，加上主线程共五个，优先值越小优先级越高</span><br><span class="line">void ThreadPriorityTest()</span><br><span class="line">&#123;</span><br><span class="line">    Thread* t1 = new Thread(<span class="string">"forkThread1"</span>, 1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t1-&gt;getName(),t1-&gt;getThreadId());</span><br><span class="line">    t1-&gt;Fork(SimpleThread, (void*)1);</span><br><span class="line">    </span><br><span class="line">    Thread* t2 = new Thread(<span class="string">"forkThread2"</span>, 2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t2-&gt;getName(),t2-&gt;getThreadId());</span><br><span class="line">    t2-&gt;Fork(SimpleThread, (void*)2);</span><br><span class="line">    </span><br><span class="line">    Thread* t3 = new Thread(<span class="string">"forkThread3"</span>, 3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t3-&gt;getName(),t3-&gt;getThreadId());</span><br><span class="line">    t3-&gt;Fork(SimpleThread, (void*)3);</span><br><span class="line">    </span><br><span class="line">    Thread* t4 = new Thread(<span class="string">"forkThread4"</span>, 4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t4-&gt;getName(),t4-&gt;getThreadId());</span><br><span class="line">    t4-&gt;Fork(SimpleThread, (void*)4);</span><br><span class="line">    </span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    SimpleThread(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果，优先级1最高，最先执行完，其次是优先为2的线程，直到所有线程结束</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -q 3</span></span><br><span class="line">--&gt;name=forkThread1,threadId=1</span><br><span class="line">--&gt;name=forkThread2,threadId=2</span><br><span class="line">--&gt;name=forkThread3,threadId=3</span><br><span class="line">--&gt;name=forkThread4,threadId=4</span><br><span class="line">userId=0,threadId=1,prio=1,loop:0,lastSwitchTick=50,systemTicks=60,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=1,loop:1,lastSwitchTick=50,systemTicks=70,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=1,loop:2,lastSwitchTick=50,systemTicks=80,usedTicks=30,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=1,loop:3,lastSwitchTick=50,systemTicks=90,usedTicks=40,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=1,loop:4,lastSwitchTick=50,systemTicks=100,usedTicks=50,TimerSlice=30</span><br><span class="line">userId=0,threadId=2,prio=2,loop:0,lastSwitchTick=110,systemTicks=120,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=2,prio=2,loop:1,lastSwitchTick=110,systemTicks=130,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=2,prio=2,loop:2,lastSwitchTick=110,systemTicks=140,usedTicks=30,TimerSlice=30</span><br><span class="line">userId=0,threadId=2,prio=2,loop:3,lastSwitchTick=110,systemTicks=150,usedTicks=40,TimerSlice=30</span><br><span class="line">userId=0,threadId=2,prio=2,loop:4,lastSwitchTick=110,systemTicks=160,usedTicks=50,TimerSlice=30</span><br><span class="line">userId=0,threadId=3,prio=3,loop:0,lastSwitchTick=170,systemTicks=180,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=3,prio=3,loop:1,lastSwitchTick=170,systemTicks=190,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=3,prio=3,loop:2,lastSwitchTick=170,systemTicks=200,usedTicks=30,TimerSlice=30</span><br><span class="line">userId=0,threadId=3,prio=3,loop:3,lastSwitchTick=170,systemTicks=210,usedTicks=40,TimerSlice=30</span><br><span class="line">userId=0,threadId=3,prio=3,loop:4,lastSwitchTick=170,systemTicks=220,usedTicks=50,TimerSlice=30</span><br><span class="line">userId=0,threadId=4,prio=4,loop:0,lastSwitchTick=230,systemTicks=240,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=4,prio=4,loop:1,lastSwitchTick=230,systemTicks=250,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=4,prio=4,loop:2,lastSwitchTick=230,systemTicks=260,usedTicks=30,TimerSlice=30</span><br><span class="line">userId=0,threadId=4,prio=4,loop:3,lastSwitchTick=230,systemTicks=270,usedTicks=40,TimerSlice=30</span><br><span class="line">userId=0,threadId=4,prio=4,loop:4,lastSwitchTick=230,systemTicks=280,usedTicks=50,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=6,loop:0,lastSwitchTick=290,systemTicks=300,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=6,loop:1,lastSwitchTick=290,systemTicks=310,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=6,loop:2,lastSwitchTick=290,systemTicks=320,usedTicks=30,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=6,loop:3,lastSwitchTick=290,systemTicks=330,usedTicks=40,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=6,loop:4,lastSwitchTick=290,systemTicks=340,usedTicks=50,TimerSlice=30</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 350, idle 0, system 350, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h4 id="Challenge-线程调度算法扩展（至少实现一种算法）"><a href="#Challenge-线程调度算法扩展（至少实现一种算法）" class="headerlink" title="Challenge 线程调度算法扩展（至少实现一种算法）"></a>Challenge <strong>线程调度算法扩展</strong>（至少实现一种算法）</h4><p>可实现“时间片轮转算法”、“多级队列反馈调度算法”，或将Linux或Windows采用的调度算法应用到Nachos上。</p><p><strong>思路：</strong>nachos启动时在system.cc中会new一个timer类，每隔一个TimerTicks大小触发时钟中断，从而让时钟向前走，时间片的大下定义在stats.h中。同时在stats.h中定义一个时间片大小变量TimerSlice，每个线程运行时间只要大于等于TimerSlice，立即放弃CPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">stats.h：</span><br><span class="line">……</span><br><span class="line">// nachos执行每条用户指令的时间为1Tick</span><br><span class="line"><span class="comment">#define UserTick 1</span></span><br><span class="line">// 系统态无法进行指令计算，</span><br><span class="line">// 所以nachos系统态的一次中断调用或其他需要进行时间计算的单位设置为10Tick</span><br><span class="line"><span class="comment">#define SystemTick 10</span></span><br><span class="line"></span><br><span class="line">// 磁头寻找超过一个扇区的时间</span><br><span class="line"><span class="comment">#define RotationTime 500</span></span><br><span class="line"></span><br><span class="line">// 磁头寻找超过一个磁道的时间</span><br><span class="line"><span class="comment">#define SeekTime500</span></span><br><span class="line"><span class="comment">#define ConsoleTime 100// time to read or write one character</span></span><br><span class="line"><span class="comment">#define NetworkTime 100// time to send or receive one packet</span></span><br><span class="line"></span><br><span class="line">// 时钟中断间隔</span><br><span class="line"><span class="comment">#define TimerTicks5// (average) time between timer interrupts</span></span><br><span class="line"></span><br><span class="line">// 时间片轮转算法一个时间片大小</span><br><span class="line"><span class="comment">#define TimerSlice10</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">threadtest.cc:</span><br><span class="line">void SimpleThread(int <span class="built_in">which</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (int num = 0; num &lt; 5; num++) &#123;</span><br><span class="line">    int ticks = stats-&gt;systemTicks - scheduler-&gt;getLastSwitchTick();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"userId=%d,threadId=%d,prio=%d,loop:%d,lastSwitchTick=%d,systemTicks=%d,usedTicks=%d,TimerSlice=%d\n"</span>,currentThread-&gt;getUserId(),currentThread-&gt;getThreadId(),currentThread-&gt;getPriority(),num,scheduler-&gt;getLastSwitchTick(),stats-&gt;systemTicks,ticks,TimerSlice);</span><br><span class="line">    // 时间片轮转算法，判断时间片是否用完</span><br><span class="line">    // 如果用完主动让出cpu，针对nachos内核线程算法</span><br><span class="line">    <span class="keyword">if</span>(ticks &gt;= TimerSlice)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"threadId=%d Yield\n"</span>,currentThread-&gt;getThreadId());</span><br><span class="line">      currentThread-&gt;Yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 非抢占模式下，多个线程同时执行该接口的话，会交替执行，交替让出cpu</span><br><span class="line">    // currentThread-&gt;Yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">threadtest.cc:</span><br><span class="line">// 创建四个线程，加上主线程共五个，时间片轮转调度策略，不可抢占</span><br><span class="line">void ThreadPriorityTest()</span><br><span class="line">&#123;</span><br><span class="line">    Thread* t1 = new Thread(<span class="string">"forkThread1"</span>, 1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t1-&gt;getName(),t1-&gt;getThreadId());</span><br><span class="line">    t1-&gt;Fork(SimpleThread, (void*)1);</span><br><span class="line">    </span><br><span class="line">    Thread* t2 = new Thread(<span class="string">"forkThread2"</span>, 2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t2-&gt;getName(),t2-&gt;getThreadId());</span><br><span class="line">    t2-&gt;Fork(SimpleThread, (void*)2);</span><br><span class="line">    </span><br><span class="line">    Thread* t3 = new Thread(<span class="string">"forkThread3"</span>, 3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t3-&gt;getName(),t3-&gt;getThreadId());</span><br><span class="line">    t3-&gt;Fork(SimpleThread, (void*)3);</span><br><span class="line">    </span><br><span class="line">    Thread* t4 = new Thread(<span class="string">"forkThread4"</span>, 4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--&gt;name=%s,threadId=%d\n"</span>,t4-&gt;getName(),t4-&gt;getThreadId());</span><br><span class="line">    t4-&gt;Fork(SimpleThread, (void*)4);</span><br><span class="line">    </span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    SimpleThread(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果，可看到usedTicks &gt;= TimserSlice时都让出cpu</span><br><span class="line">// 并且线程执行顺序为1 2 3 4 0，直到结束</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment"># ./nachos -q 3</span></span><br><span class="line">--&gt;name=forkThread1,threadId=1</span><br><span class="line">--&gt;name=forkThread2,threadId=2</span><br><span class="line">--&gt;name=forkThread3,threadId=3</span><br><span class="line">--&gt;name=forkThread4,threadId=4</span><br><span class="line">userId=0,threadId=1,prio=1,loop:0,lastSwitchTick=50,systemTicks=60,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=1 Yield</span><br><span class="line">userId=0,threadId=2,prio=2,loop:0,lastSwitchTick=60,systemTicks=70,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=2 Yield</span><br><span class="line">userId=0,threadId=3,prio=3,loop:0,lastSwitchTick=70,systemTicks=80,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=3 Yield</span><br><span class="line">userId=0,threadId=4,prio=4,loop:0,lastSwitchTick=80,systemTicks=90,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=4 Yield</span><br><span class="line">userId=0,threadId=0,prio=6,loop:0,lastSwitchTick=90,systemTicks=100,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=0 Yield</span><br><span class="line">userId=0,threadId=1,prio=1,loop:1,lastSwitchTick=100,systemTicks=110,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=1 Yield</span><br><span class="line">userId=0,threadId=2,prio=2,loop:1,lastSwitchTick=110,systemTicks=120,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=2 Yield</span><br><span class="line">userId=0,threadId=3,prio=3,loop:1,lastSwitchTick=120,systemTicks=130,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=3 Yield</span><br><span class="line">userId=0,threadId=4,prio=4,loop:1,lastSwitchTick=130,systemTicks=140,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=4 Yield</span><br><span class="line">userId=0,threadId=0,prio=6,loop:1,lastSwitchTick=140,systemTicks=150,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=0 Yield</span><br><span class="line">userId=0,threadId=1,prio=1,loop:2,lastSwitchTick=150,systemTicks=160,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=1 Yield</span><br><span class="line">userId=0,threadId=2,prio=2,loop:2,lastSwitchTick=160,systemTicks=170,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=2 Yield</span><br><span class="line">userId=0,threadId=3,prio=3,loop:2,lastSwitchTick=170,systemTicks=180,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=3 Yield</span><br><span class="line">userId=0,threadId=4,prio=4,loop:2,lastSwitchTick=180,systemTicks=190,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=4 Yield</span><br><span class="line">userId=0,threadId=0,prio=6,loop:2,lastSwitchTick=190,systemTicks=200,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=0 Yield</span><br><span class="line">userId=0,threadId=1,prio=1,loop:3,lastSwitchTick=200,systemTicks=210,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=1 Yield</span><br><span class="line">userId=0,threadId=2,prio=2,loop:3,lastSwitchTick=210,systemTicks=220,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=2 Yield</span><br><span class="line">userId=0,threadId=3,prio=3,loop:3,lastSwitchTick=220,systemTicks=230,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=3 Yield</span><br><span class="line">userId=0,threadId=4,prio=4,loop:3,lastSwitchTick=230,systemTicks=240,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=4 Yield</span><br><span class="line">userId=0,threadId=0,prio=6,loop:3,lastSwitchTick=240,systemTicks=250,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=0 Yield</span><br><span class="line">userId=0,threadId=1,prio=1,loop:4,lastSwitchTick=250,systemTicks=260,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=1 Yield</span><br><span class="line">userId=0,threadId=2,prio=2,loop:4,lastSwitchTick=260,systemTicks=270,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=2 Yield</span><br><span class="line">userId=0,threadId=3,prio=3,loop:4,lastSwitchTick=270,systemTicks=280,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=3 Yield</span><br><span class="line">userId=0,threadId=4,prio=4,loop:4,lastSwitchTick=280,systemTicks=290,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=4 Yield</span><br><span class="line">userId=0,threadId=0,prio=6,loop:4,lastSwitchTick=290,systemTicks=300,usedTicks=10,TimerSlice=10</span><br><span class="line">threadId=0 Yield</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 350, idle 0, system 350, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4-Lab/nachos-3.4/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="内容三：遇到的困难以及解决方法"><a href="#内容三：遇到的困难以及解决方法" class="headerlink" title="内容三：遇到的困难以及解决方法"></a>内容三：遇到的困难以及解决方法</h2><h3 id="困难1"><a href="#困难1" class="headerlink" title="困难1"></a>困难1</h3><p>切换线程过程中，产生段错误，通过定位，误把销毁的线程挂入就绪对了所致。</p><h2 id="内容四：收获及感想"><a href="#内容四：收获及感想" class="headerlink" title="内容四：收获及感想"></a>内容四：收获及感想</h2><p>自己动手实现后，发现时间片轮转算法，线程调度，FIFO，时钟中断等其实并不陌生。一切只要你不懒和肯付出实际行动的难题都是纸老虎。</p><h2 id="内容五：对课程的意见和建议"><a href="#内容五：对课程的意见和建议" class="headerlink" title="内容五：对课程的意见和建议"></a>内容五：对课程的意见和建议</h2><p>暂无。</p><h2 id="内容六：参考文献"><a href="#内容六：参考文献" class="headerlink" title="内容六：参考文献"></a>内容六：参考文献</h2><p>暂无。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/icoty/nachos-3.4-Lab&quot; rel=&quot;externa
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="时间片轮转调度策略" scheme="https://icoty.github.io/tags/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    
      <category term="FIFO线程调度策略" scheme="https://icoty.github.io/tags/FIFO%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    
      <category term="基于优先级的可抢占式调度策略" scheme="https://icoty.github.io/tags/%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%8F%AF%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    
      <category term="Nachos-3.4" scheme="https://icoty.github.io/tags/Nachos-3-4/"/>
    
  </entry>
  
  <entry>
    <title>Nachos-Lab1-完善线程机制</title>
    <link href="https://icoty.github.io/2019/05/13/nachos-3-4-Lab1/"/>
    <id>https://icoty.github.io/2019/05/13/nachos-3-4-Lab1/</id>
    <published>2019-05-13T05:20:11.000Z</published>
    <updated>2019-05-23T00:03:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nachos是什么"><a href="#Nachos是什么" class="headerlink" title="Nachos是什么"></a>Nachos是什么</h2><p>Nachos (Not Another Completely Heuristic Operating System)，是一个教学用操作系统，提供了操作系统框架： </p><ol><li>线程</li><li>中断</li><li>虚拟内存（位图管理所有物理页，虚拟地址与物理地址之间的转换等）</li><li>同步与互斥机制（锁、条件变量、信号量），读者写者问题，生产者消费者问题，BARRIER问题等</li><li>线程调度（基于优先级可抢占式调度，时间片轮转算法，FIFO调度）</li><li>文件系统</li><li>系统调用</li><li>机器指令、汇编指令、寄存器<br>……<br>Nachos模拟了一个MIPS模拟器，运行用户程序。</li></ol><p><img src="/2019/05/13/nachos-3-4-Lab1/structure.png" alt="structure"></p><p><img src="/2019/05/13/nachos-3-4-Lab1/runlogical.png" alt="structure"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── gnu-decstation-ultrix// 交叉编译工具链</span><br><span class="line">├── nachos-3.4.zip// 未经任何修改的源码和交叉编译工具，实验就是修改源码完善各个模块的功能</span><br><span class="line">├── README</span><br><span class="line">└── nachos-3.4// 实验过程中完善的代码</span><br><span class="line">  ├── <span class="built_in">test</span>// 该目录下编写用户自己的程序，需要修改Makfile添加自己的文件</span><br><span class="line">  ├── bin// 用户自己的程序需要利用coff2noff转换，才能在nachos下跑起来</span><br><span class="line">  ├── filesys// 文件系统管理</span><br><span class="line">  │   ├── directory.cc// 目录文件，由目录项组成，目录项里记录了文件头所在扇区号</span><br><span class="line">  │   ├── directory.h</span><br><span class="line">  │   ├── filehdr.cc</span><br><span class="line">  │   ├── filehdr.h// 文件头数据结构，通过索引记录了文件内容实际存储的所有扇区号</span><br><span class="line">  │   ├── filesys.cc// 文件系统数据结构，创建/删除/读/写/修改/重命名/打开/关别等接口</span><br><span class="line">  │   ├── filesys.h</span><br><span class="line">  │   ├── fstest.cc</span><br><span class="line">  │   ├── Makefile</span><br><span class="line">  │   ├── openfile.cc// 管理所有打开的文件句柄</span><br><span class="line">  │   ├── openfile.h</span><br><span class="line">  │   ├── synchdisk.cc// 同步磁盘类，加锁保证互斥和文件系统的一致性</span><br><span class="line">  │   ├── synchdisk.h</span><br><span class="line">  │   └── <span class="built_in">test</span></span><br><span class="line">  ├── machine// 机器硬件模拟</span><br><span class="line">  │   ├── console.cc// 终端</span><br><span class="line">  │   ├── console.h</span><br><span class="line">  │   ├── disk.cc// 磁盘</span><br><span class="line">  │   ├── disk.h</span><br><span class="line">  │   ├── interrupt.cc// 中断处理器，利用FIFO维护一个中断队列</span><br><span class="line">  │   ├── interrupt.h</span><br><span class="line">  │   ├── timer.cc// 模拟硬件时钟，用于时钟中断</span><br><span class="line">  │   ├── timer.h</span><br><span class="line">  │   ├── translate.cc// 用户程序空间虚拟地址和物理之间的转换类</span><br><span class="line">  │   └── translate.h</span><br><span class="line">  ├── network// 网络系统管理</span><br><span class="line">  │   ├── Makefile</span><br><span class="line">  │   ├── nettest.cc</span><br><span class="line">  │   ├── post.cc</span><br><span class="line">  │   ├── post.h</span><br><span class="line">  │   └── README</span><br><span class="line">  ├── threads// 内核线程管理</span><br><span class="line">  │   ├── list.cc// 工具模块 定义了链表结构及其操作</span><br><span class="line">  │   ├── list.h</span><br><span class="line">  │   ├── main.cc// main入口，可以传入argv参数</span><br><span class="line">  │   ├── Makefile</span><br><span class="line">  │   ├── scheduler.cc// 调度器，维护一个就绪的线程队列，时间片轮转/FIFO/优先级抢占</span><br><span class="line">  │   ├── scheduler.h</span><br><span class="line">  │   ├── stdarg.h</span><br><span class="line">  │   ├── switch.c// 线程启动和调度模块</span><br><span class="line">  │   ├── switch.h</span><br><span class="line">  │   ├── switch-old.s</span><br><span class="line">  │   ├── switch.s// 线程切换</span><br><span class="line">  │   ├── synch.cc// 同步与互斥，锁/信号量/条件变量</span><br><span class="line">  │   ├── synch.dis</span><br><span class="line">  │   ├── synch.h</span><br><span class="line">  │   ├── synchlist.cc// 类似于一个消息队列</span><br><span class="line">  │   ├── synchlist.h</span><br><span class="line">  │   ├── system.cc// 主控模块</span><br><span class="line">  │   ├── system.h</span><br><span class="line">  │   ├── thread.cc// 线程数据结构</span><br><span class="line">  │   ├── thread.h</span><br><span class="line">  │   ├── threadtest.cc</span><br><span class="line">  │   ├── utility.cc</span><br><span class="line">  │   └── utility.h</span><br><span class="line">  ├── userprog// 用户进程管理</span><br><span class="line">  │   ├── addrspace.cc// 为noff文件的代码段/数据段分配空间，虚拟地址空间</span><br><span class="line">  │   ├── addrspace.h</span><br><span class="line">  │   ├── bitmap.cc// 位图，用于管理扇区的分配和物理地址的分配</span><br><span class="line">  │   ├── bitmap.h</span><br><span class="line">  │   ├── exception.cc// 异常处理</span><br><span class="line">  │   ├── Makefile</span><br><span class="line">  │   ├── progtest.cc// 测试nachos是否可执行用户程序</span><br><span class="line">  │   └── syscall.h// 系统调用</span><br><span class="line">  └── vm// 虚拟内存管理</span><br><span class="line">  └── Makefile// 多线程编译: make -j4</span><br><span class="line">  └── Makefile.common// 各个模块公共的Makefile内容存放到这里面</span><br><span class="line">  └── Makefile.dep// 依赖</span><br></pre></td></tr></table></figure><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>选择Linux或Unix系统，安装32位GCC开发环境，安装32的ubuntu。</p><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p><a href="https://github.com/icoty/nachos-3.4-Lab" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/icoty/nachos-3.4-Lab</a></p><h2 id="内容一：总体概述"><a href="#内容一：总体概述" class="headerlink" title="内容一：总体概述"></a>内容一：总体概述</h2><p>本次Lab针对的内容是实现线程机制最基本的数据结构——进程控制块（PCB）。当一个进程创建时必然会生成一个相应的进程控制块，记录一些该线程特征，如进程ID、进程状态、进程优先级，进程开始运行时间，在cpu上已经运行了多少时间，程序计数器，SP指针，根目录和当前目录指针，文件描述符表，用户ID，组ID，指向代码段、数据段和栈段的指针等（当然，Nachos简化了进程控制块的内容）。实验的主要内容是修改和扩充PCB，主要难点在于发现修改PCB影响到的文件并进行修改。PCB是系统感知进程存在的唯一标志，且进程与PCB一一对应。可将PCB内部信息划分为：进程描述信息，进程控制信息，进程占有的资源和使用情况，进程的cpu现场。扩展字段如下：</p><p><img src="/2019/05/13/nachos-3-4-Lab1/pcb.png" alt="structure"></p><h2 id="内容二：任务完成情况"><a href="#内容二：任务完成情况" class="headerlink" title="内容二：任务完成情况"></a>内容二：任务完成情况</h2><h3 id="任务完成列表（Y-N）"><a href="#任务完成列表（Y-N）" class="headerlink" title="任务完成列表（Y/N）"></a>任务完成列表（Y/N）</h3><table><thead><tr><th></th><th>Exercise1</th><th>Exercise2</th><th>Exercise3</th><th>Exercise4</th></tr></thead><tbody><tr><td>第一部分</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="具体Exercise的完成情况"><a href="#具体Exercise的完成情况" class="headerlink" title="具体Exercise的完成情况"></a>具体Exercise的完成情况</h3><h4 id="Exercise1-调研"><a href="#Exercise1-调研" class="headerlink" title="Exercise1  调研"></a>Exercise1  调研</h4><p>调研Linux或Windows中进程控制块（PCB）的基本实现方式，理解与Nachos的异同。</p><p><strong>linux-4.19.23调研</strong>：Linux中的每一个进程由一个task_struct数据结构来描述。task_struct也就是PCB的数据结构。task_struct容纳了一个进程的所有信息，linux内核代码中的task_struct在linux-4.19.23/include/linux/sched.h内。</p><p><strong>Linux内核进程状态</strong>：如下可分为运行态，可中断和不可中断态，暂停态，终止态，僵死状态，挂起状态等。</p><p><strong>Linux内核进程调度</strong>：sched_info数据结构，包括被调度次数，等待时间，最后一次调度时间。<br><strong>vi linux-4.19.23/include/linux/sched.h</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">/* Used <span class="keyword">in</span> tsk-&gt;state: */</span><br><span class="line"><span class="comment">#define TASK_RUNNING0x0000// 运行态</span></span><br><span class="line"><span class="comment">#define TASK_INTERRUPTIBLE0x0001// 可中断</span></span><br><span class="line"><span class="comment">#define TASK_UNINTERRUPTIBLE0x0002// 不可中断</span></span><br><span class="line"><span class="comment">#define __TASK_STOPPED0x0004</span></span><br><span class="line"><span class="comment">#define __TASK_TRACED0x0008</span></span><br><span class="line">/* Used <span class="keyword">in</span> tsk-&gt;exit_state: */</span><br><span class="line"><span class="comment">#define EXIT_DEAD0x0010</span></span><br><span class="line"><span class="comment">#define EXIT_ZOMBIE0x0020// 僵死态</span></span><br><span class="line"><span class="comment">#define EXIT_TRACE(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line">/* Used <span class="keyword">in</span> tsk-&gt;state again: */</span><br><span class="line"><span class="comment">#define TASK_PARKED0x0040</span></span><br><span class="line"><span class="comment">#define TASK_DEAD0x0080</span></span><br><span class="line"><span class="comment">#define TASK_WAKEKILL0x0100</span></span><br><span class="line"><span class="comment">#define TASK_WAKING0x0200</span></span><br><span class="line"><span class="comment">#define TASK_NOLOAD0x0400</span></span><br><span class="line"><span class="comment">#define TASK_NEW0x0800</span></span><br><span class="line"><span class="comment">#define TASK_STATE_MAX0x1000</span></span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">struct sched_info &#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_SCHED_INFO</span></span><br><span class="line">/* Cumulative counters: */</span><br><span class="line"></span><br><span class="line">/* <span class="comment"># of times we have run on this CPU: */</span></span><br><span class="line">unsigned longpcount;</span><br><span class="line"></span><br><span class="line">/* Time spent waiting on a runqueue: */</span><br><span class="line">unsigned long longrun_delay;</span><br><span class="line"></span><br><span class="line">/* Timestamps: */</span><br><span class="line"></span><br><span class="line">/* When did we last run on a CPU? */</span><br><span class="line">unsigned long longlast_arrival;</span><br><span class="line"></span><br><span class="line">/* When were we last queued to run? */</span><br><span class="line">unsigned long longlast_queued;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif /* CONFIG_SCHED_INFO */</span></span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p><strong>时钟与锁</strong>：内核需要记录进程在其生存期内使用CPU的时间以便于统计、计费等有关操作。进程耗费CPU的时间由两部分组成：一是在用户态下耗费的时间，一是在系统态下耗费的时间。这类信息还包括进程剩余的时间片和定时器信息等，以控制相应事件的触发。</p><p><strong>文件系统信息</strong>：进程可以打开或关闭文件，文件属于系统资源，Linux内核要对进程使用文件的情况进行记录。</p><p><strong>虚拟内存信息</strong>：除了内核线程，每个进程都拥有自己的地址空间，Linux内核中用mm_struct结构来描述。</p><p><strong>物理页管理信息</strong>：当物理内存不足时，Linux内存管理子系统需要把内存中部分页面交换到外存，并将产生PageFault的地址所在的页面调入内存，交换以页为单位。这部分结构记录了交换所用到的信息。</p><p><strong>多处理器信息</strong>：与多处理器相关的几个域，每个处理器都维护了自己的一个进程调度队列，Linux内核中没有线程的概念，统一视为进程。</p><p><strong>处理器上下文信息</strong>：当进程因等待某种资源而被挂起或停止运行时，处理机的状态必须保存在进程的task_struct，目的就是保存进程的当前上下文。当进程被调度重新运行时再从进程的task_struct中把上下文信息读入CPU（实际是恢复这些寄存器和堆栈的值），然后开始执行。</p><p><strong>与Nachos的异同</strong>：Nachos相对于Linux系统的线程部分来讲，要简单许多。它的PCB仅有几个必须的变量，并且定义了一些最基本的对线程操作的函数。Nachos线程的总数目没有限制，线程的调度比较简单，而且没有实现线程的父子关系。很多地方需要完善。</p><h4 id="Exercise2-源代码阅读"><a href="#Exercise2-源代码阅读" class="headerlink" title="Exercise2 源代码阅读"></a>Exercise2 源代码阅读</h4><p><strong>code/threads/main.cc</strong>：main.cc是整个nachos操作系统启动的入口，通过它可以直接调用操作系统的方法。通过程序中的main函数，配以不同的参数，可以调用Nachos操作系统不同部分的各个方法。 </p><p><strong>code/threads/threadtest.cc</strong>：nachos内核线程测试部分，Fork两个线程，交替调用Yield()主动放弃CPU，执行循环体，会发现线程0和线程1刚好是交替执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  int argCount;// the number of arguments </span><br><span class="line">  DEBUG(<span class="string">'t'</span>, <span class="string">"Entering main"</span>);</span><br><span class="line">  (void) Initialize(argc, argv);</span><br><span class="line"><span class="comment">#ifdef THREADS</span></span><br><span class="line">  <span class="keyword">for</span> (argc--, argv++; argc &gt; 0; argc -= argCount, argv += argCount) &#123;</span><br><span class="line">    argCount = 1;</span><br><span class="line">    switch (argv[0][1]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">        testnum = atoi(argv[1]);</span><br><span class="line">        argCount++;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">        <span class="keyword">if</span>(argv[0][2] == <span class="string">'S'</span>)</span><br><span class="line">        testnum = 3;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      default:</span><br><span class="line">        testnum = 1;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ThreadTest();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">threadtest.cc</span><br><span class="line">// 线程主动让出cpu,在FIFO调度策略下能够看到多个线程按顺序运行</span><br><span class="line">void SimpleThread(int <span class="built_in">which</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (int num = 0; num &lt; 5; num++) &#123;</span><br><span class="line">    int ticks = stats-&gt;systemTicks - scheduler-&gt;getLastSwitchTick();</span><br><span class="line">    // 针对nachos内核线程的时间片轮转算法，判断时间片是否用完，如果用完主动让出cpu</span><br><span class="line">    <span class="keyword">if</span>(ticks &gt;= TimerSlice)&#123;</span><br><span class="line">    currentThread-&gt;Yield();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 多个线程同时执行该接口的话，会交替执行，交替让出cpu</span><br><span class="line">    // currentThread-&gt;Yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4/code/threads<span class="comment"># </span></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4/code/threads<span class="comment"># ./nachos -q 1</span></span><br><span class="line">userId=0,threadId=0,prio=5,loop:0,lastSwitchTick=0,systemTicks=20,usedTicks=20,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=5,loop:0,lastSwitchTick=20,systemTicks=30,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=5,loop:1,lastSwitchTick=30,systemTicks=40,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=5,loop:1,lastSwitchTick=40,systemTicks=50,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=5,loop:2,lastSwitchTick=50,systemTicks=60,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=5,loop:2,lastSwitchTick=60,systemTicks=70,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=5,loop:3,lastSwitchTick=70,systemTicks=80,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=5,loop:3,lastSwitchTick=80,systemTicks=90,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=0,prio=5,loop:4,lastSwitchTick=90,systemTicks=100,usedTicks=10,TimerSlice=30</span><br><span class="line">userId=0,threadId=1,prio=5,loop:4,lastSwitchTick=100,systemTicks=110,usedTicks=10,TimerSlice=30</span><br><span class="line">No threads ready or runnable, and no pending interrupts.</span><br><span class="line">Assuming the program completed.</span><br><span class="line">Machine halting!</span><br><span class="line"></span><br><span class="line">Ticks: total 130, idle 0, system 130, user 0</span><br><span class="line">Disk I/O: reads 0, writes 0</span><br><span class="line">Console I/O: reads 0, writes 0</span><br><span class="line">Paging: faults 0</span><br><span class="line">Network I/O: packets received 0, sent 0</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br></pre></td></tr></table></figure><p><strong>code/threads/thread.h</strong>：这部分定义了管理Thread的数据结构，即Nachos中线程的上下文环境。主要包括当前线程栈顶指针，所有寄存器的状态，栈底，线程状态，线程名。当前栈指针和机器状态的定义必须必须放作为线程成员变量的前两个，因为Nachos执行线程切换时，会按照这个顺序找到线程的起始位置，然后操作线程上下文内存和寄存器。在Thread类中还声明了一些基本的方法，如Fork()、Yield()、Sleep()等等，由于这些方法的作用根据名字已经显而易见了，在此不再赘述。 </p><p><strong>code/threads/thread.cc</strong>： Thread.cc中主要是管理Thread的一些事务。主要接口如下：</p><ul><li>Fork(VoidFunctionPtr func,int arg)：func是新线程运行的函数，arg是func函数的入参，Fork的实现包括分为几步：分配一个堆栈，初始化堆栈，将线程放入就绪队列。</li><li>Finish()：不是直接收回线程的数据结构和堆栈，因为当前仍在这个堆栈上运行这个线程。先将threadToBeDestroyed的值设为当前线程，在Scheduler的Run()内切换到新的线程时在销毁threadToBeDestroyed。Yield()、Sleep()。这里实现的方法大多是都是原子操作，在方法的一开始保存中断层次关闭中断，并在最后恢复原状态。</li><li>Yield()：当前线程放入就绪队列，从scheduler就绪队列中的找到下一个线程上cpu，以达到放弃CPU的效果。</li></ul><h4 id="Exercise3-扩展线程的数据结构"><a href="#Exercise3-扩展线程的数据结构" class="headerlink" title="Exercise3 扩展线程的数据结构"></a>Exercise3 扩展线程的数据结构</h4><h4 id="Exercise4-增加全局线程管理机制"><a href="#Exercise4-增加全局线程管理机制" class="headerlink" title="Exercise4 增加全局线程管理机制"></a>Exercise4 增加全局线程管理机制</h4><p>这里我把Exercise3和Exercise4放在一起完成。</p><ul><li><p>在Thread类中添加私有成员userId和threadId，添加公有接口getUserId()和getThreadId()，userId直接沿用Linux个getuid()接口。</p></li><li><p>system.h内部添加全局变量maxThreadsCount=128，全局数组threads[maxThreadsCount]，每创建一个线程判断并分配threadId。</p></li><li><p><strong>-TS</strong>模仿Linux的PS命令打印所有线程信息，仔细阅读list.cc代码和scheduler.cc的代码，就会发现可以直接用scheduler.cc::Print()接口，不用我们重新造轮子。</p></li><li><p>在system.cc中的void Initialize(<strong>int</strong> argc, <strong>char</strong> argv)函数体对全局数组初始化。如下我用root用户执行分配的userId为0，切换到其他用户userId会发生变化，线程id分别为0和1。当线程数超过128个线程时，ASSERT断言报错。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">threadtest.cc：</span><br><span class="line">void ThreadTest()</span><br><span class="line">&#123;</span><br><span class="line">  switch (testnum) &#123;</span><br><span class="line">    <span class="keyword">case</span> 1:</span><br><span class="line">    ThreadTest1();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 2:</span><br><span class="line">    ThreadCountLimitTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 3:</span><br><span class="line">    ThreadPriorityTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 4:</span><br><span class="line">    ThreadProducerConsumerTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 5:</span><br><span class="line">    ThreadProducerConsumerTest1();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 6:</span><br><span class="line">    barrierThreadTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 7:</span><br><span class="line">    readWriteThreadTest();</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  default:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No test specified.\n"</span>);</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程最多128个，超过128个终止运行</span><br><span class="line">void ThreadCountLimitTest()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (int i = 0; i &lt;= maxThreadsCount; ++i) &#123;</span><br><span class="line">    Thread* t = new Thread(<span class="string">"fork thread"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread name = %s, userId = %d, threadId = %d\n"</span>, t-&gt;getName(), t-&gt;getUserId(), t-&gt;getThreadId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4/code/threads<span class="comment"># ./nachos -TS</span></span><br><span class="line">thread name = fork thread, userId = 0, threadId = 1</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 2</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 3</span><br><span class="line">……</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 122</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 123</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 124</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 125</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 126</span><br><span class="line">thread name = fork thread, userId = 0, threadId = 127</span><br><span class="line">allocatedThreadID fail, maxThreadsCount:[128]</span><br><span class="line">Assertion failed: line 73, file <span class="string">"../threads/thread.cc"</span></span><br><span class="line">Aborted (core dumped)</span><br><span class="line">root@yangyu-ubuntu-32:/mnt/nachos-3.4/code/threads<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="内容三：遇到的困难以及解决方法"><a href="#内容三：遇到的困难以及解决方法" class="headerlink" title="内容三：遇到的困难以及解决方法"></a>内容三：遇到的困难以及解决方法</h2><h3 id="困难1"><a href="#困难1" class="headerlink" title="困难1"></a>困难1</h3><p>开始make编译出错，通过定位到具体行，复制出来手动执行，发现是gcc交叉编译工具链路径不对。</p><h3 id="困难2"><a href="#困难2" class="headerlink" title="困难2"></a>困难2</h3><p>刚开始修改代码验证效果，重定义错误，外部文件全局变量使用方式不对导致。</p><h2 id="内容四：收获及感想"><a href="#内容四：收获及感想" class="headerlink" title="内容四：收获及感想"></a>内容四：收获及感想</h2><p>动手实践很重要，不管你是做什么事、什么项目、什么作业，一定要落实到代码和跑到程序上面来。绝知此事要躬行，学习来不得半点虚假。</p><h2 id="内容五：对课程的意见和建议"><a href="#内容五：对课程的意见和建议" class="headerlink" title="内容五：对课程的意见和建议"></a>内容五：对课程的意见和建议</h2><p>暂无。</p><h2 id="内容六：参考文献"><a href="#内容六：参考文献" class="headerlink" title="内容六：参考文献"></a>内容六：参考文献</h2><p>暂无。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nachos是什么&quot;&gt;&lt;a href=&quot;#Nachos是什么&quot; class=&quot;headerlink&quot; title=&quot;Nachos是什么&quot;&gt;&lt;/a&gt;Nachos是什么&lt;/h2&gt;&lt;p&gt;Nachos (Not Another Completely Heuristic O
      
    
    </summary>
    
      <category term="操作系统" scheme="https://icoty.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Nachos-3.4" scheme="https://icoty.github.io/tags/Nachos-3-4/"/>
    
      <category term="PCB" scheme="https://icoty.github.io/tags/PCB/"/>
    
  </entry>
  
  <entry>
    <title>另类P、V操作问题-详细图解</title>
    <link href="https://icoty.github.io/2019/04/25/stack-pv/"/>
    <id>https://icoty.github.io/2019/04/25/stack-pv/</id>
    <published>2019-04-25T07:06:35.000Z</published>
    <updated>2019-05-31T15:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h3><p>有一个系统，定义如下P、V操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(s)：</span><br><span class="line">s.count--;</span><br><span class="line"><span class="keyword">if</span> s&lt;0 <span class="keyword">then</span></span><br><span class="line">将本进程插入相应队列末尾等待;</span><br><span class="line">  </span><br><span class="line">V(s):</span><br><span class="line">s.count++;</span><br><span class="line"><span class="keyword">if</span> s&lt;=0 <span class="keyword">then</span></span><br><span class="line">从相应等待队列队尾唤醒一个进程，将其插入就绪队列;</span><br></pre></td></tr></table></figure></p><p>思考并回答:<br>a. 这样定义P、V操作是否有问题?<br>b. 试用这样的P、V操作实现N个进程竞争使用某一共享变量的互斥机制。<br>c. 对于b的解法，有无效率更高的方法。如有，试问降低了多少复杂性?</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>a. 当然有问题，假设s=2，现有进程p1、p2按顺序来请求共享资源A，p1和p2直接获取A，假设p1和p2都还未释放A的时候，p3、p4、p5按顺序也来请求A，这时s的等待队列L为：(尾)p5p4p3(头)，然后p1释放A，执行V(s)操作从L队尾唤醒p5，L变为：(尾)p4p3(头)。这时A被p2和p5持有，且p2和p5都未释放A的时候，假设这时p1又来请求A，p1被挂起，L变为：(尾)p1p4p3(头)。然后p2释放A执行V(s)操作从L队尾唤醒p1，你会发现p1又竞争到了A，而p3和p4还一次都未竞争到，这会导致越靠近L队首的p3和p4越容易饿死，出现饥饿现象。问题的根源就在于这样定义的P、V操作，由于在信号量的等待队列上是先进后出导致的，这属于栈P、V。</p><p>b. 解决方案<br>这里以N个进程为例进行一般化分析，定义信号量数组S[N-1]，共有N-1个信号量，下标从0～N-2，其中S[i] = N-i-1，表示第i+1个信号量S[i]的初值为N-i-1，初值为何取这个看后面分析，下为伪码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Semaphore S[N-1];// S[i] = N-i-1</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=0 ; i&lt;n-1 ; i++)</span><br><span class="line">P(S[i]);</span><br><span class="line">// 临界区 Critical Section</span><br><span class="line"><span class="keyword">for</span>(int i=n-2 ; i&gt;=0 ; i--)</span><br><span class="line">V(S[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意P(S[i])操作中的i是从0～N-2，而V(S[i])的i是反过来的从N-2～0，这个很重要，这个就是多级队列的精髓，顺序不能换。<br>下面的分析，假设t1时刻p1进入临界区还没出来之前，t2～tN时刻p2～pN按顺序来请求进入临界区，那么p2～pN都执行for循环，分别被挂起在信号量N-2～0的等待队列上，并且每个信号量的等待队列上有且只有一个进程被挂起。在tN+1时刻p1出临界区，由于V(S[i])是从N-2～0，因此等待在LN-2上的P2最先被唤醒，然后L2进入临界区。之后按顺序p3～pN依次被唤醒并依次挂入就绪队列等待被调度，而处理器从就绪队列进行调度是FIFO，与请求临界区的顺序一致，饥饿现象得以解决。</p><p><img src="/2019/04/25/stack-pv/stack-pv.png" alt="聊天窗口模型"></p><p>该方法的资源复杂度为O(N-1)，需要N-1个信号量。</p><p>c. 优化方法<br>除了前面的办法，已经可以确定存在更优方案能把资源复杂度降为O(logN)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题模型&quot;&gt;&lt;a href=&quot;#问题模型&quot; class=&quot;headerlink&quot; title=&quot;问题模型&quot;&gt;&lt;/a&gt;问题模型&lt;/h3&gt;&lt;p&gt;有一个系统，定义如下P、V操作：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="同步机制" scheme="https://icoty.github.io/categories/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="互斥机制" scheme="https://icoty.github.io/categories/%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="信号量" scheme="https://icoty.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="临界区" scheme="https://icoty.github.io/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="P/V操作" scheme="https://icoty.github.io/tags/P-V%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker最简教程</title>
    <link href="https://icoty.github.io/2019/04/22/docker/"/>
    <id>https://icoty.github.io/2019/04/22/docker/</id>
    <published>2019-04-22T12:49:16.000Z</published>
    <updated>2019-06-09T06:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在让你用最短的时间弄懂Docker命令操作，什么虚拟化都太泛泛了，不讲大道理，实践出真知，让你从此的日常开发和工作中在面对Docker时不再茫然失措而是得心应手。本文也不谈安装，我实在认为作为程序员，要是我在这里教你如何安装Docker，既是在浪费你的时间也是在浪费我的时间，请参考<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" rel="external nofollow noopener noreferrer" target="_blank">Docker安装</a>；</p><p>Docker Hub是Docker官方维护的一个公共仓库，其中已经包括了数量超过15 000 的镜像，开发者可以注册自己的账号，并自定义自己的镜像进行存储，需要的时候可以直接拿来用，同时也能够分享，有点类似于Github，如想注册可移步 <a href="https://hub.docker.com" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>，注册与否不影响接下来的操作。</p><h3 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h3><p>我认为只要你不是专门研究这个的，那么你只需学会如何使用Docker的一些基本命令，使自己的日常开发和工作不受阻碍，弄清Docker和容器之间的区别，为什么现在很多企业流行Docker，这个东西解决了啥问题，有啥优势就够了。关于Docker是什么有何优势，这里挑了一个简洁的<a href="https://blog.csdn.net/shnsuohaonan/article/details/80651439" rel="external nofollow noopener noreferrer" target="_blank">博客链接</a>。</p><p>接下来从零开始，首先从docker hub仓库上拉取centos镜像，带你走进docker日常命令，学会这些命令，足以应对你的日常开发和工作中关于docker的问题。</p><p>search: 从docker hub仓库搜索带centos的所有镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> seach centos</span><br></pre></td></tr></table></figure></p><p>images: 查看本地所有镜像，pull前左侧REPOSITORY栏无centos。REPOSITORY表示镜像被归入到本地的仓库，比如icoty1/lamp:v1.0.0表示本地icoty1仓库下有一个镜像名为lamp,其TAG(版本)为v1.0.0，每个镜像有一个IMAGE ID唯一标识该镜像，SIZE为镜像大小。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> images</span><br></pre></td></tr></table></figure></p><p>pull: 从docker hub远程仓库把centos镜像拉到本地，pull后再次执行images，会发现centos已经被拉到本地。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> pull centos</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/search.png" alt="cmd"></p><p>ps: 只列出正在运行的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> ps</span><br></pre></td></tr></table></figure></p><p>ps -a: 列出所有容器, 每一个容器有一个CONTAINER ID唯一标识该容器；IMAGE表示该容器是基于哪个镜像生成的，COMMAND是容器启动时执行的命令，可以传入也可以不传入；STATUS是容器当前的状态，Exit是已停止，Up是正在运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> ps -a</span><br></pre></td></tr></table></figure></p><p>run: 从镜像衍生一个新的容器并运行；-d后台模式运行容器，-i交互模式运行容器；-p把主机80关口映射到容器的80端口，因为容器具有封闭性，容器外部不能直接访问容器内部的端口，通过映射后，主机80端口收到数据后会转发到容器内部的80端口，不过在容器内是可以直接访问容器外的主机的；-v把主机的/Users/yangyu/ide/LeetCode/目录映射到容器的/LeetCode/，容器内若无/LeetCode/目录会自动创建，用于实现主机和容器之间的目录共享，在两个目录下操作文件是对等的；centos:latest是镜像名称，可以换成IMAGE ID，二者等价；/bin/bash是容器启动时执行的命令，还可以带参数，这个不懂的可以搜索下。执行docker run后再次执行ps命令，能够看到运行中的容器多了一个。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run -d -ti -p 80:80 -v /Users/yangyu/ide/LeetCode/:/LeetCode/ centos:latest /bin/bash</span><br></pre></td></tr></table></figure></p><p>cp: 拷贝主机/Users/yangyu/ide/LeetCode/Database/目录到容器eaf43b370eb7根目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp /Users/yangyu/ide/LeetCode/Database/ eaf43b370eb7:/</span><br></pre></td></tr></table></figure></p><p>exec: 执行该命令进入容器eaf43b370eb7内，进入容器后在容器内/LeetCode/目录下新建readme.py2，在主机/Users/yangyu/ide/LeetCode/目录下能够看到该文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it eaf43b370eb7 /bin/bash</span><br><span class="line"><span class="variable">$cp</span> /LeetCode/readme.py /LeetCode/readme.py2</span><br></pre></td></tr></table></figure></p><p>cp: 从容器eaf43b370eb7根目录下拷贝目录/Database到主机的/Users/yangyu/ide/LeetCode/Database/目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp eaf43b370eb7:/Database/ /Users/yangyu/ide/LeetCode/Database/</span><br></pre></td></tr></table></figure></p><p>stop/restart: 停止容器eaf43b370eb7然后查看其状态变为Exited；然后通过restart命令重启，容器又处于运行态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> stop eaf43b370eb7</span><br><span class="line"><span class="variable">$docker</span> restart eaf43b370eb7</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/cp-ps-start.png" alt="cmd"></p><p>tag: 把centos镜像归入icoty1仓库下名称为centos，TAG为7，TAG随你定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> tag centos icoty1/centos:7</span><br></pre></td></tr></table></figure></p><p>commit: 最初pull下来的centos镜像是最简版本，里面没有安装mysql vim等；最初pull下来后基于其运行一个容器，你在容器内部可以安装你需要的环境，比如mysql，apache，nginx，hexo博客等，安装好后通过commit命令把容器提交为一个新的镜像，以后凡是从这个新的镜像运行的容器都带有你安装的内容。-m是提交说明；-p是执行commit命令时暂停该容器；eaf43b370eb7是容器ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> commit -m <span class="string">"提交我的自定义镜像，centos7内安装mysql，版本号v1.0.0"</span> -p eaf43b370eb7 icoty1/centos7-mysql:v1.0.0</span><br></pre></td></tr></table></figure></p><p>save: 把镜像03cb190015bf打包成主机目录/Users/yangyu/ide/LeetCode/下的centos7-mysql.tar，然后你可以通过U盘拷贝到其他机器上，在其他机器上通过load命令可以把centos7-mysql.tar加载成一个镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> save 03cb190015bf &gt; /Users/yangyu/ide/LeetCode/centos7-mysql.tar</span><br></pre></td></tr></table></figure></p><p>load: 把centos7-mysql.tar加载为镜像，因为这个包是从我主机上的镜像03cb190015bf打出来的，所以执行load的时候直接返回镜像03cb190015bf，如果在其他机器上执行会生成一个新的镜像ID。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> load &lt; /Users/yangyu/ide/LeetCode/centos7-mysql.tar</span><br></pre></td></tr></table></figure></p><p>push:  把本地icoty1仓库下TAG为v1.0.0的镜像icoty1/centos7-mysql推到远程仓库docker hub上的icoty1仓库下保存，执行push前需要在本地icoty1已经登陆。push成功之后，其他人就可以通过pull命令拉取你的镜像使用了，相当于git clone操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> push icoty1/centos7-mysql:v1.0.0</span><br><span class="line"><span class="variable">$docker</span> pull icoty1/centos7-mysql:v1.0.0</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/load-save.png" alt="cmd"></p><p>rm: 删除容器eaf43b370eb7，运行中的容器无法删除。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> rm eaf43b370eb7</span><br></pre></td></tr></table></figure></p><p>rmi: 删除镜像03cb190015bf，在这之前必须删除由该镜像衍生出来的所有容器删除，否则会删除失败，执行该命令后通过images发现镜像已经没有了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> rmi 03cb190015bf</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/22/docker/rmi-rm.png" alt="cmd"></p><p>build: 如下以我搭建hexo博客的Dockerfile举例说明。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像，icoty1/ubuntu-hexo-blog:latest在本地仓库必须已经存在</span></span><br><span class="line">FROM icoty1/ubuntu-hexo-blog:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护人员信息，可写可不写</span></span><br><span class="line">MAINTAINER icoty1 <span class="string">"https://icoty.github.io"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露容器的4000端口，这样主机就可以映射端口到4000了</span></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line">/*自动安装所需环境，可替换成安装mysql vim等你需要的命令</span><br><span class="line"> *hexo部分插件安装，使支持rss，图片，字数统计等功能</span><br><span class="line"> */</span><br><span class="line">RUN npm install -g hexo-cli \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> /blog \</span><br><span class="line">&amp;&amp; npm install \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-migrator-rss --save \ </span><br><span class="line">&amp;&amp; npm install hexo-asset-image --save\</span><br><span class="line">&amp;&amp; npm install hexo-wordcount --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \ </span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \ </span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: yilia/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t icoty1/ubuntu-hexo . <span class="comment"># icoty1/ubuntu-hexo是新的镜像的名字</span></span><br><span class="line">$ docker images <span class="comment"># build后会多出icoty1/ubuntu-hexo镜像</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/22/docker/build.png" alt="cmd"></p><h3 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h3><p>为了便于理解，你可以把镜像理解成一个初始模版A，通过这个模板A你可以复制出模板B、模板C等，模板B和模板C在这里就相当于容器，突然某一天你发现模板A现有的内容已经不能满足你的需求了（比如模板A没有安装Mysql，而你需要安装Mysql），这时你就只能自定义新的模板(相当于自定义新的符合你的要求的镜像)，而自定义方式则可以从模板B或模板C中安装Mysql，安装成功之后，通过docker commit命令将模板B或模板C提交成一个新的初始模板A1（也就是新的镜像），以后所有从模板A1运行的容器就都有Mysql了，然后你就有模板A和模板A1了（就是两个镜像）。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>实际操作部分，对各个命令有疑问的，相信我，直接执行一遍才是解决你心中疑虑的不二之法，如果你的命令参数不正确，顶多就是报错和执行不成功，不会让你的主机崩溃，最坏也就不过重新执行一遍，IT这个职业，其本身就是一个不断试错、犯错和总结经验的过程，如果你学到了，请我喝奶茶吧，小生会一直奋斗在原创的路上。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.runoob.com/docker/docker-command-manual.html" rel="external nofollow noopener noreferrer" target="_blank">Docker命令</a><br><a href="http://www.docker.org.cn/index.html" rel="external nofollow noopener noreferrer" target="_blank">Docker中文社区</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文旨在让你用最短的时间弄懂Docker命令操作，什么虚拟化都太泛泛了，不讲大道理，实践出真知，让你从此的日常开发和工作中在面对Docker时不再茫然失措而是得心应手。本文也不谈安装，我实在认为作为程序员，要是我在这里教你如何安装Docker，既是在浪费你的时间也是在浪费我
      
    
    </summary>
    
      <category term="Docker" scheme="https://icoty.github.io/categories/Docker/"/>
    
    
      <category term="Dockerfile" scheme="https://icoty.github.io/tags/Dockerfile/"/>
    
      <category term="镜像" scheme="https://icoty.github.io/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="容器" scheme="https://icoty.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Docker" scheme="https://icoty.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github博客最简教程-Dockerfile自动搭建</title>
    <link href="https://icoty.github.io/2019/04/18/docker-hexo-blog/"/>
    <id>https://icoty.github.io/2019/04/18/docker-hexo-blog/</id>
    <published>2019-04-18T15:23:05.000Z</published>
    <updated>2019-06-09T05:41:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h3><p>拿出你的气质，打开你的电脑，借你半小时搭建好属于你的hexo博客，小生用dockerfile自动帮你搭建好；<br>你只需要在你的mac或linux或windows上提前把docker安装好，如何安装不是我的重点，请参考<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" rel="external nofollow noopener noreferrer" target="_blank">Docker安装</a>；<br>作为程序员，博客就像你的影子，我都已经忘了内心曾经多少次告诫自己，一定要搭建一个属于自己的技术博客，奈何日复一日过去了，近来终于落实到行动上来，所谓明日复明日，明日何其多，早晚要做的事，劝君晚做不如早做。</p><h3 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h3><h4 id="获取基础镜像"><a href="#获取基础镜像" class="headerlink" title="获取基础镜像"></a>获取基础镜像</h4><p>Docker安装成功之后方能进行接下来的操作，如果对Docker基本命令不熟悉又想真懂的可以看下我的另一篇文章<a href="https://icoty.github.io/2019/04/22/docker/">Docker最简教程</a>。首先从我的Docker Hub仓库上获取基础镜像：</p><p><img src="/2019/04/18/docker-hexo-blog/dockerhub.png" alt="docker hub"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull icoty1/ubuntu-hexo-blog <span class="comment"># 从Docker hub上的icoty1用户下获取基础镜像</span></span><br><span class="line">$ docker images <span class="comment"># 查看本地所有镜像，会发现icoty1/ubuntu-hexo-blog已经被pull下来了</span></span><br></pre></td></tr></table></figure><h4 id="生成Dockerfile"><a href="#生成Dockerfile" class="headerlink" title="生成Dockerfile"></a>生成Dockerfile</h4><p>进入一个空的目录下新建空文件Dockerfile，复制如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM icoty1/ubuntu-hexo-blog:latest</span><br><span class="line"></span><br><span class="line">MAINTAINER icoty1 <span class="string">"https://icoty.github.io"</span> </span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo部分插件安装，使支持rss，图片，字数统计等功能</span></span><br><span class="line">RUN npm install -g hexo-cli \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; hexo init blog &amp;&amp; <span class="built_in">cd</span> /blog \</span><br><span class="line">&amp;&amp; npm install \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-migrator-rss --save \</span><br><span class="line">&amp;&amp; npm install hexo-asset-image --save\</span><br><span class="line">&amp;&amp; npm install hexo-wordcount --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: yilia/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>Dockerfile中的最后两行内容表示的含义是从github上把hexo-theme-yilia克隆下来并重命名成yilia，然后放到容器的/blog/themes/目录下，其中hexo-theme-yilia是hexo的主题，hexo有很多种主题，用每一种主题搭建出来的hexo博客界面美观和布局都不尽相同，你可以通过<a href="https://hexo.io/themes/" rel="external nofollow noopener noreferrer" target="_blank">hexo官网</a>上浏览每一种主题长啥样子，通过<a href="https://github.com/search?q=hexo-theme" rel="external nofollow noopener noreferrer" target="_blank">github</a>获取主题的源码仓库，选择一个你喜欢的主题，并相应的修改这两行。假如你从github选择的主题仓库地址是<a href="https://github.com/yscoder/hexo-theme-indigo.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/yscoder/hexo-theme-indigo.git</a> ， 那么你需要按照如下方式进行修改，如果你就想用yilia，那么你不需要做任何修改，我用的主题是<a href="https://github.com/theme-next/hexo-theme-next.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/theme-next/hexo-theme-next.git</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git themes/indigo \</span><br><span class="line">&amp;&amp; sed <span class="string">"s/theme: landscape/theme: indigo/g"</span> -i /blog/_config.yml</span><br></pre></td></tr></table></figure><h4 id="构建Hexo镜像"><a href="#构建Hexo镜像" class="headerlink" title="构建Hexo镜像"></a>构建Hexo镜像</h4><p>在Dockerfile的同级目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t icoty1/ubuntu-hexo .  <span class="comment"># 把icoty1/ubuntu-hexo替换成你取的名字</span></span><br><span class="line">$ docker images <span class="comment"># 能够看到多出一条记录icoty1/ubuntu-hexo，并能看到该镜像的[IMAGE ID]</span></span><br></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 把[IMAGE ID]替换成上一步构建出来的镜像的ID，该句执行成功会多出来一个容器并有一个[CONTAINER ID]</span><br><span class="line"> * -v /home/yangyu/blog/：/blog/是把本机的/home/yangyu/blog/目录映射到容器的/blog/目录</span><br><span class="line"> * 通过目录映射，你只需要在本机编辑/home/yangyu/blog/目录下的文件，而不用每次都进入容器/blog/目录下编辑文件</span><br><span class="line"> * -p 4000:4000 将主机的4000端口映射到容器的4000端口</span><br><span class="line"> *\</span><br><span class="line">$ docker run -d -ti -p 4000:4000 -v /home/yangyu/blog/：/blog/ [IMAGE ID] /bin/bash </span><br><span class="line">$ docker ps -a<span class="comment"># 执行该句列出当前所有的容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it [CONTAINER ID] /bin/bash <span class="comment"># 根据前一步的容器ID进入该容器内部</span></span><br><span class="line">$ <span class="built_in">cd</span> /blog/ &amp;&amp; hexo s <span class="comment"># 进入容器内部的/blog/目录下，启动hexo</span></span><br></pre></td></tr></table></figure><h4 id="浏览器测试"><a href="#浏览器测试" class="headerlink" title="浏览器测试"></a>浏览器测试</h4><p>浏览器访问<a href="http://localhost:4000" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:4000</a> ，出现下图说明已经成功，以后你的博客配置，文章撰写和发布等，都在/home/yangyu/blog/目录下进行，这和在容器内部/blog/目录下操作完全对等。</p><p><img src="/2019/04/18/docker-hexo-blog/yilia.png" alt="yilia"></p><h3 id="Hexo部署到Github"><a href="#Hexo部署到Github" class="headerlink" title="Hexo部署到Github"></a>Hexo部署到Github</h3><p><a href="https://github.com/join?source=header-home" rel="external nofollow noopener noreferrer" target="_blank">注册Github账户</a>，如果已经注册，跳过此步；<br>在github上仓库“用户名.github.io”，比如我的用户名为icoty，仓库名则为：icoty.github.io；</p><p><img src="/2019/04/18/docker-hexo-blog/github.png" alt="yilia"></p><p>执行如下命令生成ssh key，执行完后复制~/.sshid_rsa.pub文件内的全部内容，按照图示添加ssh keys，并粘贴保存到Key栏中，Title栏随便取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span> <span class="comment"># 全程回车</span></span><br><span class="line">$ git config --global user.name <span class="string">"你用github用户名"</span></span><br><span class="line">$ git config --global user.email <span class="string">"你的github邮箱地址"</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/18/docker-hexo-blog/ssh-key.png" alt="yilia"></p><p><img src="/2019/04/18/docker-hexo-blog/add-key.png" alt="yilia"></p><h3 id="配置Hexo主题"><a href="#配置Hexo主题" class="headerlink" title="配置Hexo主题"></a>配置Hexo主题</h3><p>编辑/blog/_config.yml文件，编辑标题、描述信息、Github信息，下图参见我的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 阳光沥肩头 仿佛自由人 <span class="comment"># 标题</span></span><br><span class="line">subtitle: <span class="comment"># 子标题</span></span><br><span class="line">description: Linux C++服务端 <span class="comment"># 描述信息</span></span><br><span class="line">keywords: </span><br><span class="line">author: icoty</span><br><span class="line">language: zh-CN <span class="comment"># 语言</span></span><br><span class="line">timezone: <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  - <span class="built_in">type</span>: git</span><br><span class="line">    repository: git@github.com:icoty/icoty.github.io.git  <span class="comment"># 设置repository对应的链接</span></span><br><span class="line">    branch: master                                        <span class="comment"># 设置提交到的分支</span></span><br><span class="line">    message: Site updated at &#123;&#123; now(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>) &#125;&#125; <span class="comment"># 设置我们提交的信息</span></span><br></pre></td></tr></table></figure><p>执行如下命令发布到github上，通过“https://你的github用户名.github.io”访问，我的是<a href="https://icoty.github.io">https://icoty.github.io</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> generate</span><br><span class="line"><span class="variable">$hexo</span> deploy <span class="comment"># 部署到GitHub</span></span><br></pre></td></tr></table></figure><p>编辑/blog/themes/yilia/_config.yml文件，自定义其他配置，如友链、评论、分享、头像等，这些配置并不是一定要做，做不做都行，只是配置的完善些，你的Hexo博客界面看起来美观些，如何配置在此不一一赘述，请自行查看对应主题的官方文档和Github说明。如果你能操作这里，说明我这个教程还是有效的，感谢你的坚持！</p><h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a><a href="https://hexo.io/zh-cn/docs/commands" rel="external nofollow noopener noreferrer" target="_blank">Hexo命令</a></h3><p>Hexo搭建好后，你可以写博客发布到GitHub 上，别人通过“https://你的github用户名.github.io”就能访问你的博客和看到你写的文章，而这个章节就是教你怎么在本地写你的博客，写博客用的MarkDown语法，推荐你安装MarkDown编辑器Typora。下面列出写博客过程中常用的命令，这些命令都需要走到/blog/目录下执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> new <span class="string">"my-hexo"</span> <span class="comment">#新建my-hexo文章，在/blog/source/_post/目录下生成my-hexo.md，在这个文件里面写你的文章</span></span><br><span class="line"><span class="variable">$hexo</span> generate <span class="comment"># 文章写好后保存，然后执行这条命令，生成静态页面至public目录</span></span><br><span class="line"><span class="variable">$hexo</span> s <span class="comment"># 然后开启预览访问端口（默认端口4000，'ctrl+c'关闭server，‘ctrl+z’放到后台运行），通过http://localhost:4000 查看效果，如果满意就执行下一条命令发布到github</span></span><br><span class="line"><span class="variable">$hexo</span> deploy <span class="comment"># 发布到github，通过https://你用github用户名.github.io 访问</span></span><br><span class="line"><span class="variable">$hexo</span> clean <span class="comment"># 有时你写文章和配置其他内容后，老是不生效，就执行下该命令清除缓存文件 (db.json) 和已生成的静态文件 (public)，不是删除，你的文章仍然在的</span></span><br><span class="line"><span class="variable">$nohup</span> hexo s &amp; <span class="comment"># 启动hexo以后台方式运行</span></span><br><span class="line"><span class="variable">$hexo</span> new page <span class="string">"About"</span> <span class="comment">#新建About页面，这个是配置Hexo界面多出来一个About布局</span></span><br><span class="line"><span class="variable">$hexo</span> <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line"><span class="variable">$hexo</span> version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><h3 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a><a href="https://www.jianshu.com/p/191d1e21f7ed" rel="external nofollow noopener noreferrer" target="_blank">MarkDown语法</a></h3><p>这个比较基础，网上教程也一大堆，MarkDown很容易学，放心比九九表容易多了，只要你用markdown实际动手写过一篇博文后就上手了，因此没啥可说的。</p><h3 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h3><p>接下来的内容是针对next主题的配置，因为我选择的是next，不同主题可能有差异，特此说明。</p><h4 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h4><p>打开themes/next/source/css/_common/components/post/post.styl文件，在文件最后且在@import之前添加如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: <span class="comment">#0593d3; //原始链接颜色</span></span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid <span class="comment">#0593d3; //底部分割线颜色</span></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: <span class="comment">#fc6423; //鼠标经过颜色</span></span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid <span class="comment">#fc6423; //底部分割线颜色</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="文章末尾添加“文章结束”标记"><a href="#文章末尾添加“文章结束”标记" class="headerlink" title="文章末尾添加“文章结束”标记"></a>文章末尾添加“文章结束”标记</h4><p>在themes/next/layout/_macro/目录下新建passage-end-tag.swig，填入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------本文结束&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>然后编辑themes/next/layout/_macro/post.swig，按照下图添加代码块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">    &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/18/docker-hexo-blog/finish-read.png" alt="yilia"></p><p>最后编辑themes/next/_config.yml，添加如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="添加网页加载进度条"><a href="#添加网页加载进度条" class="headerlink" title="添加网页加载进度条"></a>添加网页加载进度条</h4><p>打开themes/next/_config.yml，搜索“pace:”，设置为true。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pace: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="设置文章的显示顺序"><a href="#设置文章的显示顺序" class="headerlink" title="设置文章的显示顺序"></a>设置文章的显示顺序</h4><p>编辑node_modules/hexo-generator-index/lib/generator.js，在return之前添加如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="keyword">function</span>(a, b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">    <span class="keyword">if</span>(a.top == b.top) <span class="built_in">return</span> b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> b.top - a.top; // 否则按照top值降序排</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span> b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在每篇文章的头部添加top字段，top值越大的文章显示越靠前。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo+Github博客最简教程-Dockerfile自动搭建</span><br><span class="line">date: 2019-04-18 15:23:05</span><br><span class="line">top: 6</span><br><span class="line">tags: [Hexo, Dockerfile, Linux, Github]</span><br><span class="line">categories: [IDE]</span><br><span class="line">copyright: ture</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h4 id="添加底部的小图标"><a href="#添加底部的小图标" class="headerlink" title="添加底部的小图标"></a>添加底部的小图标</h4><p>打开themes/next/layout/_partials/footer.swig搜索with-love，修改为如下代码。从<a href="https://fontawesome.com/icons?d=gallery&amp;q=heart" rel="external nofollow noopener noreferrer" target="_blank">fontawesom</a>选择你喜欢的图标名称，我这里选择的是heart。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=<span class="string">"with-love"</span> id=<span class="string">"animate"</span>&gt;</span><br><span class="line">  &lt;i class=<span class="string">"fa fa-heart"</span> aria-hidden = <span class="string">"true"</span>&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h4 id="文章底部添加版权信息"><a href="#文章底部添加版权信息" class="headerlink" title="文章底部添加版权信息"></a>文章底部添加版权信息</h4><p>在themes/next/layout/_macro/下新建 my-copyright.swig，填入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.copyright %&#125;</span><br><span class="line">&lt;div class=<span class="string">"my_post_copyright"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span>&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=<span class="string">"/"</span> title=<span class="string">"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"</span>&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(<span class="string">"YYYY年MM月DD日 - HH:MM"</span>) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> title=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=<span class="string">"copy-path"</span>  title=<span class="string">"点击复制文章链接"</span>&gt;&lt;i class=<span class="string">"fa fa-clipboard"</span> data-clipboard-text=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span>  aria-label=<span class="string">"复制成功！"</span>&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=<span class="string">"fa fa-creative-commons"</span>&gt;&lt;/i&gt; &lt;a rel=<span class="string">"license"</span> href=<span class="string">"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> target=<span class="string">"_blank"</span> title=<span class="string">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    var clipboard = new Clipboard(<span class="string">'.fa-clipboard'</span>);</span><br><span class="line">    $(<span class="string">".fa-clipboard"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      clipboard.on(<span class="string">'success'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: <span class="string">""</span>,   </span><br><span class="line">          text: <span class="string">'复制成功'</span>,</span><br><span class="line">          icon: <span class="string">"success"</span>, </span><br><span class="line">          showConfirmButton: <span class="literal">true</span></span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>然后在themes/next/source/css/_common/components/post/下新建my-post-copyright.styl，填入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid <span class="comment">#d3d3d3;</span></span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: <span class="built_in">break</span>-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: <span class="comment">#b5b5b5;</span></span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: <span class="comment">#808080;</span></span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: <span class="comment">#a3d2a3;</span></span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: <span class="comment">#000;</span></span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +<span class="function"><span class="title">mobile</span></span>()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: <span class="comment">#808080;</span></span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着编辑themes/next/layout/_macro/post.swig文件，按照下图位置添加如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'my-copyright.swig'</span> %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/18/docker-hexo-blog/copy-right.png" alt="docker hub"></p><p>接着在themes/next/source/css/_common/components/post/post.styl文件最后添加如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">"my-post-copyright"</span></span><br></pre></td></tr></table></figure></p><p>然后，还需要在文章的头部添加copyright字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo+Github博客最简教程-Dockerfile自动搭建</span><br><span class="line">date: 2019-04-18 15:23:05</span><br><span class="line">top: 6</span><br><span class="line">tags: [Hexo, Dockerfile, Linux, Github]</span><br><span class="line">categories: [IDE]</span><br><span class="line">copyright: ture</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>最后，编辑根目录下的_config.yml文件，把url换成你的主页：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory</span></span><br><span class="line">url: https://icoty.github.io  <span class="comment"># 这里换成你的主页</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><h4 id="添加网易云音乐外链"><a href="#添加网易云音乐外链" class="headerlink" title="添加网易云音乐外链"></a>添加网易云音乐外链</h4><p>登陆网易云音乐网页版；点击个人头像“我的主页”；然后能够看到“我创建的歌单”，如果没有则创建一个歌单；选中一个歌单点进去，能够看到“歌曲列表”，点击“歌曲列表”右边的“生成外链播放器”；然后点击右下角的“复制代码”，粘贴到themes/next/layout/_macro/sidebar.swig文件中指定的位置即可，我的是放在侧栏中”友链”下面的。</p><h4 id="设置文章缩略显示"><a href="#设置文章缩略显示" class="headerlink" title="设置文章缩略显示"></a>设置文章缩略显示</h4><p>编辑themes/next/_config.yml，搜索auto_excerpt，设置为true：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt (Not recommend).</span></span><br><span class="line"><span class="comment"># 设置文章不显示全部  点进去再显示全部</span></span><br><span class="line"><span class="comment"># Use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line">auto_excerpt:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></p><h4 id="自定义代码块样式"><a href="#自定义代码块样式" class="headerlink" title="自定义代码块样式"></a>自定义代码块样式</h4><p>打开themes\next\source\css_custom\custom.styl，添加如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: <span class="comment">#ff7600;</span></span><br><span class="line">    background: <span class="comment">#fbf7f8;</span></span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid <span class="comment">#d6d6d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="把一篇文章归为多类"><a href="#把一篇文章归为多类" class="headerlink" title="把一篇文章归为多类"></a>把一篇文章归为多类</h4><p>如下会把该文章归为Linux/IPC类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Linux</span><br><span class="line">  - IPC</span><br></pre></td></tr></table></figure></p><p>如下会把该文章归为Linux/IPC和TCP两类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [Linux, ICP]</span><br><span class="line">  - TCP</span><br></pre></td></tr></table></figure></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.jianshu.com/p/9f0e90cc32c2" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/9f0e90cc32c2</a><br><a href="https://www.jianshu.com/p/bff1b1845ac9" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bff1b1845ac9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;闲谈&quot;&gt;&lt;a href=&quot;#闲谈&quot; class=&quot;headerlink&quot; title=&quot;闲谈&quot;&gt;&lt;/a&gt;闲谈&lt;/h3&gt;&lt;p&gt;拿出你的气质，打开你的电脑，借你半小时搭建好属于你的hexo博客，小生用dockerfile自动帮你搭建好；&lt;br&gt;你只需要在你的mac或l
      
    
    </summary>
    
      <category term="Hexo" scheme="https://icoty.github.io/categories/Hexo/"/>
    
    
      <category term="Dockerfile" scheme="https://icoty.github.io/tags/Dockerfile/"/>
    
      <category term="Hexo" scheme="https://icoty.github.io/tags/Hexo/"/>
    
      <category term="镜像" scheme="https://icoty.github.io/tags/%E9%95%9C%E5%83%8F/"/>
    
      <category term="容器" scheme="https://icoty.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于共享内存、信号、命名管道和Select模型实现聊天窗口</title>
    <link href="https://icoty.github.io/2019/04/18/ipc-chat/"/>
    <id>https://icoty.github.io/2019/04/18/ipc-chat/</id>
    <published>2019-04-18T00:16:06.000Z</published>
    <updated>2019-06-09T07:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h3><ol><li>A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据通过共享内存传递给B1进程显示；</li><li>对于A、B 进程，采用ctrl+c（实际为SIGINT信号）方式退出，A、B进程通过捕捉SIGINT信号注册信号处理函数进行资源清理，A1、B1进程手动关闭即可。<br><img src="/2019/04/18/ipc-chat/windows.png" alt="聊天窗口模型"></li></ol><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>A、B通过管道通信，如果首先通过ctrl+c退出A进程，那么B进程的fifo1管道的写端会收到SIGPIPE信号而终止B进程，因此必须在B进程终止前清理掉被B占用的共享内存2，将共享内存2的引用计数减一，否则，当B1进程退出并清理共享内存2后，共享内存2的引用计数不为0，会导致共享内存2得不到释放；</li><li>为了解决前一个问题，A、B进程在启动后立即将各自的进程id通过管道发送给对方，并在各自的进程退出时向对方进程id发送SIGINT信号，触发对方进程进入信号处理接口执行资源回收工作；</li><li>A和A1通过共享内存1通信，会从A进程和A1进程的虚拟地址空间分配一段连续的页映射到同一块连续的物理内存页上，这样A、A1两个进程都可以间接访问物理内存页，从而达到通信的目的，一般共享内存需要进行保护，读写不能同时进行，也不能同时进行写操作，共享内存省去了从内核缓冲区到用户缓冲区的拷贝，因此效率高。</li></ol><h3 id="编码与效果图"><a href="#编码与效果图" class="headerlink" title="编码与效果图"></a>编码与效果图</h3><p><img src="/2019/04/18/ipc-chat/ret.png" alt="运行结果"></p><p>func.h:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netdb.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/uio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br></pre></td></tr></table></figure></p><p>processA.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidB;// 存放对端进程B的进程id号</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidB, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))  </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式，因此需要建立两条管道</span><br><span class="line">// A进程通过管道文件fifo1的读端fdr读取B进程发送的数据</span><br><span class="line">// A进程通过管道文件fifo2的写端fdw向B进程发送数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdr=open(<span class="string">"fifo1"</span>, O_RDONLY)) || -1 == (fdw=open(<span class="string">"fifo2"</span>, O_WRONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidB = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, A to A1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, getpid(), pidB);</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给A1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标准输入可读,读出来传递给B进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidA;// 存放对端进程id</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidA, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式</span><br><span class="line">// B进程通过管道文件fifo1的写端fdw向A进程发送数据</span><br><span class="line">// B进程通过管道文件fifo2的读端fdr接收A进程的数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdw=open(<span class="string">"fifo1"</span>, O_WRONLY)) || -1 == (fdr=open(<span class="string">"fifo2"</span>, O_RDONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidA = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, B to B1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, pidA, getpid());</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给B1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标注输入可读,读出来传递给A进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processA1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am A1, recv from A:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am B1, recv from B:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h3><ol><li>这里首先通过ctrl+c退出A进程，然后B进程收到SIGPIPE信号退出，A、B进程同时调用各自的信号处理函数回收资源，通过ipcs命令发现拥有者为root的共享内存资源的nattch都为1，分别被A1和B1占有。</li><li>然后手动关闭A1、B1进程，再次执行ipcs命令，发现拥有者为root的共享内存资源不存在，已经释放成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs  <span class="comment"># 查看共性内存资源数量</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/04/18/ipc-chat/ipcs.png" alt="资源回收图"></p><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><p>本文所有<a href="https://github.com/icoty/Linux/tree/master/IPC/chat" rel="external nofollow noopener noreferrer" target="_blank">源码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题模型&quot;&gt;&lt;a href=&quot;#问题模型&quot; class=&quot;headerlink&quot; title=&quot;问题模型&quot;&gt;&lt;/a&gt;问题模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据
      
    
    </summary>
    
      <category term="IO多路复用模型" scheme="https://icoty.github.io/categories/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="同步机制" scheme="https://icoty.github.io/categories/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="IPC" scheme="https://icoty.github.io/categories/IPC/"/>
    
    
      <category term="Linux" scheme="https://icoty.github.io/tags/Linux/"/>
    
      <category term="共享内存" scheme="https://icoty.github.io/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
      <category term="命名管道" scheme="https://icoty.github.io/tags/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    
      <category term="信号" scheme="https://icoty.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="Select" scheme="https://icoty.github.io/tags/Select/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Docker快速部署LAMP</title>
    <link href="https://icoty.github.io/2019/04/16/docker-lamp/"/>
    <id>https://icoty.github.io/2019/04/16/docker-lamp/</id>
    <published>2019-04-16T15:23:05.000Z</published>
    <updated>2019-05-23T04:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>若你的mac或Linux环境上未安装Docker，请移步<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" rel="external nofollow noopener noreferrer" target="_blank">Docker安装</a>，确认安装成功之后再进行下文内容。如果你不了解Docker如何操作，但是你又想彻底弄懂Docker命令，可以看我另一篇文章<a href="https://icoty.github.io/2019/04/22/docker/">Docker最简教程</a>。</p><h3 id="拿来即用"><a href="#拿来即用" class="headerlink" title="拿来即用"></a>拿来即用</h3><h4 id="获取LAMP"><a href="#获取LAMP" class="headerlink" title="获取LAMP"></a>获取LAMP</h4><p>LAMP镜像我已经搭建好并且我已经测试过了，没有问题。你只需要直接拿去用，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> pull icoty1/lamp:v1.1.0</span><br><span class="line"><span class="variable">$docker</span> images <span class="comment"># 能够看到icoty1/lamp:v1.1.0已经被拉到你本地</span></span><br><span class="line"><span class="variable">$docker</span> run -d -ti -p 80:80 -p 3306:3306 -v /Users/yangyu/app/:/var/www/html/ icoty1/lamp:v1.1.0 /bin/bash start.sh <span class="comment"># 运行一个容器，目录/Users/yangyu/app/是你本机PHP应用位置</span></span><br></pre></td></tr></table></figure></p><p>/Users/yangyu/app/下存放的是public、thinkphp、vendor、runtime等内容。然后访问<a href="http://localhost" rel="external nofollow noopener noreferrer" target="_blank">http://localhost</a> 能够看到PHP应用目录下的内容，如下图，说明已经成功。<br><img src="/2019/04/16/docker-lamp/php-app.png" alt="php-app"></p><p>然后访问<a href="http://localhost/public/index.php" rel="external nofollow noopener noreferrer" target="_blank">http://localhost/public/index.php</a> ，这个是PHP的入口。如果浏览器打开提示权限不够，不要慌，检查下你无法访问的那个目录下是否存在.htaccess文件，如果有则删除就好了，如果没有则执行如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it [CONTAINER ID] /bin/bash <span class="comment"># 进入前面启动的容器中</span></span><br><span class="line"><span class="variable">$chmod</span> -R 0777 /var/www/html/ <span class="comment"># 赋予最高权限</span></span><br><span class="line"><span class="variable">$sh</span> start.sh <span class="comment"># start.sh在根目录下，是重启服务用的</span></span><br></pre></td></tr></table></figure><p>访问phpadmin：<a href="http://localhost/phpmyadmin/index.php" rel="external nofollow noopener noreferrer" target="_blank">http://localhost/phpmyadmin/index.php</a> ，登陆的用户名和密码均为phpmyadmin，登陆后你能够在浏览器上一目了然的对所有数据表进行操作。</p><p>容器内根目录下有个start.sh文件，每次需要重启apache服务和mysql服务时只需要执行这个脚本就好了，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sh</span> start.sh</span><br></pre></td></tr></table></figure><h4 id="LAMP版本"><a href="#LAMP版本" class="headerlink" title="LAMP版本"></a>LAMP版本</h4><p>Ubuntu 18.04.2，PHP 7.2.15，mysql 5.7.25，同时也安装了phpmyadmin。下面是查看版本的命令。mysql数据库的root账户密码是root，phpmyadmin账户密码是phpmyadmin ，你可以把密码修改成你的，<a href="https://www.cnblogs.com/mmx8861/p/9062363.html" rel="external nofollow noopener noreferrer" target="_blank">mysql修改用户密码</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@4f5e11ebccac:/<span class="comment"># cat /etc/issue</span></span><br><span class="line">Ubuntu 18.04.2 LTS \n \l</span><br><span class="line"></span><br><span class="line">root@4f5e11ebccac:/<span class="comment"># php -v</span></span><br><span class="line">PHP 7.2.15-0ubuntu0.18.04.2 (cli) (built: Mar 22 2019 17:05:14) ( NTS )</span><br><span class="line">Copyright (c) 1997-2018 The PHP Group</span><br><span class="line">Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies</span><br><span class="line">    with Zend OPcache v7.2.15-0ubuntu0.18.04.2, Copyright (c) 1999-2018, by Zend Technologies</span><br><span class="line">root@4f5e11ebccac:/<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 9</span><br><span class="line">Server version: 5.7.25-0ubuntu0.18.04.2 (Ubuntu)</span><br></pre></td></tr></table></figure><p>到这里你的目的就已经达到了，一个完整LAMP服务已经在你本机上跑起来并且能用了。下面的内容是我制作icoty1/lamp:v1.1.0的过程，如果你有兴趣，或者想知道我是怎么制作出来的，欢迎继续围观。</p><h3 id="icoty1-lamp-v1-1-0制作过程"><a href="#icoty1-lamp-v1-1-0制作过程" class="headerlink" title="icoty1/lamp:v1.1.0制作过程"></a>icoty1/lamp:v1.1.0制作过程</h3><h4 id="获取ubuntu基础镜像"><a href="#获取ubuntu基础镜像" class="headerlink" title="获取ubuntu基础镜像"></a>获取ubuntu基础镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull i icoty1/ubuntu:18.04.2-LTS  <span class="comment"># 从icoty1仓库拉取基础镜像并运行一个容器</span></span><br></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>进入前面运行的容器中安装接下来的内容。</p><h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$apt</span>-get update</span><br><span class="line"><span class="variable">$apt</span>-get upgrade -y </span><br><span class="line"><span class="variable">$apt</span>-get dist-upgrade -y</span><br><span class="line"><span class="variable">$apt</span>-get install vim -y</span><br><span class="line"><span class="variable">$apt</span>-get install mysql-server mysql-client  -y</span><br></pre></td></tr></table></figure><h5 id="apache-php"><a href="#apache-php" class="headerlink" title="apache/php"></a>apache/php</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$apt</span>-get install apache2 -y</span><br><span class="line"><span class="variable">$vi</span> /etc/apache2/apache2.conf <span class="comment"># 添加 ServerName localhost:80</span></span><br><span class="line"><span class="variable">$apt</span>-get install php7.2 -y <span class="comment"># 这个过程中需要选择国家和时区，如图。</span></span><br><span class="line"><span class="variable">$apt</span>-get install libapache2-mod-php7.2</span><br><span class="line"><span class="variable">$apt</span>-get install php7.2-mysql -y</span><br></pre></td></tr></table></figure><p><img src="/2019/04/16/docker-lamp/time-zone.png" alt="time-zone"></p><h5 id="phpmyadmin"><a href="#phpmyadmin" class="headerlink" title="phpmyadmin"></a>phpmyadmin</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$apt</span>-get install php-mbstring php7.0-mbstring php-gettext</span><br><span class="line"><span class="variable">$service</span> apache2 restart</span><br><span class="line"><span class="variable">$apt</span>-get install phpmyadmin <span class="comment"># 这个过程中会自动创建mysql用户名phpmyadmin，需要手动输入密码，如图。</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/16/docker-lamp/php-myadmin.png" alt="phpmyadmin"></p><h5 id="使apache解析php文件"><a href="#使apache解析php文件" class="headerlink" title="使apache解析php文件"></a>使apache解析php文件</h5><p> vi /etc/apache2/apache2.conf，添加如下内容，让apache服务知道libphp7.2.so库在哪里，找不到这个动态库就无法解析php文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add by yangyu, current dictory is '/etc/apache2/', so '../../usr/lib/apache2/modules/libphp7.2.so' = '/usr/lib/apache2/modules/libphp7.2.so'</span></span><br><span class="line">LoadModule php7_module ../../usr/lib/apache2/modules/libphp7.2.so</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">DirectoryIndex index.php index.htm index.html</span><br></pre></td></tr></table></figure></p><p>到此，这个容器内已经搭建好了LAMP服务，使用docker commit命令把这个容器提交为镜像icoty1/lamp:v1.1.0，然后push到我的docker hub仓库上，你所pull的正是我push上去的。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/impy/p/8040684.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/impy/p/8040684.html</a> # lamp<br><a href="https://linux.cn/article-7463-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://linux.cn/article-7463-1.html</a> # lamp<br><a href="https://blog.csdn.net/longgeaisisi/article/details/78448525" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/longgeaisisi/article/details/78448525</a> # lamp<br><a href="https://www.cnblogs.com/mmx8861/p/9062363.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/mmx8861/p/9062363.html</a> # mysql密码修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若你的mac或Linux环境上未安装Docker，请移步&lt;a href=&quot;http://www.runoob.com/docker/ubuntu-docker-install.html&quot; rel=&quot;external nofollow noopener noreferrer&quot;
      
    
    </summary>
    
      <category term="Docker" scheme="https://icoty.github.io/categories/Docker/"/>
    
      <category term="LAMP" scheme="https://icoty.github.io/categories/LAMP/"/>
    
    
      <category term="Linux" scheme="https://icoty.github.io/tags/Linux/"/>
    
      <category term="LAMP" scheme="https://icoty.github.io/tags/LAMP/"/>
    
      <category term="Dockerfile" scheme="https://icoty.github.io/tags/Dockerfile/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阳光沥肩头 仿佛自由人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-16T15:11:13.554Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>icoty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下Docker快速部署LAMP</title>
    <link href="http://yoursite.com/2019/04/18/hello-world/"/>
    <id>http://yoursite.com/2019/04/18/hello-world/</id>
    <published>2019-04-17T17:36:13.860Z</published>
    <updated>2019-04-16T15:11:13.554Z</updated>
    
    <content type="html"><![CDATA[<p>若你的mac或Linux环境上未安装Docker，请移步<a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">Docker安装</a>，确认安装成功之后再进行下文内容。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="获取基础镜像"><a href="#获取基础镜像" class="headerlink" title="获取基础镜像"></a>获取基础镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull tutum/lamp  <span class="comment"># 从Docker Hub上的tutum用户的仓库获取lamp镜像</span></span><br><span class="line">$ docker images  <span class="comment"># 列出所有的镜像，会发现多一条记录：tutum/lamp</span></span><br></pre></td></tr></table></figure><p>本文用的镜像源<a href="https://hub.docker.com/r/tutum/lamp" target="_blank" rel="noopener">tutum/lamp</a>，目前Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像，开发者可以注册自己的账号，并自定义自己的镜像进行存储，需要的时候可以直接拿来用，同时也能够分享，有点类似于Github。如想注册可移步 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>。</p><h3 id="自定义你的镜像"><a href="#自定义你的镜像" class="headerlink" title="自定义你的镜像"></a>自定义你的镜像</h3><p>在一个空的目录下新建Dockerfile文件名，填入如下4行内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM tutum/lamp:latest  <span class="comment"># 表示在镜像tutum/lamp:latest之上自定义你的镜像</span></span><br><span class="line">RUN rm -fr /app  <span class="comment"># 后面会把你的php项目映射到容器的/app/目录下</span></span><br><span class="line">EXPOSE 80 3306   <span class="comment"># 暴露80 3306端口</span></span><br><span class="line">CMD [<span class="string">"/run.sh"</span>]   <span class="comment"># 当容器启动后会自动执行容器内部的/run.sh脚本</span></span><br></pre></td></tr></table></figure></p><p>在Dockerfile的同级目录执行如下命令，该命令会去执行Dockerfile脚本，并构建新的镜像username/my-lamp-app，其中my-lamp-app为自定义的镜像名字，命名成你的即可。如果注册了docker hub，一般将username换层你的用户名，如未注册，可以随便取。我执行的是：“docker build -t icoty1/lamp .”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t username/my-lamp-app .</span><br></pre></td></tr></table></figure></p><h3 id="基于你的镜像运行一个容器"><a href="#基于你的镜像运行一个容器" class="headerlink" title="基于你的镜像运行一个容器"></a>基于你的镜像运行一个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /home/icoty/app/:/app/ -p 80:80 -p 3306:3306 username/my-lamp-app</span><br></pre></td></tr></table></figure><ol><li>-v /home/icoty/app/:/app/ 表示将/home/icoty/app/目录映射到容器内部的/app/目录，其中/home/icoty/app/为我的php项目存放位置，需要换成你的。</li><li>-p 80:80 表示将本机的80端口映射到容器内部的80端口，在容器外面是无法直接访问容器内部端口的，映射后才可以，这样当本机80端口收到数据后会自动转发给容器内部的80端口，不过在容器内部是可以直接访问其他远程主机的，这点保证了容器的封闭性和安全性。</li><li>username/my-lamp-app 为前面自定义的镜像名称。</li></ol><h3 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a   <span class="comment"># 查看上一步运行的容器，找到username/my-lamp-app对应的CONTAINER ID</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it ID /bin/bash   <span class="comment"># 根据容器ID进入容器，其中ID为前一句找到的CONTAINER ID</span></span><br><span class="line">$ chown -R www-data:www-data /app/   <span class="comment"># 将php项目目录权限修改为运行apache的用户组，否则会因为权限不够，web页面打不开</span></span><br></pre></td></tr></table></figure><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/public/index.php</span><br></pre></td></tr></table></figure><p>注意：/app/目录下的各个子目录下如果存在.htaccess 文件，会导致web页面无法访问对应子目录，只需将.htaccess重命名为.htaccess.bak即可解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若你的mac或Linux环境上未安装Docker，请移步&lt;a href=&quot;http://www.runoob.com/docker/ubuntu-docker-install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker安装&lt;/a&gt;
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="LAMP" scheme="http://yoursite.com/tags/LAMP/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信-利用共享内存和管道通信实现聊天窗口</title>
    <link href="http://yoursite.com/2019/04/18/ipc-chat/"/>
    <id>http://yoursite.com/2019/04/18/ipc-chat/</id>
    <published>2019-04-17T16:16:06.000Z</published>
    <updated>2019-04-18T02:13:31.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h3><ol><li>A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据通过共享内存传递给B1进程显示；</li><li>对于A、B 进程，采用ctrl+c（实际为SIGINT信号）方式退出，A、B进程通过捕捉SIGINT信号注册信号处理函数进行资源清理，A1、B1进程手动关闭即可。<br><img src="/2019/04/18/ipc-chat/windows.png" alt="聊天窗口模型"></li></ol><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>A、B通过管道通信，如果首先通过ctrl+c退出A进程，那么B进程的fifo1管道的写端会收到SIGPIPE信号而终止B进程，因此必须在B进程终止前清理掉被B占用的共享内存2，将共享内存2的引用计数减一，否则，当B1进程退出并清理共享内存2后，共享内存2的引用计数不为0，会导致共享内存2得不到释放；</li><li>为了解决前一个问题，A、B进程在启动后立即将各自的进程id通过管道发送给对方，并在各自的进程退出时向对方进程id发送SIGINT信号，触发对方进程进入信号处理接口执行资源回收工作；</li><li>A和A1通过共享内存1通信，会从A进程和A1进程的虚拟地址空间分配一段连续的页映射到同一块连续的物理内存页上，这样A、A1两个进程都可以间接访问物理内存页，从而达到通信的目的，一般共享内存需要进行保护，读写不能同时进行，也不能同时进行写操作，共享内存省去了从内核缓冲区到用户缓冲区的拷贝，因此效率高。</li></ol><h3 id="编码与效果图"><a href="#编码与效果图" class="headerlink" title="编码与效果图"></a>编码与效果图</h3><p><img src="/2019/04/18/ipc-chat/ret.png" alt="运行结果"></p><p>func.h:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;strings.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netdb.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/uio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ipc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/shm.h&gt;</span></span><br></pre></td></tr></table></figure></p><p>processA.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidB;// 存放对端进程B的进程id号</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidB, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))  </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式，因此需要建立两条管道</span><br><span class="line">// A进程通过管道文件fifo1的读端fdr读取B进程发送的数据</span><br><span class="line">// A进程通过管道文件fifo2的写端fdw向B进程发送数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdr=open(<span class="string">"fifo1"</span>, O_RDONLY)) || -1 == (fdw=open(<span class="string">"fifo2"</span>, O_WRONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidB = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, A to A1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, getpid(), pidB);</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给A1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标准输入可读,读出来传递给B进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int shmid;</span><br><span class="line">int pidA;// 存放对端进程id</span><br><span class="line">char *p;// 共享内存指针</span><br><span class="line"></span><br><span class="line">// 回收共享内存资源前先杀死对端进程，否则回收失败</span><br><span class="line">void handle(int num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">kill</span>(pidA, SIGINT);</span><br><span class="line">shmdt(p);</span><br><span class="line">int ret;</span><br><span class="line"><span class="keyword">if</span>(-1 == (ret=shmctl(shmid, IPC_RMID, NULL))) </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> (void)-1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT, handle);</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 管道文件为单工通信方式</span><br><span class="line">// B进程通过管道文件fifo1的写端fdw向A进程发送数据</span><br><span class="line">// B进程通过管道文件fifo2的读端fdr接收A进程的数据</span><br><span class="line">int fdr, fdw;</span><br><span class="line"><span class="keyword">if</span>(-1 == (fdw=open(<span class="string">"fifo1"</span>, O_WRONLY)) || -1 == (fdr=open(<span class="string">"fifo2"</span>, O_RDONLY)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open fifo1 or open fifo2"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通信之前先通过管道互相告知对方自己的进程id</span><br><span class="line">char s1[10] = &#123;0&#125;;</span><br><span class="line">char s2[10] = &#123;0&#125;;</span><br><span class="line">sprintf(s1, <span class="string">"%d\n"</span>, getpid());</span><br><span class="line">write(fdw, s1, strlen(s1) - 1);</span><br><span class="line"><span class="built_in">read</span>(fdr, s2, strlen(s1) - 1);</span><br><span class="line">pidA = atoi(s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe connect success, B to B1 shmid:[%d], pidA:[%d], pidB:[%d]\n"</span>, shmid, pidA, getpid());</span><br><span class="line"></span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int ret;</span><br><span class="line">fd_set rdset;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;rdset);</span><br><span class="line">FD_SET(0, &amp;rdset);</span><br><span class="line">FD_SET(fdr, &amp;rdset);</span><br><span class="line"><span class="keyword">if</span>((ret=select(fdr+1, &amp;rdset, NULL, NULL, NULL) &gt; 0))</span><br><span class="line">&#123;</span><br><span class="line">// fdr可读,则接收数据之后通过共享内存传给B1</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fdr, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">strncpy(p, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标注输入可读,读出来传递给A进程</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(0, &amp;rdset))</span><br><span class="line">&#123;</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(STDIN_FILENO, buf, sizeof(buf)) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">write(fdw, buf, strlen(buf) - 1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fdr);</span><br><span class="line">close(fdw);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processA1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "fuprintf("p:%s\n", p);nc.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1234, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am A1, recv from A:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processB1.cpp：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "func.h"</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024] = &#123;0&#125;;</span><br><span class="line">int shmid;</span><br><span class="line"><span class="keyword">if</span>(-1 == (shmid=shmget(1235, 4096, IPC_CREAT|0666)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p;</span><br><span class="line"><span class="keyword">if</span>((char*)-1 == (p=(char*)shmat(shmid, NULL, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmat"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(strcmp(buf, p)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">// 共享内存有数据可读</span><br><span class="line">bzero(buf, sizeof(buf));</span><br><span class="line">strcpy(buf, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I am B1, recv from B:[%s]\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(-1 ==(shmctl(shmid, IPC_RMID, 0)))</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmctl"</span>);</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h3><ol><li>这里首先通过ctrl+c退出A进程，然后B进程收到SIGPIPE信号退出，A、B进程同时调用各自的信号处理函数回收资源，通过ipcs命令发现拥有者为root的共享内存资源的nattch都为1，分别被A1和B1占有。</li><li>然后手动关闭A1、B1进程，再次执行ipcs命令，发现拥有者为root的共享内存资源不存在，已经释放成功。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs  <span class="comment"># 查看共性内存资源数量</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/04/18/ipc-chat/ipcs.png" alt="资源回收图"></p><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><p>本文所有<a href="https://github.com/icoty/Linux/tree/master/IPC/chat" target="_blank" rel="noopener">源码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题模型&quot;&gt;&lt;a href=&quot;#问题模型&quot; class=&quot;headerlink&quot; title=&quot;问题模型&quot;&gt;&lt;/a&gt;问题模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;A、B两个进程通过管道通信，A 进程每次接收到的数据通过共享内存传递给A1进程显示，同理，B进程每次接收到的数据
      
    
    </summary>
    
      <category term="Programing" scheme="http://yoursite.com/categories/Programing/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="IPC" scheme="http://yoursite.com/tags/IPC/"/>
    
      <category term="共享内存" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
      <category term="命名管道" scheme="http://yoursite.com/tags/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    
      <category term="信号" scheme="http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="select" scheme="http://yoursite.com/tags/select/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","width":240,"display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, struc">
<meta name="keywords" content="epoll">
<meta property="og:type" content="article">
<meta property="og:title" content="epoll源码分析(基于linux-5.1.4)">
<meta property="og:url" content="https://icoty.github.io/2019/06/03/epoll-source/index.html">
<meta property="og:site_name" content="荒野之萍">
<meta property="og:description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, struc">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-data-structure.png">
<meta property="og:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-sequence">
<meta property="og:updated_time" content="2019-06-08T02:33:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="epoll源码分析(基于linux-5.1.4)">
<meta name="twitter:description" content="APIepoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系。  int epoll_create1(int size)；  创建一个epfd句柄，size为0时等价于int epoll_create(0)。  int epoll_ctl(int epfd, int op, int fd, struc">
<meta name="twitter:image" content="https://icoty.github.io/2019/06/03/epoll-source/epoll-data-structure.png">



  <link rel="alternate" href="/atom.xml" title="荒野之萍" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://icoty.github.io/2019/06/03/epoll-source/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>epoll源码分析(基于linux-5.1.4) | 荒野之萍</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">荒野之萍</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">忙着活或忙着死</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/icoty" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://icoty.github.io/2019/06/03/epoll-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杨宇">
      <meta itemprop="description" content="后台 / 系统">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="荒野之萍">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">epoll源码分析(基于linux-5.1.4)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-03 12:49:38" itemprop="dateCreated datePublished" datetime="2019-06-03T12:49:38+00:00">2019-06-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-08 02:33:33" itemprop="dateModified" datetime="2019-06-08T02:33:33+00:00">2019-06-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/IO多路复用模型/" itemprop="url" rel="index"><span itemprop="name">IO多路复用模型</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UML/" itemprop="url" rel="index"><span itemprop="name">UML</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux源码/" itemprop="url" rel="index"><span itemprop="name">linux源码</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/03/epoll-source/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/03/epoll-source/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">158k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2:24</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>epoll提供给用户进程的接口有如下四个，本文基于linux-5.1.4源码详细分析每个API具体做了啥工作，通过UML时序图理清内核内部的函数调用关系。</p>
<ol>
<li><p>int epoll_create1(int size)；</p>
<p> 创建一个epfd句柄，size为0时等价于int epoll_create(0)。</p>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p>
<p>向epfd上添加/修改/删除fd。</p>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)；</p>
<p>返回所有就绪的fd。</p>
</li>
</ol>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>先上一张UML类图，从整体进行把握，图中已经标出各个数据结构所在的文件。</p>
<p><img src="/2019/06/03/epoll-source/epoll-data-structure.png" alt="cmd"></p>
<p>下面贴出各个数据结构代码，切记，实际在过代码的时候，其实我们没有必要对每一个变量和每一行代码咬文嚼字，也不建议这样去做，我们只需要重点关注主要的数据成员和那些关键的代码行，把心思和精力投入到我们最该关注的那部分，从框架层面去把握整体，抓准各个模块的核心，各个模块之间如何耦合，如何同步，如何通信等，这才是能够让你快速进步的最优路线。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Each file descriptor added to the eventpoll interface will</span><br><span class="line">* have an entry of this <span class="built_in">type</span> linked to the <span class="string">"rbr"</span> RB tree.</span><br><span class="line">* Avoid increasing the size of this struct, there can be many thousands</span><br><span class="line">* of these on a server and we <span class="keyword">do</span> not want this to take another cache line.</span><br><span class="line">*/</span><br><span class="line">struct epitem &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        /* RB tree node links this structure to the eventpoll RB tree */</span><br><span class="line">        struct rb_node rbn;</span><br><span class="line">        /* Used to free the struct epitem */</span><br><span class="line">        struct rcu_head rcu;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this structure to the eventpoll ready list */</span><br><span class="line">    struct list_head rdllink;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Works together <span class="string">"struct eventpoll"</span>-&gt;ovflist <span class="keyword">in</span> keeping the</span><br><span class="line">    * single linked chain of items.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *next;</span><br><span class="line"></span><br><span class="line">    /* The file descriptor information this item refers to */</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    /* Number of active <span class="built_in">wait</span> queue attached to poll operations */</span><br><span class="line">    int nwait;</span><br><span class="line"></span><br><span class="line">    /* List containing poll <span class="built_in">wait</span> queues */</span><br><span class="line">    struct list_head pwqlist;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"container"</span> of this item */</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* List header used to link this item to the <span class="string">"struct file"</span> items list */</span><br><span class="line">    struct list_head fllink;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when EPOLLWAKEUP is <span class="built_in">set</span> */</span><br><span class="line">    struct wakeup_source __rcu *ws;</span><br><span class="line"></span><br><span class="line">    /* The structure that describe the interested events and the <span class="built_in">source</span> fd */</span><br><span class="line">    struct epoll_event event;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* This structure is stored inside the <span class="string">"private_data"</span> member of the file</span><br><span class="line">* structure and represents the main data structure <span class="keyword">for</span> the eventpoll</span><br><span class="line">* interface.</span><br><span class="line">*/</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">    /*</span><br><span class="line">    * This mutex is used to ensure that files are not removed</span><br><span class="line">    * <span class="keyword">while</span> epoll is using them. This is held during the event</span><br><span class="line">    * collection loop, the file cleanup path, the epoll file <span class="built_in">exit</span></span><br><span class="line">    * code and the ctl operations.</span><br><span class="line">    */</span><br><span class="line">    struct mutex mtx;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by sys_epoll_wait() */</span><br><span class="line">    wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">    /* Wait queue used by file-&gt;poll() */</span><br><span class="line">    wait_queue_head_t poll_wait;</span><br><span class="line"></span><br><span class="line">    /* List of ready file descriptors */</span><br><span class="line">    struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">    /* Lock <span class="built_in">which</span> protects rdllist and ovflist */</span><br><span class="line">    rwlock_t lock;</span><br><span class="line"></span><br><span class="line">    /* RB tree root used to store monitored fd structs */</span><br><span class="line">    struct rb_root_cached rbr;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * This is a single linked list that chains all the <span class="string">"struct epitem"</span> that</span><br><span class="line">    * happened <span class="keyword">while</span> transferring ready events to userspace w/out</span><br><span class="line">    * holding -&gt;lock.</span><br><span class="line">    */</span><br><span class="line">    struct epitem *ovflist;</span><br><span class="line"></span><br><span class="line">    /* wakeup_source used when ep_scan_ready_list is running */</span><br><span class="line">    struct wakeup_source *ws;</span><br><span class="line"></span><br><span class="line">    /* The user that created the eventpoll descriptor */</span><br><span class="line">    struct user_struct *user;</span><br><span class="line"></span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* used to optimize loop detection check */</span><br><span class="line">    int visited;</span><br><span class="line">    struct list_head visited_list_link;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">    /* used to track busy poll napi_id */</span><br><span class="line">    unsigned int napi_id;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* eppoll_entry主要完成epitem和epitem事件发生时的callback（ep_poll_callback）</span><br><span class="line"> * 函数之间的关联，并将上述两个数据结构包装成一个链表节点，</span><br><span class="line"> * 挂载到目标文件file的waithead中。</span><br><span class="line"> * Wait structure used by the poll hooks</span><br><span class="line"> */</span><br><span class="line">struct eppoll_entry &#123;</span><br><span class="line">    /* List header used to link this structure to the <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct list_head llink;</span><br><span class="line"></span><br><span class="line">    /* The <span class="string">"base"</span> pointer is <span class="built_in">set</span> to the container <span class="string">"struct epitem"</span> */</span><br><span class="line">    struct epitem *base;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wait queue item that will be linked to the target file <span class="built_in">wait</span></span><br><span class="line">     * queue head.</span><br><span class="line">     */</span><br><span class="line">    wait_queue_entry_t <span class="built_in">wait</span>;</span><br><span class="line"></span><br><span class="line">    /* The <span class="built_in">wait</span> queue head that linked the <span class="string">"wait"</span> <span class="built_in">wait</span> queue item */</span><br><span class="line">    wait_queue_head_t *whead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* ep_pqueue主要完成epitem和callback函数的关联。</span><br><span class="line"> * 然后通过目标文件的poll函数调用callback函数ep_ptable_queue_proc。</span><br><span class="line"> * Poll函数一般由设备驱动提供，以网络设备为例，</span><br><span class="line"> * 他的poll函数为sock_poll然后根据sock类型调用不同的poll函数如：</span><br><span class="line"> * packet_poll。packet_poll在通过datagram_poll调用sock_poll_wait，</span><br><span class="line"> * 最后在poll_wait实际调用callback函数（ep_ptable_queue_proc）</span><br><span class="line"> * Wrapper struct used by poll queueing</span><br><span class="line"> */</span><br><span class="line">struct ep_pqueue &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Used by the ep_send_events() <span class="keyword">function</span> as callback private data */</span><br><span class="line">struct ep_send_events_data &#123;</span><br><span class="line">    int maxevents;</span><br><span class="line">    struct epoll_event __user *events;</span><br><span class="line">    int res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fd &#123;</span><br><span class="line">    struct file *file;</span><br><span class="line">    unsigned int flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="全局调用关系"><a href="#全局调用关系" class="headerlink" title="全局调用关系"></a>全局调用关系</h2><p>再贴一张各个API从用户进程陷入到内核态并执行系统调用的详细过程，以及client发数据过来时触发ep_poll_callback回调函数的执行流程。</p>
<p><img src="/2019/06/03/epoll-source/epoll-sequence" alt="cmd"></p>
<h2 id="epoll模块初始化-amp-内存池开辟"><a href="#epoll模块初始化-amp-内存池开辟" class="headerlink" title="epoll模块初始化&amp;内存池开辟"></a>epoll模块初始化&amp;内存池开辟</h2><p>epoll是内核的一个module，内核启动时会初始化这个module。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">static int __init eventpoll_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sysinfo si;</span><br><span class="line"></span><br><span class="line">    si_meminfo(&amp;si);</span><br><span class="line">    /*</span><br><span class="line">     * Allows top 4% of lomem to be allocated <span class="keyword">for</span> epoll watches (per user).</span><br><span class="line">     */</span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) /</span><br><span class="line">        EP_ITEM_COST;</span><br><span class="line">    BUG_ON(max_user_watches &lt; 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Initialize the structure used to perform epoll file descriptor</span><br><span class="line">     * inclusion loops checks.</span><br><span class="line">     */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_loop_ncalls);</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    /* Initialize the structure used to perform safe poll <span class="built_in">wait</span> head wake ups */</span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We can have many thousands of epitems, so prevent this from</span><br><span class="line">     * using an extra cache line on 64-bit (and smaller) CPUs</span><br><span class="line">     */</span><br><span class="line">    BUILD_BUG_ON(sizeof(void *) &lt;= 8 &amp;&amp; sizeof(struct epitem) &gt; 128);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_epi内存池,UML时序图的第21步alloc时直接从内存池里取,</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct epitem"</span> items */</span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, </span><br><span class="line">        		sizeof(struct epitem),0, placehold_flag, 0);</span><br><span class="line"></span><br><span class="line">    // 提前开辟eventpoll_pwq内存池,UML时序图的第28步alloc时直接从内存池里取</span><br><span class="line">    // 而不是重新调用malloc,效率得以提高</span><br><span class="line">    /* Allocates slab cache used to allocate <span class="string">"struct eppoll_entry"</span> */</span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,</span><br><span class="line">        sizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(eventpoll_init);</span><br></pre></td></tr></table></figure>
<h2 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h2><p>用户空间调用epoll_create(0)或epoll_create1(int)，其实质就是在名为”eventpollfs”的文件系统里创建了一个新文件，同时为该文件申请一个fd，绑定一个inode，最后返回该文件句柄。</p>
<h3 id="epoll-create-epoll-create1陷入内核"><a href="#epoll-create-epoll-create1陷入内核" class="headerlink" title="epoll_create/epoll_create1陷入内核"></a>epoll_create/epoll_create1陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create, int, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_create(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-epoll-create-ep-alloc"><a href="#do-epoll-create-ep-alloc" class="headerlink" title="do_epoll_create/ep_alloc"></a>do_epoll_create/ep_alloc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Open an eventpoll file descriptor.</span><br><span class="line"> */</span><br><span class="line">static int do_epoll_create(int flags)</span><br><span class="line">&#123;</span><br><span class="line">    int error, fd;</span><br><span class="line">    struct eventpoll *ep = NULL;</span><br><span class="line">    struct file *file;</span><br><span class="line"></span><br><span class="line">    /* Check the EPOLL_* constant <span class="keyword">for</span> consistency.  */</span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line">    /*</span><br><span class="line">     * 申请一个struct eventpoll内存空间,执行初始化后赋给ep</span><br><span class="line">     * Create the internal data structure (<span class="string">"struct eventpoll"</span>).</span><br><span class="line">     */</span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; 0)</span><br><span class="line">        <span class="built_in">return</span> error;</span><br><span class="line">    /*</span><br><span class="line">     * 获取一个未使用的fd句柄</span><br><span class="line">     * Creates all the items needed to setup an eventpoll file. That is,</span><br><span class="line">     * a file structure and a free file descriptor.</span><br><span class="line">     */</span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; 0) &#123;</span><br><span class="line">        error = fd;</span><br><span class="line">        goto out_free_ep;</span><br><span class="line">    &#125;</span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                              O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        error = PTR_ERR(file);</span><br><span class="line">        goto out_free_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">    // 绑定fd和file</span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    // 这个fd就是epfd句柄,返回给用户进程的</span><br><span class="line">    <span class="built_in">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// fs/eventpoll.c</span><br><span class="line">// 形参是一个二级指针,该接口就是简单的分配一个struct eventpoll,然后执行初始化工作</span><br><span class="line">static int ep_alloc(struct eventpoll **pep)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct user_struct *user;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    user = get_current_user();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = kzalloc(sizeof(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!ep))</span><br><span class="line">        goto free_uid;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;ep-&gt;mtx);</span><br><span class="line">    rwlock_init(&amp;ep-&gt;lock);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;wq);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;poll_wait);</span><br><span class="line">    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);</span><br><span class="line">    ep-&gt;rbr = RB_ROOT_CACHED;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line"></span><br><span class="line">    *pep = ep;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">free_uid:</span><br><span class="line">    free_uid(user);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="anon-inode-getfile-alloc-file-pseudo-alloc-file"><a href="#anon-inode-getfile-alloc-file-pseudo-alloc-file" class="headerlink" title="anon_inode_getfile/alloc_file_pseudo/alloc_file"></a>anon_inode_getfile/alloc_file_pseudo/alloc_file</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * fs/anon_inodes.c</span><br><span class="line"> * anon_inode_getfile - creates a new file instance by hooking it up to an</span><br><span class="line"> *                      anonymous inode, and a dentry that describe the <span class="string">"class"</span></span><br><span class="line"> *                      of the file</span><br><span class="line"> *</span><br><span class="line"> * @name:    [<span class="keyword">in</span>]    name of the <span class="string">"class"</span> of the new file</span><br><span class="line"> * @fops:    [<span class="keyword">in</span>]    file operations <span class="keyword">for</span> the new file</span><br><span class="line"> * @priv:    [<span class="keyword">in</span>]    private data <span class="keyword">for</span> the new file (will be file<span class="string">'s private_data)</span></span><br><span class="line"><span class="string"> * @flags:   [in]    flags</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * Creates a new file by hooking it on a single inode. This is useful for files</span></span><br><span class="line"><span class="string"> * that do not need to have a full-fledged inode in order to operate correctly.</span></span><br><span class="line"><span class="string"> * All the files created with anon_inode_getfile() will share a single inode,</span></span><br><span class="line"><span class="string"> * hence saving memory and avoiding code duplication for the file/inode/dentry</span></span><br><span class="line"><span class="string"> * setup.  Returns the newly created file* or an error pointer.</span></span><br><span class="line"><span class="string"> * 在一个inode上挂接一个新文件,这对于不需要完整inode才能正确操作的文件非常有用。</span></span><br><span class="line"><span class="string"> * 使用anon_inode_getfile()创建的所有文件都将共享一个inode，</span></span><br><span class="line"><span class="string"> * 因此可以节省内存并避免文件/inode/dentry设置的代码重复。</span></span><br><span class="line"><span class="string"> * 返回新创建的文件*或错误指针。</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct file *anon_inode_getfile(const char *name,const struct file_operations *fops,void *priv, int flags)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (IS_ERR(anon_inode_inode))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENODEV);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (fops-&gt;owner &amp;&amp; !try_module_get(fops-&gt;owner))</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOENT);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * We know the anon_inode inode count is always greater than zero,</span></span><br><span class="line"><span class="string">    * so ihold() is safe.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    ihold(anon_inode_inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // 创建一个名字为“[eventpoll]”的eventpollfs文件描述符</span></span><br><span class="line"><span class="string">    file = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,</span></span><br><span class="line"><span class="string">                             flags &amp; (O_ACCMODE | O_NONBLOCK), fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        goto err;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = anon_inode_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // file-&gt;private_data指向传进来的priv( = struct eventpoll *ep)</span></span><br><span class="line"><span class="string">    file-&gt;private_data = priv;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">err:</span></span><br><span class="line"><span class="string">    iput(anon_inode_inode);</span></span><br><span class="line"><span class="string">    module_put(fops-&gt;owner);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL_GPL(anon_inode_getfile);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// fs/file_table.c</span></span><br><span class="line"><span class="string">struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,</span></span><br><span class="line"><span class="string">    const char *name, int flags,const struct file_operations *fops)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    static const struct dentry_operations anon_ops = &#123;</span></span><br><span class="line"><span class="string">        .d_dname = simple_dname</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    struct qstr this = QSTR_INIT(name, strlen(name));</span></span><br><span class="line"><span class="string">    struct path path;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 挂载名为“[eventpoll]”的eventpollfs文件系统</span></span><br><span class="line"><span class="string">    path.dentry = d_alloc_pseudo(mnt-&gt;mnt_sb, &amp;this);</span></span><br><span class="line"><span class="string">    if (!path.dentry)</span></span><br><span class="line"><span class="string">        return ERR_PTR(-ENOMEM);</span></span><br><span class="line"><span class="string">    if (!mnt-&gt;mnt_sb-&gt;s_d_op)</span></span><br><span class="line"><span class="string">        d_set_d_op(path.dentry, &amp;anon_ops);</span></span><br><span class="line"><span class="string">    path.mnt = mntget(mnt);</span></span><br><span class="line"><span class="string">    d_instantiate(path.dentry, inode);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // inode和file绑定，返回绑定后的file结构</span></span><br><span class="line"><span class="string">    file = alloc_file(&amp;path, flags, fops);</span></span><br><span class="line"><span class="string">    if (IS_ERR(file)) &#123;</span></span><br><span class="line"><span class="string">        ihold(inode);</span></span><br><span class="line"><span class="string">        path_put(&amp;path);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EXPORT_SYMBOL(alloc_file_pseudo);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * fs/file_table.c</span></span><br><span class="line"><span class="string"> * alloc_file - allocate and initialize a '</span>struct file<span class="string">'</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @path: the (dentry, vfsmount) pair for the new file</span></span><br><span class="line"><span class="string"> * @flags: O_... flags with which the new file will be opened</span></span><br><span class="line"><span class="string"> * @fop: the '</span>struct file_operations<span class="string">' for the new file</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">static struct file *alloc_file(const struct path *path, int flags,</span></span><br><span class="line"><span class="string">    				const struct file_operations *fop)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct file *file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 申请一个空的file结构</span></span><br><span class="line"><span class="string">    file = alloc_empty_file(flags, current_cred());</span></span><br><span class="line"><span class="string">    if (IS_ERR(file))</span></span><br><span class="line"><span class="string">        return file;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    file-&gt;f_path = *path;</span></span><br><span class="line"><span class="string">    file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span></span><br><span class="line"><span class="string">    file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span></span><br><span class="line"><span class="string">    file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(fop-&gt;read || fop-&gt;read_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_READ;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(fop-&gt;write || fop-&gt;write_iter))</span></span><br><span class="line"><span class="string">        file-&gt;f_mode |= FMODE_CAN_WRITE;</span></span><br><span class="line"><span class="string">    file-&gt;f_mode |= FMODE_OPENED;</span></span><br><span class="line"><span class="string">    file-&gt;f_op = fop;</span></span><br><span class="line"><span class="string">    if ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span></span><br><span class="line"><span class="string">        i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span></span><br><span class="line"><span class="string">    return file;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p>用户进程调用int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)，op可填EPOLL_CTL_ADD(注册fd到epfd)、EPOLL_CTL_MOD(修改已注册fd监听的事件)和EPOLL_CTL_DEL(从epfd中删除fd)。</p>
<h3 id="epoll-ctl陷入内核"><a href="#epoll-ctl陷入内核" class="headerlink" title="epoll_ctl陷入内核"></a>epoll_ctl陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * The following <span class="keyword">function</span> implements the controller interface <span class="keyword">for</span></span><br><span class="line"> * the eventpoll file that enables the insertion/removal/change of</span><br><span class="line"> * file descriptors inside the interest <span class="built_in">set</span>.</span><br><span class="line"> */</span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,</span><br><span class="line">                struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    int full_check = 0;</span><br><span class="line"></span><br><span class="line">    struct fd f, tf;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line">    struct epoll_event epds;</span><br><span class="line">    struct eventpoll *tep = NULL;</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    // copy_from_user将用户空间关注的event事件拷贝到内核空间</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))</span><br><span class="line">    goto error_return;</span><br><span class="line"></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        goto error_return;</span><br><span class="line"></span><br><span class="line">    /* Get the <span class="string">"struct file *"</span> <span class="keyword">for</span> the target file */</span><br><span class="line">    tf = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tf.file)</span><br><span class="line">        goto error_fput;</span><br><span class="line"></span><br><span class="line">    /* The target file descriptor must support poll */</span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">        goto error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* 如果系统设置了自动休眠模式（通过/sys/power/autosleep），</span><br><span class="line">    * 当唤醒设备的事件发生时，设备驱动会保持唤醒状态，直到事件进入排队状态。</span><br><span class="line">    * 为了保持设备唤醒直到事件处理完成，必须使用epoll EPOLLWAKEUP 标记。</span><br><span class="line">    * 一旦给structe poll_event中的events字段设置了EPOLLWAKEUP标记，系统会在事件排队时就保持唤醒，</span><br><span class="line">    * 从epoll_wait调用开始，持续要下一次epoll_wait调用。</span><br><span class="line">    */</span><br><span class="line">    /* Check <span class="keyword">if</span> EPOLLWAKEUP is allowed */</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">        ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check that the file structure underneath the file descriptor</span><br><span class="line">    * the user passed to us _is_ an eventpoll file. And also we <span class="keyword">do</span> not permit</span><br><span class="line">    * adding an epoll file descriptor inside itself.</span><br><span class="line">    */</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">        goto error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span><br><span class="line">    * so EPOLLEXCLUSIVE is not allowed <span class="keyword">for</span> a EPOLL_CTL_MOD operation.</span><br><span class="line">    * Also, we <span class="keyword">do</span> not currently supported nested exclusive wakeups.</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">            goto error_tgt_fput;</span><br><span class="line">        <span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">                                    (epds.events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">            goto error_tgt_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * At this point it is safe to assume that the <span class="string">"private_data"</span> contains</span><br><span class="line">    * our own data structure.</span><br><span class="line">    */</span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * When we insert an epoll file descriptor, inside another epoll file</span><br><span class="line">    * descriptor, there is the change of creating closed loops, <span class="built_in">which</span> are</span><br><span class="line">    * better be handled here, than <span class="keyword">in</span> more critical paths. While we are</span><br><span class="line">    * checking <span class="keyword">for</span> loops we also determine the list of files reachable</span><br><span class="line">    * and hang them on the tfile_check_list, so we can check that we</span><br><span class="line">    * haven<span class="string">'t created too many possible wakeup paths.</span></span><br><span class="line"><span class="string">    *</span></span><br><span class="line"><span class="string">    * We do not need to take the global '</span>epumutex<span class="string">' on EPOLL_CTL_ADD when</span></span><br><span class="line"><span class="string">    * the epoll file descriptor is attaching directly to a wakeup source,</span></span><br><span class="line"><span class="string">    * unless the epoll file descriptor is nested. The purpose of taking the</span></span><br><span class="line"><span class="string">    * '</span>epmutex<span class="string">' on add is to prevent complex toplogies such as loops and</span></span><br><span class="line"><span class="string">    * deep wakeup paths from forming in parallel through multiple</span></span><br><span class="line"><span class="string">    * EPOLL_CTL_ADD operations.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">    if (op == EPOLL_CTL_ADD) &#123;</span></span><br><span class="line"><span class="string">        if (!list_empty(&amp;f.file-&gt;f_ep_links) ||</span></span><br><span class="line"><span class="string">            is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">            full_check = 1;</span></span><br><span class="line"><span class="string">            mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string">            mutex_lock(&amp;epmutex);</span></span><br><span class="line"><span class="string">            if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">                error = -ELOOP;</span></span><br><span class="line"><span class="string">                if (ep_loop_check(ep, tf.file) != 0) &#123;</span></span><br><span class="line"><span class="string">                    clear_tfile_check_list();</span></span><br><span class="line"><span class="string">                    goto error_tgt_fput;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                list_add(&amp;tf.file-&gt;f_tfile_llink,</span></span><br><span class="line"><span class="string">                         &amp;tfile_check_list);</span></span><br><span class="line"><span class="string">            mutex_lock_nested(&amp;ep-&gt;mtx, 0);</span></span><br><span class="line"><span class="string">            if (is_file_epoll(tf.file)) &#123;</span></span><br><span class="line"><span class="string">                tep = tf.file-&gt;private_data;</span></span><br><span class="line"><span class="string">                mutex_lock_nested(&amp;tep-&gt;mtx, 1);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * Try to lookup the file inside our RB tree, Since we grabbed "mtx"</span></span><br><span class="line"><span class="string">    * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="string">    * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="string">    * 从红黑树中寻找添加的fd是否存在，存在则返回到ep中，否则返回NULL</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    epi = ep_find(ep, tf.file, fd);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    error = -EINVAL;</span></span><br><span class="line"><span class="string">    switch (op) &#123;</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_ADD:</span></span><br><span class="line"><span class="string">            // 若ep为空说明红黑树中不存在,执行ep_insert添加到红黑树中</span></span><br><span class="line"><span class="string">            if (!epi) &#123;</span></span><br><span class="line"><span class="string">                epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">                // 如果不存在则添加，已经存在不重复添加</span></span><br><span class="line"><span class="string">                error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                error = -EEXIST;</span></span><br><span class="line"><span class="string">            if (full_check)</span></span><br><span class="line"><span class="string">                clear_tfile_check_list();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        // 删除fd调用ep_remove</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_DEL:</span></span><br><span class="line"><span class="string">            if (epi)</span></span><br><span class="line"><span class="string">                error = ep_remove(ep, epi);</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                error = -ENOENT;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        // 修改已注册fd所监听的事件,调用ep_modify</span></span><br><span class="line"><span class="string">        case EPOLL_CTL_MOD:</span></span><br><span class="line"><span class="string">            if (epi) &#123;</span></span><br><span class="line"><span class="string">                if (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span></span><br><span class="line"><span class="string">                    epds.events |= EPOLLERR | EPOLLHUP;</span></span><br><span class="line"><span class="string">                    error = ep_modify(ep, epi, &amp;epds);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125; else</span></span><br><span class="line"><span class="string">                error = -ENOENT;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (tep != NULL)</span></span><br><span class="line"><span class="string">        mutex_unlock(&amp;tep-&gt;mtx);</span></span><br><span class="line"><span class="string">    mutex_unlock(&amp;ep-&gt;mtx);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_tgt_fput:</span></span><br><span class="line"><span class="string">    if (full_check)</span></span><br><span class="line"><span class="string">        mutex_unlock(&amp;epmutex);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fdput(tf);</span></span><br><span class="line"><span class="string">error_fput:</span></span><br><span class="line"><span class="string">    fdput(f);</span></span><br><span class="line"><span class="string">error_return:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return error;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="ep-find"><a href="#ep-find" class="headerlink" title="ep_find"></a>ep_find</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Search the file inside the eventpoll tree. The RB tree operations</span><br><span class="line"> * are protected by the <span class="string">"mtx"</span> mutex, and ep_find() must be called with</span><br><span class="line"> * <span class="string">"mtx"</span> held.</span><br><span class="line"> */</span><br><span class="line">static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int kcmp;</span><br><span class="line">    struct rb_node *rbp;</span><br><span class="line">    struct epitem *epi, *epir = NULL;</span><br><span class="line">    struct epoll_filefd ffd;</span><br><span class="line"></span><br><span class="line">    ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">    </span><br><span class="line">    // 从红黑树根节开始二分查找,判断左右子树</span><br><span class="line">    <span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">        kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">        <span class="keyword">if</span> (kcmp &gt; 0)</span><br><span class="line">            rbp = rbp-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; 0)</span><br><span class="line">            rbp = rbp-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            epir = epi;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> epir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ep-insert"><a href="#ep-insert" class="headerlink" title="ep_insert"></a>ep_insert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * Must be called with <span class="string">"mtx"</span> held.</span><br><span class="line"> */</span><br><span class="line">static int ep_insert(struct eventpoll *ep, const struct epoll_event *event,</span><br><span class="line">                     struct file *tfile, int fd, int full_check)</span><br><span class="line">&#123;</span><br><span class="line">    int error, pwake = 0;</span><br><span class="line">    __poll_t revents;</span><br><span class="line">    long user_watches;</span><br><span class="line">    struct epitem *epi;</span><br><span class="line"></span><br><span class="line">    struct ep_pqueue epq;</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">        <span class="built_in">return</span> -ENOSPC;</span><br><span class="line">    </span><br><span class="line">    // epi_cache内存池在epoll模块初始化时已经分配,这里根据slab直接取一个epitem</span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="built_in">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    // 初始化 epitem</span><br><span class="line">    /* Item initialization follow here ... */</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = 0;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">        error = ep_create_wakeup_source(epi);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            goto error_create_wakeup_source;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RCU_INIT_POINTER(epi-&gt;ws, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个struct ep_pqueue epq, 并与epitem(epi)关联</span><br><span class="line">    /* Initialize the poll table using the queue callback */</span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    </span><br><span class="line">    /* 设置epq的回调函数为ep_ptable_queue_proc,当调用poll_wait时会调用该回调函数，</span><br><span class="line">     * 而函数体ep_ptable_queue_proc内部所做的主要工作,</span><br><span class="line">     * 就是把epitem对应fd的事件到来时的回调函数设置为ep_poll_callback。</span><br><span class="line">     * ep_poll_callback所做的主要工作就是把就绪的fd放到就绪链表rdllist上,</span><br><span class="line">     * 然后唤醒epoll_wait的调用者, 被唤醒的进程再把rdllist上就绪的fd的events拷贝给用户进程,</span><br><span class="line">     * 完成一个闭环。</span><br><span class="line">     */</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Attach the item to the poll hooks and get current event bits.</span><br><span class="line">     * We can safely use the file* here because its usage count has</span><br><span class="line">     * been increased by the <span class="built_in">caller</span> of this <span class="keyword">function</span>. Note that after</span><br><span class="line">     * this operation completes, the poll callback can start hitting</span><br><span class="line">     * the new item.</span><br><span class="line">     * 判断当前插入的event是否刚好发生，返回就绪事件的掩码赋给revents,</span><br><span class="line">     * 如果发生，那么做一个ready动作，</span><br><span class="line">     * 后面的<span class="keyword">if</span>语句将epitem加入到rdlist中，并对epoll上的<span class="built_in">wait</span>队列调用wakeup</span><br><span class="line">     */</span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt, 1);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check <span class="keyword">if</span> something went wrong during the poll <span class="built_in">wait</span> queue</span><br><span class="line">    * install process. Namely an allocation <span class="keyword">for</span> a <span class="built_in">wait</span> queue failed due</span><br><span class="line">    * high memory pressure.</span><br><span class="line">    */</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; 0)</span><br><span class="line">        goto error_unregister;</span><br><span class="line"></span><br><span class="line">    /* Add the current item to the list of active epoll hook <span class="keyword">for</span> this file */</span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    </span><br><span class="line">    // 每个文件会将所有监听自己的epitem链起来</span><br><span class="line">    list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Add the current item to the RB tree. All RB tree operations are</span><br><span class="line">    * protected by <span class="string">"mtx"</span>, and ep_insert() is called with <span class="string">"mtx"</span> held.</span><br><span class="line">    * 将epitem插入到对应的eventpoll红黑树中去,红黑树用一个互斥锁进行保护</span><br><span class="line">    */</span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">    /* now check <span class="keyword">if</span> we<span class="string">'ve created too many backpaths */</span></span><br><span class="line"><span class="string">    error = -EINVAL;</span></span><br><span class="line"><span class="string">    if (full_check &amp;&amp; reverse_path_check())</span></span><br><span class="line"><span class="string">        goto error_remove_epi;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line"><span class="string">    write_lock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* record NAPI ID of new item if present */</span></span><br><span class="line"><span class="string">    ep_set_busy_poll_napi_id(epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* If the file is already "ready" we drop it inside the ready list */</span></span><br><span class="line"><span class="string">    if (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span></span><br><span class="line"><span class="string">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span></span><br><span class="line"><span class="string">        ep_pm_stay_awake(epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* Notify waiting tasks that events are available */</span></span><br><span class="line"><span class="string">        if (waitqueue_active(&amp;ep-&gt;wq))</span></span><br><span class="line"><span class="string">            wake_up(&amp;ep-&gt;wq);</span></span><br><span class="line"><span class="string">        if (waitqueue_active(&amp;ep-&gt;poll_wait))</span></span><br><span class="line"><span class="string">            pwake++;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    write_unlock_irq(&amp;ep-&gt;lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* We have to call this outside the lock */</span></span><br><span class="line"><span class="string">    if (pwake)</span></span><br><span class="line"><span class="string">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_remove_epi:</span></span><br><span class="line"><span class="string">    spin_lock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string">    list_del_rcu(&amp;epi-&gt;fllink);</span></span><br><span class="line"><span class="string">    spin_unlock(&amp;tfile-&gt;f_lock);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_unregister:</span></span><br><span class="line"><span class="string">    ep_unregister_pollwait(ep, epi);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * We need to do this because an event could have been arrived on some</span></span><br><span class="line"><span class="string">    * allocated wait queue. Note that we don'</span>t care about the ep-&gt;ovflist</span><br><span class="line">    * list, since that is used/cleaned only inside a section bound by <span class="string">"mtx"</span>.</span><br><span class="line">    * And ep_insert() is called with <span class="string">"mtx"</span> held.</span><br><span class="line">    */</span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(epi))</span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line"></span><br><span class="line">error_create_wakeup_source:</span><br><span class="line">    kmem_cache_free(epi_cache, epi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmem-cache-alloc"><a href="#kmem-cache-alloc" class="headerlink" title="kmem_cache_alloc"></a>kmem_cache_alloc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * slab算法从内存池cachep中分配一个实例返回</span><br><span class="line"> * mm/slab.c</span><br><span class="line"> * kmem_cache_alloc - Allocate an object</span><br><span class="line"> * @cachep: The cache to allocate from.</span><br><span class="line"> * @flags: See kmalloc().</span><br><span class="line"> *</span><br><span class="line"> * Allocate an object from this cache.  The flags are only relevant</span><br><span class="line"> * <span class="keyword">if</span> the cache has no available objects.</span><br><span class="line"> *</span><br><span class="line"> * Return: pointer to the new object or %NULL <span class="keyword">in</span> <span class="keyword">case</span> of error</span><br><span class="line"> */</span><br><span class="line">void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    void *ret = slab_alloc(cachep, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">    trace_kmem_cache_alloc(_RET_IP_, ret,</span><br><span class="line">                           cachep-&gt;object_size, cachep-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_alloc);</span><br></pre></td></tr></table></figure>
<h3 id="init-poll-funcptr-ep-ptable-queue-proc-ep-poll-callback-init-waitqueue-func-entry"><a href="#init-poll-funcptr-ep-ptable-queue-proc-ep-poll-callback-init-waitqueue-func-entry" class="headerlink" title="init_poll_funcptr/ep_ptable_queue_proc/ep_poll_callback/init_waitqueue_func_entry"></a>init_poll_funcptr/ep_ptable_queue_proc/ep_poll_callback/init_waitqueue_func_entry</h3><p>init_poll_funcptr：设置epq的回调函数为ep_ptable_queue_proc，当调用poll_wait时会调用该回调函数；<br>ep_ptable_queue_proc：该函数内部所做的主要工作，就是把epitem对应fd的事件到来时的回调函数设置为ep_poll_callback。<br>ep_poll_callback：主要工作就是把就绪的fd放到就绪链表rdllist上，然后唤醒epoll_wait的调用者，被唤醒的进程再把rdllist上就绪的fd的events拷贝给用户进程，完成一个闭环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 设置回调</span><br><span class="line"> * include/linux/poll.h</span><br><span class="line"> */</span><br><span class="line">static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)</span><br><span class="line">&#123;</span><br><span class="line">    pt-&gt;_qproc = qproc;</span><br><span class="line">    pt-&gt;_key   = ~(__poll_t)0; /* all events enabled */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This is the callback that is used to add our <span class="built_in">wait</span> queue to the</span><br><span class="line"> * target file wakeup lists.</span><br><span class="line"> * struct file *file（目标文件）= epi-&gt;ffd.file,</span><br><span class="line"> * wait_queue_head_t *whead（目标文件的waitlist）= eventpoll-&gt;poll_wait,</span><br><span class="line"> * poll_table *pt（前面生成的poll_table）</span><br><span class="line"> */</span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,poll_table *pt)</span><br><span class="line">&#123;</span><br><span class="line">    struct epitem *epi = ep_item_from_epqueue(pt);</span><br><span class="line">    // 创建一个struct eppoll_entry,与对应的epitem关联上</span><br><span class="line">    struct eppoll_entry *pwq;</span><br><span class="line">    </span><br><span class="line">    // 从pwq_cache内存池中取一个struct eppoll_entry</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        // 把每个epitem对应的回调函数设置为ep_poll_callback,</span><br><span class="line">        // 当epitem关注的事件中断到来时会执行回调函数ep_poll_callback</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;<span class="built_in">wait</span>, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        // 关联上epitem</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        // 通过add_wait_queue将epoll_entry挂载到目标文件的waitlist。</span><br><span class="line">        // 完成这个动作后，epoll_entry已经被挂载到waitlist</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">            add_wait_queue_exclusive(whead, &amp;pwq-&gt;<span class="built_in">wait</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add_wait_queue(whead, &amp;pwq-&gt;<span class="built_in">wait</span>);</span><br><span class="line">        // eppoll_entry-&gt;llink执行epitem-&gt;pwqlist</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /* We have to signal that an error occurred */</span><br><span class="line">        epi-&gt;nwait = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// include/linux/wait.h</span><br><span class="line">static inline void init_waitqueue_func_entry(struct wait_queue_entry *wq_entry,</span><br><span class="line">                                            wait_queue_func_t func)</span><br><span class="line">&#123;</span><br><span class="line">    wq_entry-&gt;flags        = 0;</span><br><span class="line">    wq_entry-&gt;private      = NULL;</span><br><span class="line">    wq_entry-&gt;func         = func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * fs/eventpoll.c</span><br><span class="line"> * This is the callback that is passed to the <span class="built_in">wait</span> queue wakeup</span><br><span class="line"> * mechanism. It is called by the stored file descriptors when they</span><br><span class="line"> * have events to report.</span><br><span class="line"> *</span><br><span class="line"> * This callback takes a <span class="built_in">read</span> lock <span class="keyword">in</span> order not to content with concurrent</span><br><span class="line"> * events from another file descriptors, thus all modifications to -&gt;rdllist</span><br><span class="line"> * or -&gt;ovflist are lockless.  Read lock is paired with the write lock from</span><br><span class="line"> * ep_scan_ready_list(), <span class="built_in">which</span> stops all list modifications and guarantees</span><br><span class="line"> * that lists state is seen correctly.</span><br><span class="line"> *</span><br><span class="line"> * Another thing worth to mention is that ep_poll_callback() can be called</span><br><span class="line"> * concurrently <span class="keyword">for</span> the same @epi from different CPUs <span class="keyword">if</span> poll table was inited</span><br><span class="line"> * with several <span class="built_in">wait</span> queues entries.  Plural wakeup from different CPUs of a</span><br><span class="line"> * single <span class="built_in">wait</span> queue is serialized by wq.lock, but the <span class="keyword">case</span> when multiple <span class="built_in">wait</span></span><br><span class="line"> * queues are used should be detected accordingly.  This is detected using</span><br><span class="line"> * cmpxchg() operation.</span><br><span class="line"> */</span><br><span class="line">static int ep_poll_callback(wait_queue_entry_t *<span class="built_in">wait</span>, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    struct epitem *epi = ep_item_from_wait(<span class="built_in">wait</span>);</span><br><span class="line">    struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line">    __poll_t pollflags = key_to_poll(key);</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    int ewake = 0;</span><br><span class="line">    </span><br><span class="line">    read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    </span><br><span class="line">    ep_set_busy_poll_napi_id(epi);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * If the event mask does not contain any poll(2) event, we consider the</span><br><span class="line">     * descriptor to be disabled. This condition is likely the effect of the</span><br><span class="line">     * EPOLLONESHOT bit that disables the descriptor when an event is received,</span><br><span class="line">     * until the next EPOLL_CTL_MOD will be issued.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        goto out_unlock;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * Check the events coming with the callback. At this stage, not</span><br><span class="line">     * every device reports the events <span class="keyword">in</span> the <span class="string">"key"</span> parameter of the</span><br><span class="line">     * callback. We need to be able to handle both cases here, hence the</span><br><span class="line">     * <span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"key"</span> != NULL before the event match <span class="built_in">test</span>.</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        goto out_unlock;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * If we are transferring events to userspace, we can hold no locks</span><br><span class="line">     * (because we<span class="string">'re accessing user memory, and because of linux f_op-&gt;poll()</span></span><br><span class="line"><span class="string">     * semantics). All the events that happen during that period of time are</span></span><br><span class="line"><span class="string">     * chained in ep-&gt;ovflist and requeued later on.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    if (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span></span><br><span class="line"><span class="string">        // epi-&gt;next == EP_UNACTIVE_PTR说明rdllist当前被其他进程持有,</span></span><br><span class="line"><span class="string">        // 因此调用chain_epi_lockless把epitem放入vovflist上</span></span><br><span class="line"><span class="string">        if (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp; chain_epi_lockless(epi))</span></span><br><span class="line"><span class="string">            ep_pm_stay_awake_rcu(epi);</span></span><br><span class="line"><span class="string">        goto out_unlock;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // rdllist抢占成功,调用list_add_tail_lockless把epitem挂入rdllist上</span></span><br><span class="line"><span class="string">    /* If this file is already in the ready list we exit soon */</span></span><br><span class="line"><span class="string">    if (!ep_is_linked(epi) &amp;&amp; list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span></span><br><span class="line"><span class="string">        ep_pm_stay_awake_rcu(epi);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="string">     * wait list.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    if (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span></span><br><span class="line"><span class="string">        if ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span></span><br><span class="line"><span class="string">            !(pollflags &amp; POLLFREE)) &#123;</span></span><br><span class="line"><span class="string">            switch (pollflags &amp; EPOLLINOUT_BITS) &#123;</span></span><br><span class="line"><span class="string">                case EPOLLIN:</span></span><br><span class="line"><span class="string">                    if (epi-&gt;event.events &amp; EPOLLIN)</span></span><br><span class="line"><span class="string">                        ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                case EPOLLOUT:</span></span><br><span class="line"><span class="string">                    if (epi-&gt;event.events &amp; EPOLLOUT)</span></span><br><span class="line"><span class="string">                        ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                case 0:</span></span><br><span class="line"><span class="string">                    ewake = 1;</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 同时唤醒eventpoll的wq等待队列,也就是唤醒poll_wait的调用者</span></span><br><span class="line"><span class="string">        wake_up(&amp;ep-&gt;wq);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (waitqueue_active(&amp;ep-&gt;poll_wait))</span></span><br><span class="line"><span class="string">        pwake++;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">out_unlock:</span></span><br><span class="line"><span class="string">    read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* We have to call this outside the lock */</span></span><br><span class="line"><span class="string">    if (pwake)</span></span><br><span class="line"><span class="string">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span></span><br><span class="line"><span class="string">        ewake = 1;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (pollflags &amp; POLLFREE) &#123;</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">         * If we race with ep_remove_wait_queue() it can miss</span></span><br><span class="line"><span class="string">         * -&gt;whead = NULL and do another remove_wait_queue() after</span></span><br><span class="line"><span class="string">         * us, so we can'</span>t use __remove_wait_queue().</span><br><span class="line">         */</span><br><span class="line">        list_del_init(&amp;<span class="built_in">wait</span>-&gt;entry);</span><br><span class="line">        /*</span><br><span class="line">         * -&gt;whead != NULL protects us from the race with ep_free()</span><br><span class="line">         * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span><br><span class="line">         * held by the <span class="built_in">caller</span>. Once we nullify it, nothing protects</span><br><span class="line">         * ep/epi or even <span class="built_in">wait</span>.</span><br><span class="line">         */</span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(<span class="built_in">wait</span>)-&gt;whead, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ep-item-poll-poll-wait-ep-scan-ready-list"><a href="#ep-item-poll-poll-wait-ep-scan-ready-list" class="headerlink" title="ep_item_poll/poll_wait/ep_scan_ready_list"></a>ep_item_poll/poll_wait/ep_scan_ready_list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Differs from ep_eventpoll_poll() <span class="keyword">in</span> that internal callers already have</span><br><span class="line"> * the ep-&gt;mtx so we need to start from depth=1, such that mutex_lock_nested()</span><br><span class="line"> * is correctly annotated.</span><br><span class="line"> */</span><br><span class="line">static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,int depth)</span><br><span class="line">&#123;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    bool locked;</span><br><span class="line"></span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">        <span class="built_in">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">    // 拿到eventpoll,回头过去看UML数据结构,private_data是指向eventpoll的</span><br><span class="line">    ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">    // 这里面会执行前面设置的ep_ptable_queue_proc回调体</span><br><span class="line">    // ep_ptable_queue_proc函数体的工作在前面已经介绍过</span><br><span class="line">    poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">    locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    // 把就绪链表rdllist拷贝到用户空间</span><br><span class="line">    <span class="built_in">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">                              ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">                              locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// include/linux/poll.h</span><br><span class="line">static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address,</span><br><span class="line">                             poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ep_scan_ready_list - Scans the ready list <span class="keyword">in</span> a way that makes possible <span class="keyword">for</span></span><br><span class="line"> *                      the scan code, to call f_op-&gt;poll(). Also allows <span class="keyword">for</span></span><br><span class="line"> *                      O(NumReady) performance.</span><br><span class="line"> *</span><br><span class="line"> * @ep: Pointer to the epoll private data structure.</span><br><span class="line"> * @sproc: Pointer to the scan callback.</span><br><span class="line"> * @priv: Private opaque data passed to the @sproc callback.</span><br><span class="line"> * @depth: The current depth of recursive f_op-&gt;poll calls.</span><br><span class="line"> * @ep_locked: <span class="built_in">caller</span> already holds ep-&gt;mtx</span><br><span class="line"> *</span><br><span class="line"> * Returns: The same <span class="built_in">integer</span> error code returned by the @sproc callback.</span><br><span class="line"> */</span><br><span class="line">static __poll_t ep_scan_ready_list(struct eventpoll *ep,</span><br><span class="line">                                   __poll_t (*sproc)(struct eventpoll *,</span><br><span class="line">                                   struct list_head *, void *),void *priv,</span><br><span class="line">                                   int depth, bool ep_locked)</span><br><span class="line">&#123;</span><br><span class="line">    __poll_t res;</span><br><span class="line">    int pwake = 0;</span><br><span class="line">    struct epitem *epi, *nepi;</span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We need to lock this because we could be hit by</span><br><span class="line">    * eventpoll_release_file() and epoll_ctl().</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_locked)</span><br><span class="line">        mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Steal the ready list, and re-init the original one to the</span><br><span class="line">    * empty list. Also, <span class="built_in">set</span> ep-&gt;ovflist to NULL so that events</span><br><span class="line">    * happening <span class="keyword">while</span> looping w/out locks, are not lost. We cannot</span><br><span class="line">    * have the poll callback to queue directly on ep-&gt;rdllist,</span><br><span class="line">    * because we want the <span class="string">"sproc"</span> callback to be able to <span class="keyword">do</span> it</span><br><span class="line">    * <span class="keyword">in</span> a lockless way.</span><br><span class="line">    */</span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    // 把就绪链表rdllist赋给临时的txlist,执行该操作后rdllist会被清空,</span><br><span class="line">    // 因为rdllist需要腾出来给其他进程继续往上放内容,</span><br><span class="line">    // 从而把txlist内epitem对应fd的就绪events复制到用户空间</span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    WRITE_ONCE(ep-&gt;ovflist, NULL);</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * sproc就是前面设置好的ep_poll_callback,事件到来了执行该回调体,</span><br><span class="line">    * sproc会把就绪的epitem放入rdllist或ovflist上</span><br><span class="line">    * Now call the callback <span class="keyword">function</span>.</span><br><span class="line">    */</span><br><span class="line">    res = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">    write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">    /*</span><br><span class="line">    * During the time we spent inside the <span class="string">"sproc"</span> callback, some</span><br><span class="line">    * other events might have been queued by the poll callback.</span><br><span class="line">    * We re-insert them inside the main ready-list here.</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != NULL;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        /*</span><br><span class="line">        * We need to check <span class="keyword">if</span> the item is already <span class="keyword">in</span> the list.</span><br><span class="line">        * During the <span class="string">"sproc"</span> callback execution time, items are</span><br><span class="line">        * queued into -&gt;ovflist but the <span class="string">"txlist"</span> might already</span><br><span class="line">        * contain them, and the list_splice() below takes care of them.</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">            /*</span><br><span class="line">            * -&gt;ovflist is LIFO, so we have to reverse it <span class="keyword">in</span> order</span><br><span class="line">            * to keep <span class="keyword">in</span> FIFO.</span><br><span class="line">            */</span><br><span class="line">            list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">                ep_pm_stay_awake(epi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    * We need to <span class="built_in">set</span> back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span><br><span class="line">    * releasing the lock, events will be queued <span class="keyword">in</span> the normal way inside</span><br><span class="line">    * ep-&gt;rdllist.</span><br><span class="line">    */</span><br><span class="line">    WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * 把水平触发EPOLLLT属性的epitem依旧挂回到rdllist,</span><br><span class="line">    * 因为我们希望即使没有新的数据到来,只要数据还没被用户空间读完,就继续上报</span><br><span class="line">    * Quickly re-inject items left on <span class="string">"txlist"</span>.</span><br><span class="line">    */</span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">    __pm_relax(ep-&gt;ws);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        /*</span><br><span class="line">        * Wake up (<span class="keyword">if</span> active) both the eventpoll <span class="built_in">wait</span> list and</span><br><span class="line">        * the -&gt;poll() <span class="built_in">wait</span> list (delayed after we release the lock).</span><br><span class="line">        * wake_up唤醒epoll_wait的调用者</span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_locked)</span><br><span class="line">        mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    /* We have to call this outside the lock */</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，epoll_ctl的分析就已经完了，这里只描述的EPOLL_CTL_ADD调用。EPOLL_CTL_MOD/EPOLL_CTL_DEL相对就简单很多，这三个操作差异主要体现在fs/eventpoll.c文件内接口SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,struct epoll_event __user*, event)的switch语句部分，EPOLL_CTL_MOD和EPOLL_CTL_DEL分别对应ep_modify和ep_remove，这两个函数就是从红黑树中去找到对应的节点进行修改和删除操作，因此这里没有贴代码。</p>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><h3 id="epoll-wait陷入内核"><a href="#epoll-wait陷入内核" class="headerlink" title="epoll_wait陷入内核"></a>epoll_wait陷入内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// fs/eventpoll.c</span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *,</span><br><span class="line">                events,int, maxevents, int, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> do_epoll_wait(epfd, events, maxevents, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-epoll-wait-ep-poll-ep-send-events-ep-send-events-proc"><a href="#do-epoll-wait-ep-poll-ep-send-events-ep-send-events-proc" class="headerlink" title="do_epoll_wait/ep_poll/ep_send_events/ep_send_events_proc"></a>do_epoll_wait/ep_poll/ep_send_events/ep_send_events_proc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Implement the event <span class="built_in">wait</span> interface <span class="keyword">for</span> the eventpoll file. It is the kernel</span><br><span class="line"> * part of the user space epoll_wait(2).</span><br><span class="line"> */</span><br><span class="line">static int do_epoll_wait(int epfd, struct epoll_event __user *events,</span><br><span class="line">                         int maxevents, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int error;</span><br><span class="line">    // struct fd结构在数据结构部分代码已经列出</span><br><span class="line">    struct fd f;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* The maximum number of event must be greater than zero */</span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="built_in">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* Verify that the area passed by the user is writeable */</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(events, maxevents * sizeof(struct epoll_event)))</span><br><span class="line">        <span class="built_in">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    /* Get the <span class="string">"struct file *"</span> <span class="keyword">for</span> the eventpoll file */</span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="built_in">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We have to check that the file structure underneath the fd</span><br><span class="line">    * the user passed to us _is_ an eventpoll file.</span><br><span class="line">    */</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(f.file))</span><br><span class="line">        goto error_fput;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * At this point it is safe to assume that the <span class="string">"private_data"</span> contains</span><br><span class="line">    * our own data structure.</span><br><span class="line">    * 直接拿到eventpoll对象</span><br><span class="line">    */</span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    // ep_poll时主循环体,当rdllist为空时调用者根据设置的超时参数,</span><br><span class="line">    // 决定是等待还是返回</span><br><span class="line">    /* Time to fish <span class="keyword">for</span> events ... */</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="built_in">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ep_poll - Retrieves ready events, and delivers them to the <span class="built_in">caller</span> supplied</span><br><span class="line"> *           event buffer.</span><br><span class="line"> *</span><br><span class="line"> * @ep: Pointer to the eventpoll context.</span><br><span class="line"> * @events: Pointer to the userspace buffer <span class="built_in">where</span> the ready events should be</span><br><span class="line"> *          stored.</span><br><span class="line"> * @maxevents: Size (<span class="keyword">in</span> terms of number of events) of the <span class="built_in">caller</span> event buffer.</span><br><span class="line"> * @timeout: Maximum timeout <span class="keyword">for</span> the ready events fetch operation, <span class="keyword">in</span></span><br><span class="line"> *           milliseconds. If the @timeout is zero, the <span class="keyword">function</span> will not block,</span><br><span class="line"> *           <span class="keyword">while</span> <span class="keyword">if</span> the @timeout is less than zero, the <span class="keyword">function</span> will block</span><br><span class="line"> *           until at least one event has been retrieved (or an error</span><br><span class="line"> *           occurred).</span><br><span class="line"> *</span><br><span class="line"> * Returns: Returns the number of ready events <span class="built_in">which</span> have been fetched, or an</span><br><span class="line"> *          error code, <span class="keyword">in</span> <span class="keyword">case</span> of error.</span><br><span class="line"> */</span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,</span><br><span class="line">                   int maxevents, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, eavail, timed_out = 0;</span><br><span class="line">    u64 slack = 0;</span><br><span class="line">    bool waiter = <span class="literal">false</span>;</span><br><span class="line">    wait_queue_entry_t <span class="built_in">wait</span>;</span><br><span class="line">    ktime_t expires, *to = NULL;</span><br><span class="line"></span><br><span class="line">    lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">    // 超时设置</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; 0) &#123;</span><br><span class="line">        struct timespec64 end_time = ep_set_mstimeout(timeout);</span><br><span class="line"></span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">        to = &amp;expires;</span><br><span class="line">        *to = timespec64_to_ktime(end_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == 0) &#123; // 立即返回</span><br><span class="line">        /*</span><br><span class="line">        * Avoid the unnecessary trip to the <span class="built_in">wait</span> queue loop, <span class="keyword">if</span> the</span><br><span class="line">        * <span class="built_in">caller</span> specified a non blocking operation. We still need</span><br><span class="line">        * lock because we could race and not see an epi being added</span><br><span class="line">        * to the ready list <span class="keyword">while</span> <span class="keyword">in</span> irq callback. Thus incorrectly</span><br><span class="line">        * returning 0 back to userspace.</span><br><span class="line">        */</span><br><span class="line">        timed_out = 1;</span><br><span class="line"></span><br><span class="line">        write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">        eavail = ep_events_available(ep);</span><br><span class="line">        write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">        goto send_events;</span><br><span class="line">    &#125;// 否则是永久等待,直到有新的事件到来</span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep))</span><br><span class="line">        ep_busy_loop(ep, timed_out);</span><br><span class="line"></span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line">    <span class="keyword">if</span> (eavail)</span><br><span class="line">        goto send_events;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * Busy poll timed out.  Drop NAPI ID <span class="keyword">for</span> now, we can add</span><br><span class="line">    * it back <span class="keyword">in</span> when we have moved a socket with a valid NAPI</span><br><span class="line">    * ID onto the ready list.</span><br><span class="line">    */</span><br><span class="line">    ep_reset_busy_poll_napi_id(ep);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We don<span class="string">'t have any available event to return to the caller.  We need</span></span><br><span class="line"><span class="string">    * to sleep here, and we will be woken by ep_poll_callback() when events</span></span><br><span class="line"><span class="string">    * become available.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">    if (!waiter) &#123;</span></span><br><span class="line"><span class="string">        waiter = true;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        // ep-&gt;rdllist存放的是已就绪(read)的fd，为空时说明当前没有就绪的fd,</span></span><br><span class="line"><span class="string">        // 创建一个等待队列,并使用当前进程（current）初始化</span></span><br><span class="line"><span class="string">        init_waitqueue_entry(&amp;wait, current);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">        // 将当前进程添加到等待队列</span></span><br><span class="line"><span class="string">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span></span><br><span class="line"><span class="string">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for (;;) &#123;</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">        * We don'</span>t want to sleep <span class="keyword">if</span> the ep_poll_callback() sends us</span><br><span class="line">        * a wakeup <span class="keyword">in</span> between. That<span class="string">'s why we set the task state</span></span><br><span class="line"><span class="string">        * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="string">        */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        set_current_state(TASK_INTERRUPTIBLE);</span></span><br><span class="line"><span class="string">        /*</span></span><br><span class="line"><span class="string">        * Always short-circuit for fatal signals to allow</span></span><br><span class="line"><span class="string">        * threads to make a timely exit without the chance of</span></span><br><span class="line"><span class="string">        * finding more events available and fetching</span></span><br><span class="line"><span class="string">        * repeatedly.</span></span><br><span class="line"><span class="string">        */</span></span><br><span class="line"><span class="string">        if (fatal_signal_pending(current)) &#123;</span></span><br><span class="line"><span class="string">            res = -EINTR;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // ep_events_available内部会判断rdllist是否为空</span></span><br><span class="line"><span class="string">        eavail = ep_events_available(ep);</span></span><br><span class="line"><span class="string">        if (eavail)</span></span><br><span class="line"><span class="string">            break; // 循环体,如果rdllist不为空,则跳出循环体,进入send_events</span></span><br><span class="line"><span class="string">        if (signal_pending(current)) &#123;</span></span><br><span class="line"><span class="string">            res = -EINTR;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span></span><br><span class="line"><span class="string">            timed_out = 1;</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __set_current_state(TASK_RUNNING);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">send_events:</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="string">    * there'</span>s still timeout left over, we go trying again <span class="keyword">in</span> search of</span><br><span class="line">    * more luck.</span><br><span class="line">    * ep_send_events接口复制txlist内epitem对应fd的就绪events到用户空间</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp; !(res = ep_send_events(ep, events, maxevents))</span><br><span class="line">        &amp;&amp; !timed_out)</span><br><span class="line">        goto fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waiter) &#123;</span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">        // 将当前进程移出等待队列</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;<span class="built_in">wait</span>);</span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs/eventpoll.c</span><br><span class="line">static int ep_send_events(struct eventpoll *ep,</span><br><span class="line">                          struct epoll_event __user *events, int maxevents)</span><br><span class="line">&#123;</span><br><span class="line">    struct ep_send_events_data esed;</span><br><span class="line"></span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line"></span><br><span class="line">    // 传入ep_send_events_proc</span><br><span class="line">    ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">return</span> esed.res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实际执行复制到用户空间的工作是由该函数体负责</span><br><span class="line">static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head,void *priv)</span><br><span class="line">&#123;</span><br><span class="line">    struct ep_send_events_data *esed = priv;</span><br><span class="line">    __poll_t revents;</span><br><span class="line">    struct epitem *epi, *tmp;</span><br><span class="line">    struct epoll_event __user *uevent = esed-&gt;events;</span><br><span class="line">    struct wakeup_source *ws;</span><br><span class="line">    poll_table pt;</span><br><span class="line"></span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);</span><br><span class="line">    esed-&gt;res = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * We can loop without lock because we are passed a task private list.</span><br><span class="line">    * Items cannot vanish during the loop because ep_scan_ready_list() is</span><br><span class="line">    * holding <span class="string">"mtx"</span> during this call.</span><br><span class="line">    */</span><br><span class="line">    lockdep_assert_held(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    // lambda表达式</span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">        <span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent</span><br><span class="line">        * triggering auto-suspend here (<span class="keyword">in</span> <span class="keyword">case</span> we reactive epi-&gt;ws</span><br><span class="line">        * below).</span><br><span class="line">        *</span><br><span class="line">        * This could be rearranged to delay the deactivation of epi-&gt;ws</span><br><span class="line">        * instead, but <span class="keyword">then</span> epi-&gt;ws would temporarily be out of sync</span><br><span class="line">        * with ep_is_linked().</span><br><span class="line">        */</span><br><span class="line">        ws = ep_wakeup_source(epi);</span><br><span class="line">        <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">                __pm_stay_awake(ep-&gt;ws);</span><br><span class="line">            __pm_relax(ws);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        * If the event mask intersect the <span class="built_in">caller</span>-requested one,</span><br><span class="line">        * deliver the event to userspace. Again, ep_scan_ready_list()</span><br><span class="line">        * is holding ep-&gt;mtx, so no operations coming from userspace</span><br><span class="line">        * can change the item.</span><br><span class="line">        */</span><br><span class="line">        revents = ep_item_poll(epi, &amp;pt, 1);</span><br><span class="line">        <span class="keyword">if</span> (!revents)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">        // 复制到用户空间</span><br><span class="line">        <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">            __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">            list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">            ep_pm_stay_awake(epi);</span><br><span class="line">            <span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">                esed-&gt;res = -EFAULT;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;</span><br><span class="line">        esed-&gt;res++;</span><br><span class="line">        uevent++;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">            epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">            /*</span><br><span class="line">            * If this file has been added with Level</span><br><span class="line">            * Trigger mode, we need to insert back inside</span><br><span class="line">            * the ready list, so that the next call to</span><br><span class="line">            * epoll_wait() will check again the events</span><br><span class="line">            * availability. At this point, no one can insert</span><br><span class="line">            * into ep-&gt;rdllist besides us. The epoll_ctl()</span><br><span class="line">            * callers are locked out by</span><br><span class="line">            * ep_scan_ready_list() holding <span class="string">"mtx"</span> and the</span><br><span class="line">            * poll callback will queue them <span class="keyword">in</span> ep-&gt;ovflist.</span><br><span class="line">            */</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            ep_pm_stay_awake(epi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/rankun1/article/details/69938640" rel="external nofollow noopener noreferrer" target="_blank">epoll react</a><br>[2] <a href="https://blog.csdn.net/zhaobryant/article/details/80557262" rel="external nofollow noopener noreferrer" target="_blank">linux epoll源码分析</a><br>[3] <a href="https://baijiahao.baidu.com/s?id=1611547498841608701&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">IO复用select/poll/epoll</a><br>[4] <a href="https://www.cnblogs.com/Anker/p/3263780.html" rel="external nofollow noopener noreferrer" target="_blank">IO复用epoll</a><br>[5] <a href="https://www.linuxidc.com/Linux/2019-02/157109.htm" rel="external nofollow noopener noreferrer" target="_blank">linux epoll源码</a><br>[6] <a href="http://blog.chinaunix.net/uid-28541347-id-4238524.html" rel="external nofollow noopener noreferrer" target="_blank">linux poll/epoll实现</a><br>[7] <a href="https://github.com/torvalds/linux" rel="external nofollow noopener noreferrer" target="_blank">linux源码github仓库</a></p>

      
    </div>

    

    
    
    
    <div>
     
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/06/03/epoll-source/">epoll源码分析(基于linux-5.1.4)</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 杨宇 的个人博客">杨宇</a></p>
  <p><span>发布时间:</span>2019年06月03日 - 12:06</p>
  <p><span>最后更新:</span>2019年06月08日 - 02:06</p>
  <p><span>原始链接:</span><a href="/2019/06/03/epoll-source/" title="epoll源码分析(基于linux-5.1.4)">https://icoty.github.io/2019/06/03/epoll-source/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://icoty.github.io/2019/06/03/epoll-source/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
    });
    });
</script>


      
    </div>

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>打赏狗粮！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="杨宇 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="杨宇 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/epoll/" rel="tag"><i class="fa fa-tag"></i> epoll</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/25/cs-threadpool-message-queue/" rel="next" title="基于线程池、消息队列和epoll模型实现并发服务器架构">
                <i class="fa fa-chevron-left"></i> 基于线程池、消息队列和epoll模型实现并发服务器架构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/08/xv6-filesystem/" rel="prev" title="XV6源代码阅读-文件系统">
                XV6源代码阅读-文件系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="杨宇">
            
              <p class="site-author-name" itemprop="name">杨宇</p>
              <div class="site-description motion-element" itemprop="description">后台 / 系统</div>
          </div>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/icoty" title="GitHub &rarr; https://github.com/icoty" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/icoty23" title="博客园 &rarr; https://www.cnblogs.com/icoty23" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-spinner"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/qq_36347375" title="CSDN &rarr; https://blog.csdn.net/qq_36347375" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-copyright"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:icoty.yangy@gmail.com" title="E-mail &rarr; mailto:icoty.yangy@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://laibh.top" title="http://laibh.top" rel="external nofollow noopener noreferrer" target="_blank">赖同学</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核数据结构"><span class="nav-number">2.</span> <span class="nav-text">内核数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局调用关系"><span class="nav-number">3.</span> <span class="nav-text">全局调用关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll模块初始化-amp-内存池开辟"><span class="nav-number">4.</span> <span class="nav-text">epoll模块初始化&amp;内存池开辟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-create"><span class="nav-number">5.</span> <span class="nav-text">epoll_create</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-create-epoll-create1陷入内核"><span class="nav-number">5.1.</span> <span class="nav-text">epoll_create/epoll_create1陷入内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-epoll-create-ep-alloc"><span class="nav-number">5.2.</span> <span class="nav-text">do_epoll_create/ep_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anon-inode-getfile-alloc-file-pseudo-alloc-file"><span class="nav-number">5.3.</span> <span class="nav-text">anon_inode_getfile/alloc_file_pseudo/alloc_file</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">6.</span> <span class="nav-text">epoll_ctl</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-ctl陷入内核"><span class="nav-number">6.1.</span> <span class="nav-text">epoll_ctl陷入内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ep-find"><span class="nav-number">6.2.</span> <span class="nav-text">ep_find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ep-insert"><span class="nav-number">6.3.</span> <span class="nav-text">ep_insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmem-cache-alloc"><span class="nav-number">6.4.</span> <span class="nav-text">kmem_cache_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init-poll-funcptr-ep-ptable-queue-proc-ep-poll-callback-init-waitqueue-func-entry"><span class="nav-number">6.5.</span> <span class="nav-text">init_poll_funcptr/ep_ptable_queue_proc/ep_poll_callback/init_waitqueue_func_entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ep-item-poll-poll-wait-ep-scan-ready-list"><span class="nav-number">6.6.</span> <span class="nav-text">ep_item_poll/poll_wait/ep_scan_ready_list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait"><span class="nav-number">7.</span> <span class="nav-text">epoll_wait</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-wait陷入内核"><span class="nav-number">7.1.</span> <span class="nav-text">epoll_wait陷入内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-epoll-wait-ep-poll-ep-send-events-ep-send-events-proc"><span class="nav-number">7.2.</span> <span class="nav-text">do_epoll_wait/ep_poll/ep_send_events/ep_send_events_proc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">8.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="20" width="270" height="42" src="//music.163.com/outchain/player?type=0&id=2768835095&auto=0&height=32"></iframe>

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨宇</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">165k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">2:30</span>
  
</div>










        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'zWlHCMwekbEgyjRmAxWLoIR4-gzGzoHsz',
    appKey: 'LbfEX3cmne22ibHj9hcwButY',
    placeholder: '欢迎探讨，留下你的邮箱能够收到我的回复喔！',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  

  

  

  

  

  

  

  

  

</body>
</html>
